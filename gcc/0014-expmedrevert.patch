diff --git a/gcc/config/h8300/h8300.md b/gcc/config/h8300/h8300.md
index 89bfcf11126..2332a1ea135 100644
--- a/gcc/config/h8300/h8300.md
+++ b/gcc/config/h8300/h8300.md
@@ -235,6 +235,7 @@
 (define_code_iterator ors [ior xor])
 
 (define_code_iterator eqne [eq ne])
+(define_code_attr eqne_invert [(eq "ne") (ne "eq")])
 
 ;; For storing the C flag, map from the unsigned comparison to the right
 ;; code for testing the C bit.
diff --git a/gcc/config/h8300/testcompare.md b/gcc/config/h8300/testcompare.md
index 9ff7a51077e..4b87fd279dd 100644
--- a/gcc/config/h8300/testcompare.md
+++ b/gcc/config/h8300/testcompare.md
@@ -61,6 +61,15 @@
   "mov.b	%t0,%t0"
   [(set_attr "length" "2")])
 
+(define_insn "*tsthi_upper_z"
+  [(set (reg:CCZ CC_REG)
+	(compare (and:HI (match_operand:HI 0 "register_operand" "r")
+			 (const_int -256))
+		 (const_int 0)))]
+  "reload_completed"
+  "mov.b	%t0,%t0"
+  [(set_attr "length" "2")])
+
 (define_insn "*tstsi_upper"
   [(set (reg:CCZN CC_REG)
 	(compare (and:SI (match_operand:SI 0 "register_operand" "r")
@@ -86,6 +95,22 @@
   }
   [(set_attr "length_table" "add")])
 
+(define_insn "*cmpqi_z"
+  [(set (reg:CCZ CC_REG)
+	(eq (match_operand:QI 0 "h8300_dst_operand" "rQ")
+	    (match_operand:QI 1 "h8300_src_operand" "rQi")))]
+  "reload_completed"
+  { return "cmp.b	%X1,%X0"; }
+  [(set_attr "length_table" "add")])
+
+(define_insn "*cmphi_z"
+  [(set (reg:CCZ CC_REG)
+	(eq (match_operand:HI 0 "h8300_dst_operand" "rQ")
+	    (match_operand:HI 1 "h8300_src_operand" "rQi")))]
+  "reload_completed"
+  { return "cmp.w	%T1,%T0"; }
+  [(set_attr "length_table" "add")])
+
 (define_insn "*cmpqi"
   [(set (reg:CC CC_REG)
 	(compare (match_operand:QI 0 "h8300_dst_operand" "rQ")
@@ -209,6 +234,8 @@
 	  return "xor.l\t%S0,%S0\;bist\t#0,%w0";
 	gcc_unreachable ();
       }
+    else
+      gcc_unreachable ();
   }
   [(set (attr "length") (symbol_ref "<MODE>mode == SImode ? 6 : 4"))])
 
@@ -224,3 +251,98 @@
 	(ltu:CCC (match_dup 1) (match_dup 2)))
    (set (match_dup 0)
 	(<geultu_to_c>:QHSI (reg:CCC CC_REG) (const_int 0)))])
+
+;; Storing Z into a QImode destination is fairly easy on the H8/S and
+;; newer as the stc; shift; mask is just 3 insns/6 bytes.  On the H8/300H
+;; it is 4 insns/8 bytes which is a speed improvement, but a size
+;; regression relative to the branchy sequence
+;;
+;; Storing inverted Z in QImode is not profitable on the H8/300H, but
+;; is a speed improvement on the H8S.
+(define_insn_and_split "*store_z_qi"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(eq:QI (match_operand:HI 1 "register_operand" "r")
+	       (match_operand:HI 2 "register_operand" "r")))]
+  "TARGET_H8300S || !optimize_size"
+  "#"
+  "&& reload_completed"
+  [(set (reg:CCZ CC_REG)
+	(eq:CCZ (match_dup 1) (match_dup 2)))
+   (set (match_dup 0)
+	(ne:QI (reg:CCZ CC_REG) (const_int 0)))])
+
+(define_insn_and_split "*store_z_i_qi"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(ne:QI (match_operand:HI 1 "register_operand" "r")
+	       (match_operand:HI 2 "register_operand" "r")))]
+  "TARGET_H8300S"
+  "#"
+  "&& reload_completed"
+  [(set (reg:CCZ CC_REG)
+	(eq:CCZ (match_dup 1) (match_dup 2)))
+   (set (match_dup 0)
+	(eq:QI (reg:CCZ CC_REG) (const_int 0)))])
+
+(define_insn "*store_z_qi"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(ne:QI (reg:CCZ CC_REG) (const_int 0)))]
+  "(TARGET_H8300S || !optimize_size) && reload_completed"
+  {
+    if (TARGET_H8300S)
+      return "stc\tccr,%X0\;shar\t#2,%X0\;and\t#0x1,%X0";
+    else
+      return "stc\tccr,%X0\;shar\t%X0\;shar\t%X0\;and\t#0x1,%X0";
+  }
+  [(set (attr "length") (symbol_ref "TARGET_H8300S ? 6 : 8"))])
+
+(define_insn "*store_z_i_qi"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(eq:QI (reg:CCZ CC_REG) (const_int 0)))]
+  "(TARGET_H8300S || !optimize_size) && reload_completed"
+  "stc\tccr,%X0\;bld\t#2,%X0\;xor.w\t%T0,%T0\;bist\t#0,%X0";
+  [(set_attr "length" "8")])
+
+;; Storing Z or an inverted Z into a HImode destination is
+;; profitable on the H8/S and older variants, but not on the
+;; H8/SX where the branchy sequence can use the two-byte
+;; mov-immediate that is specific to the H8/SX
+(define_insn_and_split "*store_z_hi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(eqne:HI (match_operand:HI 1 "register_operand" "r")
+		 (match_operand:HI 2 "register_operand" "r")))]
+  "!TARGET_H8300SX"
+  "#"
+  "&& reload_completed"
+  [(set (reg:CCZ CC_REG)
+	(eq:CCZ (match_dup 1) (match_dup 2)))
+   (set (match_dup 0)
+	(<eqne_invert>:HI (reg:CCZ CC_REG) (const_int 0)))])
+
+(define_insn "*store_z_hi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(eqne:HI (reg:CCZ CC_REG) (const_int 0)))]
+  "!TARGET_H8300SX"
+  {
+    if (<CODE> == NE)
+      return "stc\tccr,%X0\;bld\t#2,%X0\;xor.w\t%T0,%T0\;bst\t#0,%X0";
+    else
+      return "stc\tccr,%X0\;bld\t#2,%X0\;xor.w\t%T0,%T0\;bist\t#0,%X0";
+  }
+  [(set_attr "length" "8")])
+
+
+;; We can test the upper byte of a HImode register and the upper word
+;; of a SImode register
+(define_insn_and_split "*store_z"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(eqne:HI (and:HI (match_operand:HI 1 "register_operand" "r")
+			 (const_int -256))
+		 (const_int 0)))]
+  "!TARGET_H8300SX"
+  "#"
+  "&& reload_completed"
+  [(set (reg:CCZ CC_REG)
+	(compare (and:HI (match_dup 1) (const_int -256))
+		 (const_int 0)))
+   (set (match_dup 0)
+	(<eqne_invert>:HI (reg:CCZ CC_REG) (const_int 0)))])
diff --git a/gcc/expmed.c b/gcc/expmed.c
index f083d6e86d0..3143f38e057 100644
--- a/gcc/expmed.c
+++ b/gcc/expmed.c
@@ -71,14 +71,7 @@ static void store_split_bit_field (rtx, opt_scalar_int_mode,
 static rtx extract_integral_bit_field (rtx, opt_scalar_int_mode,
 				       unsigned HOST_WIDE_INT,
 				       unsigned HOST_WIDE_INT, int, rtx,
-				       machine_mode, machine_mode,
-				       scalar_int_mode, bool, bool);
-static rtx extract_and_convert_fixed_bit_field (scalar_int_mode,
-						machine_mode, machine_mode,
-						rtx, opt_scalar_int_mode,
-						unsigned HOST_WIDE_INT,
-						unsigned HOST_WIDE_INT, rtx,
-						int, bool);
+				       machine_mode, machine_mode, bool, bool);
 static rtx extract_fixed_bit_field (machine_mode, rtx, opt_scalar_int_mode,
 				    unsigned HOST_WIDE_INT,
 				    unsigned HOST_WIDE_INT, rtx, int, bool);
@@ -1639,7 +1632,6 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,
 {
   rtx op0 = str_rtx;
   machine_mode mode1;
-  scalar_int_mode int_tmode;
 
   if (tmode == VOIDmode)
     tmode = mode;
@@ -1861,46 +1853,10 @@ extract_bit_field_1 (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,
   /* It's possible we'll need to handle other cases here for
      polynomial bitnum and bitsize.  */
 
-  /* Make sure we are playing with integral modes.  Pun with subregs
-     if we aren't. When tmode is HFmode, op0 is SImode, there will be ICE
-     in extract_integral_bit_field.  */
-  opt_scalar_int_mode target_imode = int_mode_for_mode (tmode);
-  if (!target_imode.exists (&int_tmode) || int_tmode != tmode)
-    {
-      if (target_imode.exists (&int_tmode))
-	{
-	  rtx ret = extract_integral_bit_field (op0, op0_mode,
-						bitsize.to_constant (),
-						bitnum.to_constant (),
-						unsignedp, NULL, int_tmode,
-						int_tmode, int_tmode,
-						reverse, fallback_p);
-	  gcc_assert (ret);
-
-	  if (!REG_P (ret))
-	    ret = force_reg (int_tmode, ret);
-	  return gen_lowpart_SUBREG (tmode, ret);
-	}
-      else
-	{
-	  if (!fallback_p)
-	    return NULL;
-
-	  int_tmode = int_mode_for_mode (mode).require ();
-	  return extract_and_convert_fixed_bit_field (int_tmode, tmode, mode,
-						      op0, op0_mode,
-						      bitsize.to_constant (),
-						      bitnum.to_constant (),
-						      target, unsignedp,
-						      reverse);
-	}
-    }
-
   /* From here on we need to be looking at a fixed-size insertion.  */
   return extract_integral_bit_field (op0, op0_mode, bitsize.to_constant (),
 				     bitnum.to_constant (), unsignedp,
-				     target, mode, tmode,
-				     int_tmode, reverse, fallback_p);
+				     target, mode, tmode, reverse, fallback_p);
 }
 
 /* Subroutine of extract_bit_field_1, with the same arguments, except
@@ -1913,7 +1869,6 @@ extract_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,
 			    unsigned HOST_WIDE_INT bitsize,
 			    unsigned HOST_WIDE_INT bitnum, int unsignedp,
 			    rtx target, machine_mode mode, machine_mode tmode,
-			    scalar_int_mode int_tmode,
 			    bool reverse, bool fallback_p)
 {
   /* Handle fields bigger than a word.  */
@@ -2080,10 +2035,29 @@ extract_integral_bit_field (rtx op0, opt_scalar_int_mode op0_mode,
   if (!fallback_p)
     return NULL;
 
-  return extract_and_convert_fixed_bit_field (int_tmode, tmode, mode,
-					      op0, op0_mode, bitsize,
-					      bitnum, target, unsignedp,
-					      reverse);
+  /* Find a correspondingly-sized integer field, so we can apply
+     shifts and masks to it.  */
+  scalar_int_mode int_mode;
+  if (!int_mode_for_mode (tmode).exists (&int_mode))
+    /* If this fails, we should probably push op0 out to memory and then
+       do a load.  */
+    int_mode = int_mode_for_mode (mode).require ();
+
+  target = extract_fixed_bit_field (int_mode, op0, op0_mode, bitsize,
+				    bitnum, target, unsignedp, reverse);
+
+  /* Complex values must be reversed piecewise, so we need to undo the global
+     reversal, convert to the complex mode and reverse again.  */
+  if (reverse && COMPLEX_MODE_P (tmode))
+    {
+      target = flip_storage_order (int_mode, target);
+      target = convert_extracted_bit_field (target, mode, tmode, unsignedp);
+      target = flip_storage_order (tmode, target);
+    }
+  else
+    target = convert_extracted_bit_field (target, mode, tmode, unsignedp);
+
+  return target;
 }
 
 /* Generate code to extract a byte-field from STR_RTX
@@ -2155,33 +2129,6 @@ extract_bit_field (rtx str_rtx, poly_uint64 bitsize, poly_uint64 bitnum,
   return extract_bit_field_1 (str_rtx, bitsize, bitnum, unsignedp,
 			      target, mode, tmode, reverse, true, alt_rtl);
 }
-
-/* Combination of extract_fixed_bit_field and convert_extracted_bit_field.  */
-static rtx
-extract_and_convert_fixed_bit_field (scalar_int_mode int_tmode,
-				     machine_mode tmode, machine_mode mode,
-				     rtx op0, opt_scalar_int_mode op0_mode,
-				     unsigned HOST_WIDE_INT bitsize,
-				     unsigned HOST_WIDE_INT bitnum,
-				     rtx target, int unsignedp, bool reverse)
-{
-  target = extract_fixed_bit_field (int_tmode, op0, op0_mode, bitsize,
-				    bitnum, target, unsignedp, reverse);
-
-  /* Complex values must be reversed piecewise, so we need to undo the global
-     reversal, convert to the complex mode and reverse again.  */
-  if (reverse && COMPLEX_MODE_P (tmode))
-    {
-      target = flip_storage_order (int_tmode, target);
-      target = convert_extracted_bit_field (target, mode, tmode, unsignedp);
-      target = flip_storage_order (tmode, target);
-    }
-  else
-    target = convert_extracted_bit_field (target, mode, tmode, unsignedp);
-
-  return target;
-}
-
 
 /* Use shifts and boolean operations to extract a field of BITSIZE bits
    from bit BITNUM of OP0.  If OP0_MODE is defined, it is the mode of OP0,
