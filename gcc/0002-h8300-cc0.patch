diff --git a/gcc/config/h8300/addsub.md b/gcc/config/h8300/addsub.md
new file mode 100644
index 00000000000..ee64fb67df6
--- /dev/null
+++ b/gcc/config/h8300/addsub.md
@@ -0,0 +1,325 @@
+;; ----------------------------------------------------------------------
+;; ADD INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_expand "add<mode>3"
+  [(set (match_operand:QHSI 0 "register_operand" "")
+	(plus:QHSI (match_operand:QHSI 1 "register_operand" "")
+		   (match_operand:QHSI 2 "h8300_src_operand" "")))]
+  ""
+  "")
+
+(define_insn_and_split "*addqi3"
+  [(set (match_operand:QI 0 "h8300_dst_operand" "=rQ")
+	(plus:QI (match_operand:QI 1 "h8300_dst_operand" "%0")
+		 (match_operand:QI 2 "h8300_src_operand" "rQi")))]
+  "h8300_operands_match_p (operands)"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (plus:QI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*addqi3_clobber_flags"
+  [(set (match_operand:QI 0 "h8300_dst_operand" "=rQ")
+	(plus:QI (match_operand:QI 1 "h8300_dst_operand" "%0")
+		 (match_operand:QI 2 "h8300_src_operand" "rQi")))
+   (clobber (reg:CC CC_REG))]
+  "reload_completed && h8300_operands_match_p (operands)"
+  "add.b	%X2,%X0"
+  [(set_attr "length_table" "add")])
+
+(define_insn "*addqi3_set_flags"
+  [(set (reg:CCZN CC_REG) (compare:CCZN
+			    (plus:QI
+			      (match_operand:QI 1 "register_operand" "%0,0")
+			      (match_operand:QI 2 "h8300_src_operand" "n,r"))
+			    (const_int 0)))
+   (set (match_operand:QI 0 "register_operand" "=r,r")
+	(plus:QI (match_dup 1) (match_dup 2)))]
+  "reload_completed && h8300_operands_match_p (operands)"
+  "add.b	%X2,%X0"
+  [(set_attr "length" "2,2")])
+
+(define_insn_and_split "*addhi"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r,r")
+	(plus:HI (match_operand:HI 1 "register_operand" "%0,0,0,0,0")
+		 (match_operand:HI 2 "h8300_src_operand" "L,N,J,n,r")))]
+  "!TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (plus:HI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*addhi3_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r,r")
+	(plus:HI (match_operand:HI 1 "register_operand" "%0,0,0,0,0")
+		 (match_operand:HI 2 "h8300_src_operand" "L,N,J,n,r")))
+   (clobber (reg:CC CC_REG))]
+  "reload_completed && !TARGET_H8300SX"
+  "@
+   adds	%2,%S0
+   subs	%G2,%S0
+   add.b	%t2,%t0
+   add.w	%T2,%T0
+   add.w	%T2,%T0"
+  [(set_attr "length" "2,2,2,4,2")])
+
+(define_insn "*addhi3_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN (plus:HI
+			(match_operand:HI 1 "register_operand" "%0,0,0,0")
+			(match_operand:HI 2 "h8300_src_operand" "M,O,n,r"))
+		      (const_int 0)))
+   (set (match_operand:HI 0 "register_operand" "=r,r,r,r")
+	(plus:HI (match_dup 1) (match_dup 2)))]
+  "reload_completed && !TARGET_H8300SX"
+  "@
+   inc.w	%T2,%T0
+   dec.w	%G2,%T0
+   add.w	%T2,%T0
+   add.w	%T2,%T0"
+  [(set_attr "length" "2,2,4,2")])
+
+(define_insn_and_split "*addhi3_h8sx"
+  [(set (match_operand:HI 0 "h8300_dst_operand" "=rU,rU,r,rQ")
+	(plus:HI (match_operand:HI 1 "h8300_dst_operand" "%0,0,0,0")
+		 (match_operand:HI 2 "h8300_src_operand" "P3>X,P3<X,J,rQi")))]
+  "TARGET_H8300SX && h8300_operands_match_p (operands)"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (plus:HI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*addhi3_h8sx_clobber_flags"
+  [(set (match_operand:HI 0 "h8300_dst_operand" "=rU,rU,r,rQ")
+	(plus:HI (match_operand:HI 1 "h8300_dst_operand" "%0,0,0,0")
+		 (match_operand:HI 2 "h8300_src_operand" "P3>X,P3<X,J,rQi")))
+   (clobber (reg:CC CC_REG))]
+  "reload_completed && TARGET_H8300SX && h8300_operands_match_p (operands)"
+  "@
+   add.w	%T2:3,%T0
+   sub.w	%G2:3,%T0
+   add.b	%t2,%t0
+   add.w	%T2,%T0"
+  [(set_attr "length_table" "short_immediate,short_immediate,*,add")
+   (set_attr "length" "*,*,2,*")])
+
+(define_insn "*addhi3_h8sx_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (plus:HI (match_operand:HI 1 "h8300_dst_operand" "%0,0,0,0")
+		   (match_operand:HI 2 "h8300_src_operand" "P3>X,P3<X,J,rQi"))
+	  (const_int 0)))
+   (set (match_operand:HI 0 "h8300_dst_operand" "=rU,rU,r,rQ")
+	(plus:HI (match_dup 1) (match_dup 2)))]
+  "reload_completed && TARGET_H8300SX && h8300_operands_match_p (operands)"
+  "@
+   add.w	%T2:3,%T0
+   sub.w	%G2:3,%T0
+   add.b	%t2,%t0
+   add.w	%T2,%T0"
+  [(set_attr "length_table" "short_immediate,short_immediate,*,add")
+   (set_attr "length" "*,*,2,*")])
+
+(define_split
+  [(set (match_operand:HSI 0 "register_operand" "")
+	(plus:HSI (match_dup 0)
+		 (match_operand:HSI 1 "two_insn_adds_subs_operand" "")))]
+  "!reload_completed"
+  [(const_int 0)]
+  {
+    split_adds_subs (<MODE>mode, operands);
+    DONE;
+  })
+
+
+(define_insn_and_split "*addsi"
+  [(set (match_operand:SI 0 "h8300_dst_operand" "=rQ,rQ")
+	(plus:SI (match_operand:SI 1 "h8300_dst_operand" "%0,0")
+		 (match_operand:SI 2 "h8300_src_operand" "i,rQ")))]
+  "h8300_operands_match_p (operands)"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*addsi_clobber_flags"
+  [(set (match_operand:SI 0 "h8300_dst_operand" "=rQ,rQ")
+	(plus:SI (match_operand:SI 1 "h8300_dst_operand" "%0,0")
+		 (match_operand:SI 2 "h8300_src_operand" "i,rQ")))
+   (clobber (reg:CC CC_REG))]
+  "reload_completed && h8300_operands_match_p (operands)"
+{
+  return output_plussi (operands, false);
+}
+  [(set (attr "length")
+	(symbol_ref "compute_plussi_length (operands, false)"))])
+
+(define_insn "*addsi3_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN (plus:SI
+			(match_operand:SI 1 "h8300_dst_operand" "%0,0")
+			(match_operand:SI 2 "h8300_src_operand" "i,rQ"))
+		      (const_int 0)))
+   (set (match_operand:SI 0 "h8300_dst_operand" "=rQ,rQ")
+	(plus:SI (match_dup 1) (match_dup 2)))]
+  "reload_completed && h8300_operands_match_p (operands)"
+{
+  return output_plussi (operands, true);
+}
+  [(set (attr "length")
+	(symbol_ref "compute_plussi_length (operands, true)"))])
+
+;; ----------------------------------------------------------------------
+;; SUBTRACT INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_expand "sub<mode>3"
+  [(set (match_operand:QHSI 0 "register_operand" "")
+	(minus:QHSI (match_operand:QHSI 1 "register_operand" "")
+		    (match_operand:QHSI 2 "h8300_src_operand" "")))]
+  "")
+
+(define_insn_and_split "*subqi3"
+  [(set (match_operand:QI 0 "h8300_dst_operand" "=rQ")
+	(minus:QI (match_operand:QI 1 "h8300_dst_operand" "0")
+		  (match_operand:QI 2 "h8300_dst_operand" "rQ")))]
+  "h8300_operands_match_p (operands)"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (minus:QI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*subqi3_clobber_flags"
+  [(set (match_operand:QI 0 "h8300_dst_operand" "=rQ")
+	(minus:QI (match_operand:QI 1 "h8300_dst_operand" "0")
+		  (match_operand:QI 2 "h8300_dst_operand" "rQ")))
+   (clobber (reg:CC CC_REG))]
+  "reload_completed && h8300_operands_match_p (operands)"
+  "sub.b	%X2,%X0"
+  [(set_attr "length_table" "add")])
+
+(define_insn "*subqi3_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN (minus:QI (match_operand:QI 1 "h8300_dst_operand" "0")
+			        (match_operand:QI 2 "h8300_dst_operand" "rQ"))
+		      (const_int 0)))
+   (set (match_operand:QI 0 "h8300_dst_operand" "=rQ")
+	(minus:QI (match_dup 1) (match_dup 2)))]
+  "reload_completed && h8300_operands_match_p (operands)"
+  "sub.b	%X2,%X0"
+  [(set_attr "length_table" "add")])
+
+(define_insn_and_split "*sub<mode>3"
+  [(set (match_operand:HSI 0 "h8300_dst_operand" "=rQ,rQ")
+	(minus:HSI (match_operand:HSI 1 "h8300_dst_operand" "0,0")
+		   (match_operand:HSI 2 "h8300_src_operand" "rQ,i")))]
+  "h8300_operands_match_p (operands)"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (minus:HSI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*sub<mode>3_clobber_flags"
+  [(set (match_operand:HSI 0 "h8300_dst_operand" "=rQ,rQ")
+	(minus:HSI (match_operand:HSI 1 "h8300_dst_operand" "0,0")
+		   (match_operand:HSI 2 "h8300_src_operand" "rQ,i")))
+   (clobber (reg:CC CC_REG))]
+  "reload_completed && h8300_operands_match_p (operands)"
+  { 
+    if (<MODE>mode == HImode)
+      return "sub.w	%T2,%T0";
+    else if (<MODE>mode == SImode)
+      return "sub.l	%S2,%S0";
+    gcc_unreachable ();
+  }
+  [(set_attr "length_table" "add")])
+
+(define_insn "*sub<mode>3_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (minus:HSI (match_operand:HSI 1 "h8300_dst_operand" "0,0")
+		     (match_operand:HSI 2 "h8300_dst_operand" "rQ,i"))
+	  (const_int 0)))
+   (set (match_operand:HSI 0 "h8300_dst_operand" "=rQ,rQ")
+	(minus:HSI (match_dup 1) (match_dup 2)))]
+  "reload_completed && h8300_operands_match_p (operands)"
+  { 
+    if (<MODE>mode == HImode)
+      return "sub.w	%T2,%T0";
+    else if (<MODE>mode == SImode)
+      return "sub.l	%S2,%S0";
+    gcc_unreachable ();
+  }
+  [(set_attr "length_table" "add")])
+
+;; ----------------------------------------------------------------------
+;; NEGATION INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_expand "neg<mode>2"
+  [(set (match_operand:QHSIF 0 "register_operand" "")
+	(neg:QHSIF (match_operand:QHSIF 1 "register_operand" "")))]
+  ""
+  "")
+
+(define_insn_and_split "*neg<mode>2"
+  [(set (match_operand:QHSI 0 "h8300_dst_operand" "=rQ")
+	(neg:QHSI (match_operand:QHSI 1 "h8300_dst_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (neg:QHSI (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*neg<mode>2_clobber_flags"
+  [(set (match_operand:QHSI 0 "h8300_dst_operand" "=rQ")
+	(neg:QHSI (match_operand:QHSI 1 "h8300_dst_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  "reload_completed"
+  {
+    if (<MODE>mode == E_QImode)
+      return "neg	%X0";
+    if (<MODE>mode == E_HImode)
+      return "neg.w	%T0";
+    if (<MODE>mode == E_SImode)
+      return "neg.l	%S0";
+    gcc_unreachable ();
+  }
+  [(set_attr "length_table" "unary")])
+
+(define_insn "*neg<mode>2_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN (neg:QHSI (match_operand:QHSI 1 "h8300_dst_operand" "0"))
+		      (const_int 0)))
+   (set (match_operand:QHSI 0 "h8300_dst_operand" "=rQ")
+	(neg:QHSI (match_dup 1)))]
+  "reload_completed"
+  {
+    if (<MODE>mode == E_QImode)
+      return "neg	%X0";
+    if (<MODE>mode == E_HImode)
+      return "neg.w	%T0";
+    if (<MODE>mode == E_SImode)
+      return "neg.l	%S0";
+    gcc_unreachable ();
+  }
+  [(set_attr "length_table" "unary")])
+
+(define_insn_and_split "*negsf2"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(neg:SF (match_operand:SF 1 "register_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (neg:SF (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+  
+(define_insn "*negsf2_clobber_flags"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+       (neg:SF (match_operand:SF 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  "reload_completed"
+  "xor.w\\t#32768,%e0"
+  [(set_attr "length" "4")])
+
diff --git a/gcc/config/h8300/bitfield.md b/gcc/config/h8300/bitfield.md
new file mode 100644
index 00000000000..8fa6fde433a
--- /dev/null
+++ b/gcc/config/h8300/bitfield.md
@@ -0,0 +1,544 @@
+;; -----------------------------------------------------------------
+;; BIT FIELDS
+;; -----------------------------------------------------------------
+;; The H8/300 has given 1/8th of its opcode space to bitfield
+;; instructions so let's use them as well as we can.
+
+;; You'll never believe all these patterns perform one basic action --
+;; load a bit from the source, optionally invert the bit, then store it
+;; in the destination (which is known to be zero).
+;;
+;; Combine obviously need some work to better identify this situation and
+;; canonicalize the form better.
+
+;;
+;; Inverted loads with a 16bit destination.
+;;
+
+(define_insn_and_split ""
+  [(set (match_operand:HI 0 "register_operand" "=&r")
+	(zero_extract:HI (xor:HI (match_operand:HI 1 "register_operand" "r")
+				 (match_operand:HI 3 "const_int_operand" "n"))
+			 (const_int 1)
+			 (match_operand:HI 2 "const_int_operand" "n")))]
+  "(TARGET_H8300SX)
+    && (1 << INTVAL (operands[2])) == INTVAL (operands[3])"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (zero_extract:HI (xor:HI (match_dup 1) (match_dup 3))
+				    (const_int 1)
+				    (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn ""
+  [(set (match_operand:HI 0 "register_operand" "=&r")
+	(zero_extract:HI (xor:HI (match_operand:HI 1 "register_operand" "r")
+				 (match_operand:HI 3 "const_int_operand" "n"))
+			 (const_int 1)
+			 (match_operand:HI 2 "const_int_operand" "n")))
+   (clobber (reg:CC CC_REG))]
+  "(TARGET_H8300SX)
+    && (1 << INTVAL (operands[2])) == INTVAL (operands[3])"
+  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
+  [(set_attr "length" "8")])
+
+;;
+;; Normal loads with a 32bit destination.
+;;
+
+(define_insn_and_split "*extzv_1_r"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extract:SI (match_operand:SI 1 "register_operand" "?0,r")
+			 (const_int 1)
+			 (match_operand 2 "const_int_operand" "n,n")))]
+  "INTVAL (operands[2]) < 16"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (zero_extract:SI (match_dup 1) (const_int 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*extzv_1_r_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extract:SI (match_operand:SI 1 "register_operand" "?0,r")
+			 (const_int 1)
+			 (match_operand 2 "const_int_operand" "n,n")))
+   (clobber (reg:CC CC_REG))]
+  "INTVAL (operands[2]) < 16"
+{
+  return output_simode_bld (0, operands);
+}
+  [(set_attr "cc" "set_znv,set_znv")
+   (set_attr "length" "8,6")])
+
+;;
+;; Inverted loads with a 32bit destination.
+;;
+
+(define_insn_and_split "*extzv_1_r_inv"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extract:SI (xor:SI (match_operand:SI 1 "register_operand" "?0,r")
+				 (match_operand 3 "const_int_operand" "n,n"))
+			 (const_int 1)
+			 (match_operand 2 "const_int_operand" "n,n")))]
+  "INTVAL (operands[2]) < 16
+    && (1 << INTVAL (operands[2])) == INTVAL (operands[3])"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (zero_extract:SI (xor:SI (match_dup 1) (match_dup 3))
+				    (const_int 1)
+				    (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*extzv_1_r_inv_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extract:SI (xor:SI (match_operand:SI 1 "register_operand" "?0,r")
+				 (match_operand 3 "const_int_operand" "n,n"))
+			 (const_int 1)
+			 (match_operand 2 "const_int_operand" "n,n")))
+   (clobber (reg:CC CC_REG))]
+  "INTVAL (operands[2]) < 16
+    && (1 << INTVAL (operands[2])) == INTVAL (operands[3])"
+{
+  return output_simode_bld (1, operands);
+}
+  [(set_attr "cc" "set_znv,set_znv")
+   (set_attr "length" "8,6")])
+
+(define_expand "insv"
+  [(set (zero_extract:HI (match_operand:HI 0 "general_operand" "")
+			 (match_operand:HI 1 "general_operand" "")
+			 (match_operand:HI 2 "general_operand" ""))
+	(match_operand:HI 3 "general_operand" ""))]
+  "TARGET_H8300SX"
+  {
+    if (GET_CODE (operands[1]) == CONST_INT
+	&& GET_CODE (operands[2]) == CONST_INT
+	&& INTVAL (operands[1]) <= 8
+	&& INTVAL (operands[2]) >= 0
+	&& INTVAL (operands[1]) + INTVAL (operands[2]) <= 8
+	&& memory_operand (operands[0], GET_MODE (operands[0])))
+      {
+	/* If the source operand is zero, it's better to use AND rather
+	   than BFST.  Likewise OR if the operand is all ones.  */
+	if (GET_CODE (operands[3]) == CONST_INT)
+	  {
+	    HOST_WIDE_INT mask = (1 << INTVAL (operands[1])) - 1;
+	    if ((INTVAL (operands[3]) & mask) == 0)
+	      FAIL;
+	    if ((INTVAL (operands[3]) & mask) == mask)
+	      FAIL;
+	  }
+	if (! bit_memory_operand (operands[0], GET_MODE (operands[0])))
+	  {
+	    if (!can_create_pseudo_p ())
+	      FAIL;
+	    operands[0] =  replace_equiv_address (operands[0], force_reg (Pmode,
+						  XEXP (operands[0], 0)));
+	  }
+	operands[3] = gen_lowpart (QImode, operands[3]);
+	if (! operands[3])
+	  FAIL;
+	if (! register_operand (operands[3], QImode))
+	  {
+	    if (!can_create_pseudo_p ())
+	      FAIL;
+	    operands[3] = force_reg (QImode, operands[3]);
+	  }
+	emit_insn (gen_bfst (adjust_address (operands[0], QImode, 0),
+					     operands[3], operands[1], operands[2]));
+	DONE;
+      }
+    FAIL;
+  })
+
+(define_insn_and_split ""
+  [(set (zero_extract:HI (match_operand:HI 0 "register_operand" "+r")
+			 (const_int 1)
+			 (match_operand:HI 1 "immediate_operand" "n"))
+	(match_operand:HI 2 "register_operand" "r"))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (zero_extract:HI (match_dup 0) (const_int 1) (match_dup 1))
+		   (match_dup 2))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn ""
+  [(set (zero_extract:HI (match_operand:HI 0 "register_operand" "+r")
+			 (const_int 1)
+			 (match_operand:HI 1 "immediate_operand" "n"))
+	(match_operand:HI 2 "register_operand" "r"))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "bld	#0,%R2\;bst	%Z1,%Y0 ; i1"
+  [(set_attr "length" "4")])
+
+(define_expand "extzv"
+  [(set (match_operand:HI 0 "register_operand" "")
+	(zero_extract:HI (match_operand:HI 1 "bit_operand" "")
+			 (match_operand:HI 2 "general_operand" "")
+			 (match_operand:HI 3 "general_operand" "")))]
+  "TARGET_H8300SX"
+  {
+    if (GET_CODE (operands[2]) == CONST_INT
+	&& GET_CODE (operands[3]) == CONST_INT
+	&& INTVAL (operands[2]) <= 8
+	&& INTVAL (operands[3]) >= 0
+	&& INTVAL (operands[2]) + INTVAL (operands[3]) <= 8
+	&& memory_operand (operands[1], QImode))
+      {
+	rtx temp;
+
+	/* Optimize the case where we're extracting into a paradoxical
+	   subreg.  It's only necessary to extend to the inner reg.  */
+	if (GET_CODE (operands[0]) == SUBREG
+	    && subreg_lowpart_p (operands[0])
+	    && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (operands[0])))
+		< GET_MODE_SIZE (GET_MODE (operands[0])))
+	    && (GET_MODE_CLASS (GET_MODE (SUBREG_REG (operands[0])))
+		== MODE_INT))
+	   operands[0] = SUBREG_REG (operands[0]);
+
+	if (!can_create_pseudo_p ())
+	  temp = gen_lowpart (QImode, operands[0]);
+	else
+	  temp = gen_reg_rtx (QImode);
+	if (! temp)
+	  FAIL;
+        if (! bit_memory_operand (operands[1], QImode))
+	  {
+	    if (!can_create_pseudo_p ())
+	      FAIL;
+	    operands[1] = replace_equiv_address (operands[1],
+						 force_reg (Pmode, XEXP (operands[1], 0)));
+	  }
+	emit_insn (gen_bfld (temp, operands[1], operands[2], operands[3]));
+	convert_move (operands[0], temp, 1);
+	DONE;
+      }
+    FAIL;
+  })
+
+;; BAND, BOR, and BXOR patterns
+
+(define_insn_and_split ""
+  [(set (match_operand:HI 0 "bit_operand" "=Ur")
+	(match_operator:HI 4 "bit_operator"
+	 [(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
+			   (const_int 1)
+			   (match_operand:HI 2 "immediate_operand" "n"))
+	  (match_operand:HI 3 "bit_operand" "0")]))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 4 [(zero_extract:HI (match_dup 1)
+						     (const_int 1)
+						     (match_dup 2))
+				    (match_dup 3)]))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn ""
+  [(set (match_operand:HI 0 "bit_operand" "=Ur")
+	(match_operator:HI 4 "bit_operator"
+	 [(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
+			   (const_int 1)
+			   (match_operand:HI 2 "immediate_operand" "n"))
+	  (match_operand:HI 3 "bit_operand" "0")]))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "bld	%Z2,%Y1\;b%c4	#0,%R0\;bst	#0,%R0; bl1"
+  [(set_attr "length" "6")])
+
+(define_insn_and_split ""
+  [(set (match_operand:HI 0 "bit_operand" "=Ur")
+	(match_operator:HI 5 "bit_operator"
+	 [(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
+			   (const_int 1)
+			   (match_operand:HI 2 "immediate_operand" "n"))
+	  (zero_extract:HI (match_operand:HI 3 "register_operand" "r")
+			   (const_int 1)
+			   (match_operand:HI 4 "immediate_operand" "n"))]))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 5 [(zero_extract:HI (match_dup 1)
+						     (const_int 1)
+						     (match_dup 2))
+				    (zero_extract:HI (match_dup 3)
+						     (const_int 1)
+						     (match_dup 4))]))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn ""
+  [(set (match_operand:HI 0 "bit_operand" "=Ur")
+	(match_operator:HI 5 "bit_operator"
+	 [(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
+			   (const_int 1)
+			   (match_operand:HI 2 "immediate_operand" "n"))
+	  (zero_extract:HI (match_operand:HI 3 "register_operand" "r")
+			   (const_int 1)
+			   (match_operand:HI 4 "immediate_operand" "n"))]))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "bld	%Z2,%Y1\;b%c5	%Z4,%Y3\;bst	#0,%R0; bl3"
+  [(set_attr "length" "6")])
+
+(define_insn_and_split "bfld"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(zero_extract:QI (match_operand:QI 1 "bit_memory_operand" "WU")
+			 (match_operand:QI 2 "immediate_operand" "n")
+			 (match_operand:QI 3 "immediate_operand" "n")))]
+  "TARGET_H8300SX && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (zero_extract:QI (match_dup 1) (match_dup 2) (match_dup 3)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "bfld_clobber_flags"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(zero_extract:QI (match_operand:QI 1 "bit_memory_operand" "WU")
+			 (match_operand:QI 2 "immediate_operand" "n")
+			 (match_operand:QI 3 "immediate_operand" "n")))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8"
+{
+  operands[2] = GEN_INT ((1 << (INTVAL (operands[2]) + INTVAL (operands[3])))
+			 - (1 << INTVAL (operands[3])));
+  return "bfld	%2,%1,%R0";
+}
+  [(set_attr "cc" "none_0hit")
+   (set_attr "length_table" "bitfield")])
+
+(define_insn_and_split "bfst"
+  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU")
+			 (match_operand:QI 2 "immediate_operand" "n")
+			 (match_operand:QI 3 "immediate_operand" "n"))
+	(match_operand:QI 1 "register_operand" "r"))]
+  "TARGET_H8300SX && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8"
+  "#"
+  "reload_completed"
+  [(parallel [(set (zero_extract:QI (match_dup 0) (match_dup 2) (match_dup 3))
+		   (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "bfst_clobber_flags"
+  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU")
+			 (match_operand:QI 2 "immediate_operand" "n")
+			 (match_operand:QI 3 "immediate_operand" "n"))
+	(match_operand:QI 1 "register_operand" "r"))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8"
+{
+  operands[2] = GEN_INT ((1 << (INTVAL (operands[2]) + INTVAL (operands[3])))
+			 - (1 << INTVAL (operands[3])));
+  return "bfst	%R1,%2,%0";
+}
+  [(set_attr "cc" "none_0hit")
+   (set_attr "length_table" "bitfield")])
+
+;;(define_expand "cstore<mode>4"
+;;  [(use (match_operator 1 "eqne_operator"
+;;         [(match_operand:QHSI 2 "h8300_dst_operand" "")
+;;          (match_operand:QHSI 3 "h8300_src_operand" "")]))
+;;   (clobber (match_operand:QHSI 0 "register_operand"))]
+;;  "TARGET_H8300SX"
+;;  {
+;;    h8300_expand_store (operands);
+;;    DONE;
+;;  })
+
+;;(define_insn "*bstzhireg"
+;;  [(set (match_operand:HI 0 "register_operand" "=r")
+;;	(match_operator:HI 1 "eqne_operator" [(cc0) (const_int 0)]))]
+;;  "TARGET_H8300SX"
+;;  "mulu.w	#0,%T0\;b%k1	.Lh8BR%=\;inc.w	#1,%T0\\n.Lh8BR%=:"
+;;  [(set_attr "cc" "clobber")])
+
+;;(define_insn_and_split "*cmpstz"
+;;  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU,WU")
+;;			 (const_int 1)
+;;			 (match_operand:QI 1 "immediate_operand" "n,n"))
+;;	(match_operator:QI 2 "eqne_operator"
+;;	 [(match_operand 3 "h8300_dst_operand" "r,rQ")
+;;	  (match_operand 4 "h8300_src_operand" "I,rQi")]))]
+;;  "TARGET_H8300SX
+;;   && (GET_MODE (operands[3]) == GET_MODE (operands[4])
+;;       || GET_CODE (operands[4]) == CONST_INT)
+;;   && GET_MODE_CLASS (GET_MODE (operands[3])) == MODE_INT
+;;   && GET_MODE_SIZE (GET_MODE (operands[3])) <= 4"
+;;  "#"
+;;  "reload_completed"
+;;  [(set (cc0) (match_dup 5))
+;;   (set (zero_extract:QI (match_dup 0) (const_int 1) (match_dup 1))
+;;	(match_op_dup:QI 2 [(cc0) (const_int 0)]))]
+;;  {
+;;    operands[5] = gen_rtx_COMPARE (VOIDmode, operands[3], operands[4]);
+;;  }
+;;  [(set_attr "cc" "set_znv,compare")])
+
+;;(define_insn "*bstz"
+;;  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU")
+;;			 (const_int 1)
+;;			 (match_operand:QI 1 "immediate_operand" "n"))
+;;	(eq:QI (cc0) (const_int 0)))]
+;;  "TARGET_H8300SX && reload_completed"
+;;  "bstz	%1,%0"
+;;  [(set_attr "cc" "none_0hit")
+;;   (set_attr "length_table" "unary")])
+
+;;(define_insn "*bistz"
+;;  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU")
+;;			 (const_int 1)
+;;			 (match_operand:QI 1 "immediate_operand" "n"))
+;;	(ne:QI (cc0) (const_int 0)))]
+;;  "TARGET_H8300SX && reload_completed"
+;;  "bistz	%1,%0"
+;;  [(set_attr "cc" "none_0hit")
+;;   (set_attr "length_table" "unary")])
+
+;;(define_insn_and_split "*cmpcondbset"
+;;  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
+;;	(if_then_else:QI (match_operator 1 "eqne_operator"
+;;			  [(match_operand 2 "h8300_dst_operand" "r,rQ")
+;;			   (match_operand 3 "h8300_src_operand" "I,rQi")])
+;;			 (ior:QI (match_operand:QI 4 "bit_memory_operand" "0,0")
+;;				 (match_operand:QI 5 "single_one_operand" "n,n"))
+;;			 (match_dup 4)))]
+;;  "TARGET_H8300SX"
+;;  "#"
+;;  "reload_completed"
+;;  [(set (cc0) (match_dup 6))
+;;   (set (match_dup 0)
+;;	(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])
+;;			 (ior:QI (match_dup 4) (match_dup 5))
+;;			 (match_dup 4)))]
+;;  {
+;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
+;;  }
+;; [(set_attr "cc" "set_znv,compare")])
+
+;;(define_insn "*condbset"
+;;  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
+;;	(if_then_else:QI (match_operator:QI 2 "eqne_operator"
+;;			  [(cc0) (const_int 0)])
+;;			 (ior:QI (match_operand:QI 3 "bit_memory_operand" "0")
+;;				 (match_operand:QI 1 "single_one_operand" "n"))
+;;			 (match_dup 3)))]
+;;  "TARGET_H8300SX && reload_completed"
+;;  "bset/%j2\t%V1,%0"
+;;  [(set_attr "cc" "none_0hit")
+;;   (set_attr "length_table" "logicb")])
+
+;;(define_insn_and_split "*cmpcondbclr"
+;;  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
+;;	(if_then_else:QI (match_operator 1 "eqne_operator"
+;;			  [(match_operand 2 "h8300_dst_operand" "r,rQ")
+;;			   (match_operand 3 "h8300_src_operand" "I,rQi")])
+;;			 (and:QI (match_operand:QI 4 "bit_memory_operand" "0,0")
+;;				 (match_operand:QI 5 "single_zero_operand" "n,n"))
+;;			 (match_dup 4)))]
+;;  "TARGET_H8300SX"
+;;  "#"
+;;  "reload_completed"
+;;  [(set (cc0) (match_dup 6))
+;;   (set (match_dup 0)
+;;	(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])
+;;			 (and:QI (match_dup 4) (match_dup 5))
+;;			 (match_dup 4)))]
+;;  {
+;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
+;;  }
+;;  [(set_attr "cc" "set_znv,compare")])
+
+;;(define_insn "*condbclr"
+;;  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
+;;	(if_then_else:QI (match_operator:QI 2 "eqne_operator"
+;;			  [(cc0) (const_int 0)])
+;;			 (and:QI (match_operand:QI 3 "bit_memory_operand" "0")
+;;				 (match_operand:QI 1 "single_zero_operand" "n"))
+;;			 (match_dup 3)))]
+;;  "TARGET_H8300SX && reload_completed"
+;;  "bclr/%j2\t%W1,%0"
+;;  [(set_attr "cc" "none_0hit")
+;;   (set_attr "length_table" "logicb")])
+
+;;(define_insn_and_split "*cmpcondbsetreg"
+;;  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
+;;	(if_then_else:QI (match_operator 1 "eqne_operator"
+;;			  [(match_operand 2 "h8300_dst_operand" "r,rQ")
+;;			   (match_operand 3 "h8300_src_operand" "I,rQi")])
+;;			 (ior:QI (match_operand:QI 4 "bit_memory_operand" "0,0")
+;;				 (ashift:QI (const_int 1)
+;;					    (match_operand:QI 5 "register_operand" "r,r")))
+;;			 (match_dup 4)))]
+;;  "TARGET_H8300SX"
+;;  "#"
+;;  "reload_completed"
+;;  [(set (cc0) (match_dup 6))
+;;   (set (match_dup 0)
+;;	(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])
+;;			 (ior:QI (match_dup 4)
+;;				 (ashift:QI (const_int 1)
+;;					    (match_operand:QI 5 "register_operand" "r,r")))
+;;			 (match_dup 4)))]
+;;  {
+;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
+;;  }
+;;  [(set_attr "cc" "set_znv,compare")])
+
+;;(define_insn "*condbsetreg"
+;;  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
+;;	(if_then_else:QI (match_operator:QI 2 "eqne_operator"
+;;			  [(cc0) (const_int 0)])
+;;			 (ior:QI (match_operand:QI 3 "bit_memory_operand" "0")
+;;				 (ashift:QI (const_int 1)
+;;					    (match_operand:QI 1 "register_operand" "r")))
+;;			 (match_dup 3)))]
+;;  "TARGET_H8300SX && reload_completed"
+;;  "bset/%j2\t%R1,%0"
+;;  [(set_attr "cc" "none_0hit")
+;;   (set_attr "length_table" "logicb")])
+
+;;(define_insn_and_split "*cmpcondbclrreg"
+;;  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
+;;	(if_then_else:QI (match_operator 1 "eqne_operator"
+;;			  [(match_operand 2 "h8300_dst_operand" "r,rQ")
+;;			   (match_operand 3 "h8300_src_operand" "I,rQi")])
+;;			 (and:QI (match_operand:QI 4 "bit_memory_operand" "0,0")
+;;				 (ashift:QI (const_int 1)
+;;					    (match_operand:QI 5 "register_operand" "r,r")))
+;;			 (match_dup 4)))]
+;;  "TARGET_H8300SX"
+;;  "#"
+;;  "reload_completed"
+;;  [(set (cc0) (match_dup 6))
+;;   (set (match_dup 0)
+;;	(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])
+;;			 (and:QI (match_dup 4)
+;;				 (ashift:QI (const_int 1)
+;;					    (match_operand:QI 5 "register_operand" "r,r")))
+;;			 (match_dup 4)))]
+;;  {
+;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
+;;  }
+;;  [(set_attr "cc" "set_znv,compare")])
+
+;;(define_insn "*condbclrreg"
+;;  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
+;;	(if_then_else:QI (match_operator:QI 2 "eqne_operator"
+;;			  [(cc0) (const_int 0)])
+;;			 (and:QI (match_operand:QI 3 "bit_memory_operand" "0")
+;;				 (ashift:QI (const_int 1)
+;;					    (match_operand:QI 1 "register_operand" "r")))
+;;			 (match_dup 3)))]
+;;  "TARGET_H8300SX && reload_completed"
+;;  "bclr/%j2\t%R1,%0"
+;;  [(set_attr "cc" "none_0hit")
+;;   (set_attr "length_table" "logicb")])
+
diff --git a/gcc/config/h8300/combiner.md b/gcc/config/h8300/combiner.md
new file mode 100644
index 00000000000..6f7cb2eef9e
--- /dev/null
+++ b/gcc/config/h8300/combiner.md
@@ -0,0 +1,1278 @@
+;; -----------------------------------------------------------------
+;; COMBINE PATTERNS
+;; -----------------------------------------------------------------
+
+;; insv:SI
+
+(define_insn_and_split "*insv_si_1_n"
+  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
+			 (const_int 1)
+			 (match_operand:SI 1 "const_int_operand" "n"))
+	(match_operand:SI 2 "register_operand" "r"))]
+  "INTVAL (operands[1]) < 16"
+  "#"
+  "reload_completed"
+  [(parallel [(set (zero_extract:SI (match_dup 0) (const_int 1) (match_dup 1))
+		   (match_dup 2))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*insv_si_1_n_clobber_flags"
+  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
+			 (const_int 1)
+			 (match_operand:SI 1 "const_int_operand" "n"))
+	(match_operand:SI 2 "register_operand" "r"))
+   (clobber (reg:CC CC_REG))]
+  "INTVAL (operands[1]) < 16"
+  "bld\\t#0,%w2\;bst\\t%Z1,%Y0"
+  [(set_attr "length" "4")])
+
+(define_insn_and_split "*insv_si_1_n_lshiftrt"
+  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
+			 (const_int 1)
+			 (match_operand:SI 1 "const_int_operand" "n"))
+	(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
+		     (match_operand:SI 3 "const_int_operand" "n")))]
+  "INTVAL (operands[1]) < 16 && INTVAL (operands[3]) < 16"
+  "#"
+  "reload_completed"
+  [(parallel [(set (zero_extract:SI (match_dup 0) (const_int 1) (match_dup 1))
+		   (lshiftrt:SI (match_dup 2) (match_dup 3)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*insv_si_1_n_lshiftrt_clobber_flags"
+  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
+			 (const_int 1)
+			 (match_operand:SI 1 "const_int_operand" "n"))
+	(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
+		     (match_operand:SI 3 "const_int_operand" "n")))
+   (clobber (reg:CC CC_REG))]
+  "INTVAL (operands[1]) < 16 && INTVAL (operands[3]) < 16"
+  "bld\\t%Z3,%Y2\;bst\\t%Z1,%Y0"
+  [(set_attr "length" "4")])
+
+(define_insn_and_split "*insv_si_1_n_lshiftrt_16"
+  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
+			 (const_int 1)
+			 (match_operand:SI 1 "const_int_operand" "n"))
+	(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
+		     (const_int 16)))]
+  "INTVAL (operands[1]) < 16"
+  "#"
+  "reload_completed"
+  [(parallel [(set (zero_extract:SI (match_dup 0) (const_int 1) (match_dup 1))
+		   (lshiftrt:SI (match_dup 2) (const_int 16)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*insv_si_1_n_lshiftrt_16_clobber_flags"
+  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
+			 (const_int 1)
+			 (match_operand:SI 1 "const_int_operand" "n"))
+	(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
+		     (const_int 16)))
+   (clobber (reg:CC CC_REG))]
+  "INTVAL (operands[1]) < 16"
+  "rotr.w\\t%e2\;rotl.w\\t%e2\;bst\\t%Z1,%Y0"
+  [(set_attr "length" "6")])
+
+(define_insn_and_split "*insv_si_8_8"
+  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
+			 (const_int 8)
+			 (const_int 8))
+	(match_operand:SI 1 "register_operand" "r"))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (zero_extract:SI (match_dup 0) (const_int 8) (const_int 8))
+		   (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*insv_si_8_8_clobber_flags"
+  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
+			 (const_int 8)
+			 (const_int 8))
+	(match_operand:SI 1 "register_operand" "r"))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.b\\t%w1,%x0"
+  [(set_attr "length" "2")])
+
+(define_insn_and_split "*insv_si_8_8_lshiftrt_8"
+  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
+			 (const_int 8)
+			 (const_int 8))
+	(lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+		     (const_int 8)))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (zero_extract:SI (match_dup 0) (const_int 8) (const_int 8))
+		   (lshiftrt:SI (match_dup 1) (const_int 8)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*insv_si_8_8_lshiftrt_8_clobber_flags"
+  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
+			 (const_int 8)
+			 (const_int 8))
+	(lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+		     (const_int 8)))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.b\\t%x1,%x0"
+  [(set_attr "length" "2")])
+
+;; extzv:SI
+
+(define_insn_and_split "*extzv_8_8"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extract:SI (match_operand:SI 1 "register_operand" "?0,r")
+			 (const_int 8)
+			 (const_int 8)))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (zero_extract:SI (match_dup 1) (const_int 8) (const_int 8)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*extzv_8_8_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extract:SI (match_operand:SI 1 "register_operand" "?0,r")
+			 (const_int 8)
+			 (const_int 8)))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "@
+   mov.b\\t%x1,%w0\;extu.w\\t%f0\;extu.l\\t%S0
+   sub.l\\t%S0,%S0\;mov.b\\t%x1,%w0"
+  [(set_attr "cc" "set_znv,clobber")
+   (set_attr "length" "6,4")])
+
+(define_insn_and_split "*extzv_8_16"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extract:SI (match_operand:SI 1 "register_operand" "r")
+			 (const_int 8)
+			 (const_int 16)))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (zero_extract:SI (match_dup 1) (const_int 8) (const_int 16)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*extzv_8_16_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extract:SI (match_operand:SI 1 "register_operand" "r")
+			 (const_int 8)
+			 (const_int 16)))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.w\\t%e1,%f0\;extu.w\\t%f0\;extu.l\\t%S0"
+  [(set_attr "cc" "set_znv")
+   (set_attr "length" "6")])
+
+(define_insn_and_split "*extzv_16_8"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extract:SI (match_operand:SI 1 "register_operand" "r")
+			 (const_int 16)
+			 (const_int 8)))
+   (clobber (match_scratch:SI 2 "=&r"))]
+  "TARGET_H8300H"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (zero_extract:SI (match_dup 1) (const_int 16) (const_int 8)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*extzv_16_8_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extract:SI (match_operand:SI 1 "register_operand" "r")
+			 (const_int 16)
+			 (const_int 8)))
+   (clobber (match_scratch:SI 2 "=&r"))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300H"
+  "mov.w\\t%e1,%f2\;mov.b\\t%x1,%w0\;mov.b\\t%w2,%x0\;extu.l\\t%S0"
+  [(set_attr "length" "8")
+   (set_attr "cc" "set_znv")])
+
+;; Extract the exponent of a float.
+
+(define_insn_and_split "*extzv_8_23"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extract:SI (match_operand:SI 1 "register_operand" "0")
+			 (const_int 8)
+			 (const_int 23)))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ashift:SI (match_dup 0)
+			      (const_int 1)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0)
+		   (lshiftrt:SI (match_dup 0)
+				(const_int 24)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])])
+
+;; and:SI
+
+;; ((SImode) HImode) << 15
+
+(define_insn_and_split "*twoshifts_l16_r1"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(and:SI (ashift:SI (match_operand:SI 1 "register_operand" "0")
+			   (const_int 15))
+		(const_int 2147450880)))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ashift:SI (match_dup 0)
+			      (const_int 16)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0)
+		   (lshiftrt:SI (match_dup 0)
+				(const_int 1)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])])
+
+;; Transform (SImode << B) & 0xffff into (SImode) (HImode << B).
+
+(define_insn_and_split "*andsi3_ashift_n_lower"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(and:SI (ashift:SI (match_operand:SI 1 "register_operand" "0,0")
+			   (match_operand:QI 2 "const_int_operand" "S,n"))
+		(match_operand:SI 3 "const_int_operand" "n,n")))
+   (clobber (match_scratch:QI 4 "=X,&r"))]
+  "INTVAL (operands[2]) <= 15
+   && UINTVAL (operands[3]) == ((HOST_WIDE_INT_M1U << INTVAL (operands[2]))
+				& 0xffff)"
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 5)
+		   (ashift:HI (match_dup 5)
+			      (match_dup 2)))
+	      (clobber (match_dup 4))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0)
+		   (zero_extend:SI (match_dup 5)))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[5] = gen_rtx_REG (HImode, REGNO (operands[0]));
+  })
+
+;; Accept (A >> 30) & 2 and the like.
+
+(define_insn_and_split "*andsi3_lshiftrt_n_sb"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
+			     (match_operand:SI 2 "const_int_operand" "n"))
+		(match_operand:SI 3 "single_one_operand" "n")))]
+  "exact_log2 (INTVAL (operands[3])) < 16
+   && INTVAL (operands[2]) + exact_log2 (INTVAL (operands[3])) == 31"
+  "#"
+  ""
+  [(parallel [(set (match_dup 0)
+		   (and:SI (lshiftrt:SI (match_dup 1) (match_dup 2))
+			   (match_dup 3)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*andsi3_lshiftrt_n_sb"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
+			     (match_operand:SI 2 "const_int_operand" "n"))
+		(match_operand:SI 3 "single_one_operand" "n")))
+   (clobber (reg:CC CC_REG))]
+  "exact_log2 (INTVAL (operands[3])) < 16
+   && INTVAL (operands[2]) + exact_log2 (INTVAL (operands[3])) == 31"
+{
+  operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
+  return "shll.l\\t%S0\;xor.l\\t%S0,%S0\;bst\\t%Z3,%Y0";
+}
+  [(set_attr "length" "8")])
+
+(define_insn_and_split "*andsi3_lshiftrt_9_sb"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
+			     (const_int 9))
+		(const_int 4194304)))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (and:SI (lshiftrt:SI (match_dup 0) (const_int 25))
+			   (const_int 64)))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0)
+		   (ashift:SI (match_dup 0)
+			      (const_int 16)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])])
+
+;; plus:SI
+
+(define_insn_and_split "*addsi3_upper"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "r")
+			  (const_int 65536))
+		 (match_operand:SI 2 "register_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (plus:SI (mult:SI (match_dup 1) (const_int 65536))
+			    (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*addsi3_upper_clobber_regs"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "r")
+			  (const_int 65536))
+		 (match_operand:SI 2 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "add.w\\t%f1,%e0"
+  [(set_attr "length" "2")])
+
+(define_insn_and_split "*addsi3_lshiftrt_16_zexthi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(plus:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+			      (const_int 16))
+		 (zero_extend:SI (match_operand:HI 2 "register_operand" "0"))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (plus:SI (lshiftrt:SI (match_dup 1) (const_int 16))
+			    (zero_extend:SI (match_dup 2))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*addsi3_lshiftrt_16_zexthi_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(plus:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+			      (const_int 16))
+		 (zero_extend:SI (match_operand:HI 2 "register_operand" "0"))))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "add.w\\t%e1,%f0\;xor.w\\t%e0,%e0\;rotxl.w\\t%e0"
+  [(set_attr "length" "6")])
+
+;;(define_insn_and_split "*addsi3_and_r_1"
+;;  [(set (match_operand:SI 0 "register_operand" "=r")
+;;	(plus:SI (and:SI (match_operand:SI 1 "register_operand" "r")
+;;			 (const_int 1))
+;;		 (match_operand:SI 2 "register_operand" "0")))]
+;;  ""
+;;  "#"
+;;  "&& reload_completed"
+;;  [(set (cc0) (compare (zero_extract:SI (match_dup 1)
+;;					(const_int 1)
+;;					(const_int 0))
+;;		       (const_int 0)))
+;;   (set (pc)
+;;        (if_then_else (eq (cc0)
+;;			  (const_int 0))
+;;		      (label_ref (match_dup 3))
+;;		      (pc)))
+;;   (set (match_dup 2)
+;;        (plus:SI (match_dup 2)
+;;		 (const_int 1)))
+;;   (match_dup 3)]
+;;  {
+;;    operands[3] = gen_label_rtx ();
+;;  })
+
+;;(define_insn_and_split "*addsi3_and_not_r_1"
+;;  [(set (match_operand:SI 0 "register_operand" "=r")
+;;	(plus:SI (and:SI (not:SI (match_operand:SI 1 "register_operand" "r"))
+;;			 (const_int 1))
+;;		 (match_operand:SI 2 "register_operand" "0")))]
+;;  ""
+;;  "#"
+;;  "&& reload_completed"
+;;  [(set (cc0) (compare (zero_extract:SI (match_dup 1)
+;;					(const_int 1)
+;;					(const_int 0))
+;;		       (const_int 0)))
+;;   (set (pc)
+;;        (if_then_else (ne (cc0)
+;;			  (const_int 0))
+;;		      (label_ref (match_dup 3))
+;;		      (pc)))
+;;   (set (match_dup 2)
+;;        (plus:SI (match_dup 2)
+;;		 (const_int 1)))
+;;   (match_dup 3)]
+;;  {
+;;    operands[3] = gen_label_rtx ();
+;;  })
+
+;; [ix]or:HI
+
+(define_insn_and_split "*ixorhi3_zext"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(match_operator:HI 1 "iorxor_operator"
+	 [(zero_extend:HI (match_operand:QI 2 "register_operand" "r"))
+	  (match_operand:HI 3 "register_operand" "0")]))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 1 [(zero_extend:HI (match_dup 2))
+				    (match_dup 3)]))
+	      (clobber (reg:CC CC_REG))])])
+
+
+(define_insn "*ixorhi3_zext_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(match_operator:HI 1 "iorxor_operator"
+	 [(zero_extend:HI (match_operand:QI 2 "register_operand" "r"))
+	  (match_operand:HI 3 "register_operand" "0")]))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "%c1.b\\t%X2,%s0"
+  [(set_attr "length" "2")])
+
+;; [ix]or:SI
+
+(define_insn_and_split "*ixorsi3_zext_qi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "iorxor_operator"
+	 [(zero_extend:SI (match_operand:QI 2 "register_operand" "r"))
+	  (match_operand:SI 3 "register_operand" "0")]))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 1 [(zero_extend:SI (match_dup 2))
+				    (match_dup 3)]))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*ixorsi3_zext_qi_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "iorxor_operator"
+	 [(zero_extend:SI (match_operand:QI 2 "register_operand" "r"))
+	  (match_operand:SI 3 "register_operand" "0")]))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "%c1.b\\t%X2,%w0"
+  [(set_attr "length" "2")])
+
+(define_insn_and_split "*ixorsi3_zext_hi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "iorxor_operator"
+	 [(zero_extend:SI (match_operand:HI 2 "register_operand" "r"))
+	  (match_operand:SI 3 "register_operand" "0")]))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 1 [(zero_extend:SI (match_dup 2))
+				    (match_dup 3)]))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*ixorsi3_zext_hi_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "iorxor_operator"
+	 [(zero_extend:SI (match_operand:HI 2 "register_operand" "r"))
+	  (match_operand:SI 3 "register_operand" "0")]))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "%c1.w\\t%T2,%f0"
+  [(set_attr "length" "2")])
+
+(define_insn_and_split "*ixorsi3_ashift_16"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "iorxor_operator"
+	 [(ashift:SI (match_operand:SI 2 "register_operand" "r")
+		     (const_int 16))
+	  (match_operand:SI 3 "register_operand" "0")]))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 1 [(ashift:SI (match_dup 2) (const_int 16))
+				    (match_dup 3)]))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*ixorsi3_ashift_16_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "iorxor_operator"
+	 [(ashift:SI (match_operand:SI 2 "register_operand" "r")
+		     (const_int 16))
+	  (match_operand:SI 3 "register_operand" "0")]))
+  (clobber (reg:CC CC_REG))]
+  ""
+  "%c1.w\\t%f2,%e0"
+  [(set_attr "length" "2")])
+
+(define_insn_and_split "*ixorsi3_lshiftrt_16"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "iorxor_operator"
+	 [(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
+		       (const_int 16))
+	  (match_operand:SI 3 "register_operand" "0")]))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 1 [(lshiftrt:SI (match_dup 2) (const_int 16))
+				    (match_dup 3)]))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*ixorsi3_lshiftrt_16_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(match_operator:SI 1 "iorxor_operator"
+	 [(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
+		       (const_int 16))
+	  (match_operand:SI 3 "register_operand" "0")]))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "%c1.w\\t%e2,%f0"
+  [(set_attr "length" "2")])
+
+;; ior:HI
+
+(define_insn_and_split "*iorhi3_ashift_8"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(ior:HI (ashift:HI (match_operand:HI 1 "register_operand" "r")
+			   (const_int 8))
+		(match_operand:HI 2 "register_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:HI (ashift:HI (match_dup 1) (const_int 8))
+			   (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorhi3_ashift_8_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(ior:HI (ashift:HI (match_operand:HI 1 "register_operand" "r")
+			   (const_int 8))
+		(match_operand:HI 2 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "or.b\\t%s1,%t0"
+  [(set_attr "length" "2")])
+
+(define_insn_and_split "*iorhi3_lshiftrt_8"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(ior:HI (lshiftrt:HI (match_operand:HI 1 "register_operand" "r")
+			     (const_int 8))
+		(match_operand:HI 2 "register_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:HI (lshiftrt:HI (match_dup 1) (const_int 8))
+			   (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorhi3_lshiftrt_8_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(ior:HI (lshiftrt:HI (match_operand:HI 1 "register_operand" "r")
+			     (const_int 8))
+		(match_operand:HI 2 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "or.b\\t%t1,%s0"
+  [(set_attr "length" "2")])
+
+(define_insn_and_split "*iorhi3_two_qi"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(ior:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "0"))
+		(ashift:HI (match_operand:HI 2 "register_operand" "r")
+			   (const_int 8))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:HI (zero_extend:HI (match_dup 1))
+			   (ashift:HI (match_dup 2) (const_int 8))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorhi3_two_qi_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(ior:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "0"))
+		(ashift:HI (match_operand:HI 2 "register_operand" "r")
+			   (const_int 8))))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.b\\t%s2,%t0"
+  [(set_attr "length" "2")])
+
+(define_insn_and_split "*iorhi3_two_qi_mem"
+  [(set (match_operand:HI 0 "register_operand" "=&r")
+	(ior:HI (zero_extend:HI (match_operand:QI 1 "memory_operand" "m"))
+		(ashift:HI (subreg:HI (match_operand:QI 2 "memory_operand" "m") 0)
+			   (const_int 8))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:HI (zero_extend:HI (match_dup 1))
+			   (ashift:HI (subreg:HI (match_dup 2) 0)
+				      (const_int 8))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorhi3_two_qi_mem_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=&r")
+	(ior:HI (zero_extend:HI (match_operand:QI 1 "memory_operand" "m"))
+		(ashift:HI (subreg:HI (match_operand:QI 2 "memory_operand" "m") 0)
+			   (const_int 8))))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.b\\t%X2,%t0\;mov.b\\t%X1,%s0"
+  [(set_attr "length" "16")])
+
+(define_split
+  [(set (match_operand:HI 0 "register_operand" "")
+	(ior:HI (zero_extend:HI (match_operand:QI 1 "memory_operand" ""))
+		(ashift:HI (subreg:HI (match_operand:QI 2 "memory_operand" "") 0)
+			   (const_int 8))))]
+  "reload_completed
+   && byte_accesses_mergeable_p (XEXP (operands[2], 0), XEXP (operands[1], 0))"
+  [(parallel [(set (match_dup 0) (match_dup 3))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[3] = gen_rtx_MEM (HImode, XEXP (operands[2], 0));
+  })
+
+;; ior:SI
+
+(define_insn_and_split "*iorsi3_two_hi"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (zero_extend:SI (match_operand:HI 1 "register_operand" "0"))
+		(ashift:SI (match_operand:SI 2 "register_operand" "r")
+			   (const_int 16))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:SI (zero_extend:SI (match_dup 1))
+			   (ashift:SI (match_dup 2) (const_int 16))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorsi3_two_hi_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (zero_extend:SI (match_operand:HI 1 "register_operand" "0"))
+		(ashift:SI (match_operand:SI 2 "register_operand" "r")
+			   (const_int 16))))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.w\\t%f2,%e0"
+  [(set_attr "length" "2")])
+
+(define_insn_and_split "*iorsi3_two_qi_zext"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+	(ior:SI (zero_extend:SI (match_operand:QI 1 "memory_operand" "m"))
+		(and:SI (ashift:SI (subreg:SI (match_operand:QI 2 "memory_operand" "m") 0)
+				   (const_int 8))
+			(const_int 65280))))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 3)
+		   (ior:HI (zero_extend:HI (match_dup 1))
+			   (ashift:HI (subreg:HI (match_dup 2) 0)
+				      (const_int 8))))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0) (zero_extend:SI (match_dup 3)))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));
+  })
+
+(define_insn_and_split "*iorsi3_e2f"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (match_operand:SI 1 "register_operand" "0")
+			(const_int -65536))
+		(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
+			     (const_int 16))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:SI (and:SI (match_dup 1) (const_int -65536))
+			   (lshiftrt:SI (match_dup 2) (const_int 16))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorsi3_e2f_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (match_operand:SI 1 "register_operand" "0")
+			(const_int -65536))
+		(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
+			     (const_int 16))))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.w\\t%e2,%f0"
+  [(set_attr "length" "2")])
+
+(define_insn_and_split "*iorsi3_two_qi_sext"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (zero_extend:SI (match_operand:QI 1 "register_operand" "0"))
+		(ashift:SI (sign_extend:SI (match_operand:QI 2 "register_operand" "r"))
+			   (const_int 8))))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 3)
+		   (ior:HI (zero_extend:HI (match_dup 1))
+			   (ashift:HI (match_dup 4) (const_int 8))))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0) (sign_extend:SI (match_dup 3)))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));
+    operands[4] = gen_rtx_REG (HImode, REGNO (operands[2]));
+  })
+
+(define_insn_and_split "*iorsi3_w"
+  [(set (match_operand:SI 0 "register_operand" "=r,&r")
+	(ior:SI (and:SI (match_operand:SI 1 "register_operand" "0,0")
+			(const_int -256))
+		(zero_extend:SI (match_operand:QI 2 "general_operand_src" "r,g>"))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:SI (and:SI (match_dup 1) (const_int -256))
+			   (zero_extend:SI (match_dup 2))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorsi3_w_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r,&r")
+	(ior:SI (and:SI (match_operand:SI 1 "register_operand" "0,0")
+			(const_int -256))
+		(zero_extend:SI (match_operand:QI 2 "general_operand_src" "r,g>"))))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.b\\t%X2,%w0"
+  [(set_attr "length" "2,8")])
+
+(define_insn_and_split "*iorsi3_ashift_31"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "r")
+			   (const_int 31))
+		(match_operand:SI 2 "register_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:SI (ashift:SI (match_dup 1) (const_int 31))
+			   (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorsi3_ashift_31_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "r")
+			   (const_int 31))
+		(match_operand:SI 2 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "rotxl.l\\t%S0\;bor\\t#0,%w1\;rotxr.l\\t%S0"
+  [(set_attr "length" "6")
+   (set_attr "cc" "set_znv")])
+
+(define_insn_and_split "*iorsi3_and_ashift"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (ashift:SI (match_operand:SI 1 "register_operand" "r")
+				   (match_operand:SI 2 "const_int_operand" "n"))
+			(match_operand:SI 3 "single_one_operand" "n"))
+		(match_operand:SI 4 "register_operand" "0")))]
+  "(INTVAL (operands[3]) & ~0xffff) == 0"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:SI (and:SI (ashift:SI (match_dup 1) (match_dup 2))
+				   (match_dup 3))
+			  (match_dup 4)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorsi3_and_ashift_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (ashift:SI (match_operand:SI 1 "register_operand" "r")
+				   (match_operand:SI 2 "const_int_operand" "n"))
+			(match_operand:SI 3 "single_one_operand" "n"))
+		(match_operand:SI 4 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  "(INTVAL (operands[3]) & ~0xffff) == 0"
+{
+  rtx srcpos = GEN_INT (exact_log2 (INTVAL (operands[3]))
+			- INTVAL (operands[2]));
+  rtx dstpos = GEN_INT (exact_log2 (INTVAL (operands[3])));
+  operands[2] = srcpos;
+  operands[3] = dstpos;
+  return "bld\\t%Z2,%Y1\;bor\\t%Z3,%Y0\;bst\\t%Z3,%Y0";
+}
+  [(set_attr "length" "6")])
+
+(define_insn_and_split "*iorsi3_and_lshiftrt"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				     (match_operand:SI 2 "const_int_operand" "n"))
+			(match_operand:SI 3 "single_one_operand" "n"))
+		(match_operand:SI 4 "register_operand" "0")))]
+  "((INTVAL (operands[3]) << INTVAL (operands[2])) & ~0xffff) == 0"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:SI (and:SI (lshiftrt:SI (match_dup 1) (match_dup 2))
+				   (match_dup 3))
+			   (match_dup 4)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorsi3_and_lshiftrt_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				     (match_operand:SI 2 "const_int_operand" "n"))
+			(match_operand:SI 3 "single_one_operand" "n"))
+		(match_operand:SI 4 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  "((INTVAL (operands[3]) << INTVAL (operands[2])) & ~0xffff) == 0"
+{
+  rtx srcpos = GEN_INT (exact_log2 (INTVAL (operands[3]))
+			+ INTVAL (operands[2]));
+  rtx dstpos = GEN_INT (exact_log2 (INTVAL (operands[3])));
+  operands[2] = srcpos;
+  operands[3] = dstpos;
+  return "bld\\t%Z2,%Y1\;bor\\t%Z3,%Y0\;bst\\t%Z3,%Y0";
+}
+  [(set_attr "length" "6")])
+
+(define_insn_and_split "*iorsi3_zero_extract"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (zero_extract:SI (match_operand:SI 1 "register_operand" "r")
+				 (const_int 1)
+				 (match_operand:SI 2 "const_int_operand" "n"))
+		(match_operand:SI 3 "register_operand" "0")))]
+  "INTVAL (operands[2]) < 16"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:SI (zero_extract:SI (match_dup 1)
+					    (const_int 1)
+					    (match_dup 2))
+			   (match_dup 3)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorsi3_zero_extract_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (zero_extract:SI (match_operand:SI 1 "register_operand" "r")
+				 (const_int 1)
+				 (match_operand:SI 2 "const_int_operand" "n"))
+		(match_operand:SI 3 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  "INTVAL (operands[2]) < 16"
+  "bld\\t%Z2,%Y1\;bor\\t#0,%w0\;bst\\t#0,%w0"
+  [(set_attr "length" "6")])
+
+(define_insn_and_split "*iorsi3_and_lshiftrt_n_sb"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				     (const_int 30))
+			(const_int 2))
+		(match_operand:SI 2 "register_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:SI (and:SI (lshiftrt:SI (match_dup 1) (const_int 30))
+				   (const_int 2))
+			   (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorsi3_and_lshiftrt_n_sb_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				     (const_int 30))
+			(const_int 2))
+		(match_operand:SI 2 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "rotl.l\\t%S1\;rotr.l\\t%S1\;bor\\t#1,%w0\;bst\\t#1,%w0"
+  [(set_attr "length" "8")])
+
+(define_insn_and_split "*iorsi3_and_lshiftrt_9_sb"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				     (const_int 9))
+			(const_int 4194304))
+		(match_operand:SI 2 "register_operand" "0")))
+   (clobber (match_scratch:HI 3 "=&r"))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:SI (and:SI (lshiftrt:SI (match_dup 1) (const_int 9))
+				   (const_int 4194304))
+			   (match_dup 2)))
+	      (clobber (match_dup 3))
+	      (clobber (reg:CC CC_REG))])])
+
+
+(define_insn "*iorsi3_and_lshiftrt_9_sb_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				     (const_int 9))
+			(const_int 4194304))
+		(match_operand:SI 2 "register_operand" "0")))
+   (clobber (match_scratch:HI 3 "=&r"))
+   (clobber (reg:CC CC_REG))]
+  ""
+{
+  if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))
+    return "shll.l\\t%S1\;xor.w\\t%T3,%T3\;bst\\t#6,%s3\;or.w\\t%T3,%e0";
+  else
+    return "rotl.l\\t%S1\;rotr.l\\t%S1\;xor.w\\t%T3,%T3\;bst\\t#6,%s3\;or.w\\t%T3,%e0";
+}
+  [(set_attr "length" "10")])
+
+;; Used to OR the exponent of a float.
+
+(define_insn "*iorsi3_shift"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "r")
+			   (const_int 23))
+		(match_operand:SI 2 "register_operand" "0")))
+   (clobber (match_scratch:SI 3 "=&r"))]
+  ""
+  "#")
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "")
+			   (const_int 23))
+		(match_dup 0)))
+   (clobber (match_operand:SI 2 "register_operand" ""))]
+  "epilogue_completed
+   && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))
+   && REGNO (operands[0]) != REGNO (operands[1])"
+  [(parallel [(set (match_dup 3)
+		   (ashift:HI (match_dup 3)
+			      (const_int 7)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0)
+		    (ior:SI (ashift:SI (match_dup 1) (const_int 16))
+			    (match_dup 0)))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[1]));
+  })
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "")
+			   (const_int 23))
+		(match_dup 0)))
+   (clobber (match_operand:SI 2 "register_operand" ""))]
+  "epilogue_completed
+   && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))
+	&& REGNO (operands[0]) != REGNO (operands[1]))"
+  [(parallel [(set (match_dup 2) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 3)
+		   (ashift:HI (match_dup 3)
+			      (const_int 7)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0)
+		   (ior:SI (ashift:SI (match_dup 2) (const_int 16))
+			   (match_dup 0)))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[2]));
+  })
+
+(define_insn_and_split "*iorsi2_and_1_lshiftrt_1"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (match_operand:SI 1 "register_operand" "0")
+			(const_int 1))
+		(lshiftrt:SI (match_dup 1)
+			     (const_int 1))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (ior:SI (and:SI (match_dup 1) (const_int 1))
+			   (lshiftrt:SI (match_dup 1) (const_int 1))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*iorsi2_and_1_lshiftrt_1_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (match_operand:SI 1 "register_operand" "0")
+			(const_int 1))
+		(lshiftrt:SI (match_dup 1)
+			     (const_int 1))))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "shlr.l\\t%S0\;bor\\t#0,%w0\;bst\\t#0,%w0"
+  [(set_attr "length" "6")])
+
+(define_insn_and_split "*iorsi3_ashift_16_ashift_24"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "0")
+			   (const_int 16))
+		(ashift:SI (match_operand:SI 2 "register_operand" "r")
+			   (const_int 24))))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 3)
+		   (ior:HI (ashift:HI (match_dup 4) (const_int 8))
+			   (match_dup 3)))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0)
+		   (ashift:SI (match_dup 0)
+			      (const_int 16)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));
+    operands[4] = gen_rtx_REG (HImode, REGNO (operands[2]));
+  })
+
+(define_insn_and_split "*iorsi3_ashift_16_ashift_24_mem"
+  [(set (match_operand:SI 0 "register_operand" "=&r")
+	(ior:SI (and:SI (ashift:SI (subreg:SI (match_operand:QI 1 "memory_operand" "m") 0)
+				   (const_int 16))
+			(const_int 16711680))
+		(ashift:SI (subreg:SI (match_operand:QI 2 "memory_operand" "m") 0)
+			   (const_int 24))))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 3)
+		   (ior:HI (zero_extend:HI (match_dup 1))
+			   (ashift:HI (subreg:HI (match_dup 2) 0)
+				      (const_int 8))))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0)
+		   (ashift:SI (match_dup 0)
+			      (const_int 16)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));
+  })
+
+;; Used to add the exponent of a float.
+
+(define_insn "*addsi3_shift"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "r")
+			  (const_int 8388608))
+		 (match_operand:SI 2 "register_operand" "0")))
+   (clobber (match_scratch:SI 3 "=&r"))]
+  ""
+  "#")
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "")
+			  (const_int 8388608))
+		 (match_dup 0)))
+   (clobber (match_operand:SI 2 "register_operand" ""))]
+  "epilogue_completed
+   && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))
+   && REGNO (operands[0]) != REGNO (operands[1])"
+  [(parallel [(set (match_dup 3)
+		   (ashift:HI (match_dup 3)
+			      (const_int 7)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0)
+		   (plus:SI (mult:SI (match_dup 1) (const_int 65536))
+			    (match_dup 0)))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[1]));
+  })
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "")
+			  (const_int 8388608))
+		 (match_dup 0)))
+   (clobber (match_operand:SI 2 "register_operand" ""))]
+  "epilogue_completed
+   && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))
+	&& REGNO (operands[0]) != REGNO (operands[1]))"
+  [(parallel [(set (match_dup 2) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 3)
+		   (ashift:HI (match_dup 3)
+			      (const_int 7)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0)
+		   (plus:SI (mult:SI (match_dup 2) (const_int 65536))
+			    (match_dup 0)))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[3] = gen_rtx_REG (HImode, REGNO (operands[2]));
+  })
+
+;; ashift:SI
+
+(define_insn_and_split "*ashiftsi_sextqi_7"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ashift:SI (sign_extend:SI (match_operand:QI 1 "register_operand" "0"))
+		   (const_int 7)))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 2)
+		   (ashift:HI (match_dup 2)
+			      (const_int 8)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0) (sign_extend:SI (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0)
+		   (ashiftrt:SI (match_dup 0)
+				(const_int 1)))
+	      (clobber (scratch:QI))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[2] = gen_rtx_REG (HImode, REGNO (operands[0]));
+  })
+
+;; Storing a part of HImode to QImode.
+
+(define_insn_and_split ""
+  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
+	(subreg:QI (lshiftrt:HI (match_operand:HI 1 "register_operand" "r")
+				(const_int 8)) 1))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (subreg:QI (lshiftrt:HI (match_dup 1)
+							 (const_int 8)) 1))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn ""
+  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
+	(subreg:QI (lshiftrt:HI (match_operand:HI 1 "register_operand" "r")
+				(const_int 8)) 1))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.b\\t%t1,%R0"
+  [(set_attr "cc" "set_znv")
+   (set_attr "length" "8")])
+
+;; Storing a part of SImode to QImode.
+
+(define_insn_and_split ""
+  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
+	(subreg:QI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				(const_int 8)) 3))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (subreg:QI (lshiftrt:SI (match_dup 1) (const_int 8)) 3))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn ""
+  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
+	(subreg:QI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				(const_int 8)) 3))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.b\\t%x1,%R0"
+  [(set_attr "cc" "set_znv")
+   (set_attr "length" "8")])
+
+(define_insn_and_split ""
+  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
+	(subreg:QI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				(const_int 16)) 3))
+   (clobber (match_scratch:SI 2 "=&r"))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (subreg:QI (lshiftrt:SI (match_dup 1) (const_int 16)) 3))
+	      (clobber (match_dup 2))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn ""
+  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
+	(subreg:QI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				(const_int 16)) 3))
+   (clobber (match_scratch:SI 2 "=&r"))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.w\\t%e1,%f2\;mov.b\\t%w2,%R0"
+  [(set_attr "cc" "set_znv")
+   (set_attr "length" "10")])
+
+(define_insn_and_split ""
+  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
+	(subreg:QI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				(const_int 24)) 3))
+   (clobber (match_scratch:SI 2 "=&r"))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (subreg:QI (lshiftrt:SI (match_dup 1) (const_int 24)) 3))
+	      (clobber (match_dup 2))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn ""
+  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
+	(subreg:QI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
+				(const_int 24)) 3))
+   (clobber (match_scratch:SI 2 "=&r"))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.w\\t%e1,%f2\;mov.b\\t%x2,%R0"
+  [(set_attr "cc" "set_znv")
+   (set_attr "length" "10")])
+
+;;(define_insn_and_split ""
+;;  [(set (pc)
+;;	(if_then_else (eq (zero_extract:SI (subreg:SI (match_operand:QI 0 "register_operand" "") 0)
+;;					   (const_int 1)
+;;					   (const_int 7))
+;;			  (const_int 0))
+;;		      (label_ref (match_operand 1 "" ""))
+;;		      (pc)))]
+;;  ""
+;;  "#"
+;;  ""
+;;  [(set (cc0) (compare (match_dup 0)
+;;		       (const_int 0)))
+;;   (set (pc)
+;;	(if_then_else (ge (cc0)
+;;			  (const_int 0))
+;;		      (label_ref (match_dup 1))
+;;		      (pc)))]
+;;  "")
+
+;;(define_insn_and_split ""
+;;  [(set (pc)
+;;	(if_then_else (ne (zero_extract:SI (subreg:SI (match_operand:QI 0 "register_operand" "") 0)
+;;					   (const_int 1)
+;;					   (const_int 7))
+;;			  (const_int 0))
+;;		      (label_ref (match_operand 1 "" ""))
+;;		      (pc)))]
+;;  ""
+;;  "#"
+;;  ""
+;;  [(set (cc0) (compare (match_dup 0)
+;;		       (const_int 0)))
+;;   (set (pc)
+;;	(if_then_else (lt (cc0)
+;;			  (const_int 0))
+;;		      (label_ref (match_dup 1))
+;;		      (pc)))]
+;;  "")
diff --git a/gcc/config/h8300/constraints.md b/gcc/config/h8300/constraints.md
index fee44e847db..d24518225f8 100644
--- a/gcc/config/h8300/constraints.md
+++ b/gcc/config/h8300/constraints.md
@@ -82,11 +82,9 @@
        (match_test "(ival & 0xff) == 0")))
 
 (define_constraint "L"
-  "1, 2 or 4 on the H8300H or S; 1 or 2 otherwise."
+  "Integer 1, 2 or 4"
   (and (match_code "const_int")
-       (if_then_else (match_test "TARGET_H8300H || TARGET_H8300S")
-		     (match_test "ival == 1 || ival == 2 || ival == 4")
-		     (match_test "ival == 1 || ival == 2"))))
+       (match_test "ival == 1 || ival == 2 || ival == 4")))
 
 (define_constraint "M"
   "Integer 1 or 2."
@@ -94,11 +92,9 @@
        (match_test "ival == 1 || ival == 2")))
 
 (define_constraint "N"
-  "-1, -2, or -4 on the H8300H or S; -1 or -2 otherwise."
+  "Integer -1, -2 or -4"
   (and (match_code "const_int")
-       (if_then_else (match_test "TARGET_H8300H || TARGET_H8300S")
-		     (match_test "ival == -1 || ival == -2 || ival == -4")
-		     (match_test "ival == -1 || ival == -2"))))
+       (match_test "ival == -1 || ival == -2 || ival == -4")))
 
 (define_constraint "O"
   "Integer -1 or -2."
diff --git a/gcc/config/h8300/divmod.md b/gcc/config/h8300/divmod.md
new file mode 100644
index 00000000000..b5ab6b727bb
--- /dev/null
+++ b/gcc/config/h8300/divmod.md
@@ -0,0 +1,214 @@
+;; ----------------------------------------------------------------------
+;; DIVIDE/MOD INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn_and_split "udiv<mode>3"
+  [(set (match_operand:HSI 0 "register_operand" "=r")
+	(udiv:HSI (match_operand:HSI 1 "register_operand" "0")
+		  (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X")))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (udiv:HSI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "udiv<mode>3_clobber_flags"
+  [(set (match_operand:HSI 0 "register_operand" "=r")
+	(udiv:HSI (match_operand:HSI 1 "register_operand" "0")
+		  (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X")))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  { return <MODE>mode == HImode ? "divu.w\\t%T2,%T0" : "divu.l\\t%S2,%S0"; }
+  [(set_attr "length" "4")])
+
+(define_insn_and_split "div<mode>3"
+  [(set (match_operand:HSI 0 "register_operand" "=r")
+	(div:HSI (match_operand:HSI 1 "register_operand" "0")
+		 (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X")))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (div:HSI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "div<mode>3_clobber_flags"
+  [(set (match_operand:HSI 0 "register_operand" "=r")
+	(div:HSI (match_operand:HSI 1 "register_operand" "0")
+		 (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X")))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  { return <MODE>mode == HImode ? "divs.w\\t%T2,%T0" : "divs.l\\t%S2,%S0"; }
+  [(set_attr "length" "4")])
+
+(define_insn_and_split "udivmodqi4"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(truncate:QI
+	  (udiv:HI
+	    (match_operand:HI 1 "register_operand" "0")
+	    (zero_extend:HI (match_operand:QI 2 "register_operand" "r")))))
+   (set (match_operand:QI 3 "register_operand" "=r")
+	(truncate:QI
+	  (umod:HI
+	    (match_dup 1)
+	    (zero_extend:HI (match_dup 2)))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (truncate:QI
+				   (udiv:HI (match_dup 1)
+					    (zero_extend:HI (match_dup 2)))))
+	      (set (match_dup 3) (truncate:QI
+				   (umod:HI (match_dup 1)
+					    (zero_extend:HI (match_dup 2)))))
+	      (clobber (reg:CC CC_REG))])])
+							
+
+(define_insn "udivmodqi4_clobber_flags"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(truncate:QI
+	  (udiv:HI
+	    (match_operand:HI 1 "register_operand" "0")
+	    (zero_extend:HI (match_operand:QI 2 "register_operand" "r")))))
+   (set (match_operand:QI 3 "register_operand" "=r")
+	(truncate:QI
+	  (umod:HI
+	    (match_dup 1)
+	    (zero_extend:HI (match_dup 2)))))
+   (clobber (reg:CC CC_REG))]
+  ""
+{
+  if (find_reg_note (insn, REG_UNUSED, operands[3]))
+    return "divxu.b\\t%X2,%T0";
+  else
+    return "divxu.b\\t%X2,%T0\;mov.b\\t%t0,%s3";
+}
+  [(set_attr "length" "4")])
+
+(define_insn_and_split "divmodqi4"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(truncate:QI
+	  (div:HI
+	    (match_operand:HI 1 "register_operand" "0")
+	    (sign_extend:HI (match_operand:QI 2 "register_operand" "r")))))
+   (set (match_operand:QI 3 "register_operand" "=r")
+	(truncate:QI
+	  (mod:HI
+	    (match_dup 1)
+	    (sign_extend:HI (match_dup 2)))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (truncate:QI
+				   (div:HI (match_dup 1)
+					   (sign_extend:HI (match_dup 2)))))
+	      (set (match_dup 3) (truncate:QI
+				   (mod:HI (match_dup 1)
+					   (sign_extend:HI (match_dup 2)))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "divmodqi4_clobber_flags"
+  [(set (match_operand:QI 0 "register_operand" "=r")
+	(truncate:QI
+	  (div:HI
+	    (match_operand:HI 1 "register_operand" "0")
+	    (sign_extend:HI (match_operand:QI 2 "register_operand" "r")))))
+   (set (match_operand:QI 3 "register_operand" "=r")
+	(truncate:QI
+	  (mod:HI
+	    (match_dup 1)
+	    (sign_extend:HI (match_dup 2)))))
+   (clobber (reg:CC CC_REG))]
+  ""
+{
+  if (find_reg_note (insn, REG_UNUSED, operands[3]))
+    return "divxs.b\\t%X2,%T0";
+  else
+    return "divxs.b\\t%X2,%T0\;mov.b\\t%t0,%s3";
+}
+  [(set_attr "length" "6")])
+
+(define_insn_and_split "udivmodhi4"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(truncate:HI
+	  (udiv:SI
+	    (match_operand:SI 1 "register_operand" "0")
+	    (zero_extend:SI (match_operand:HI 2 "register_operand" "r")))))
+   (set (match_operand:HI 3 "register_operand" "=r")
+	(truncate:HI
+	  (umod:SI
+	    (match_dup 1)
+	    (zero_extend:SI (match_dup 2)))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (truncate:HI
+				   (udiv:SI (match_dup 1)
+					    (zero_extend:SI (match_dup 2)))))
+	      (set (match_dup 3) (truncate:HI
+				   (umod:SI (match_dup 1)
+					    (zero_extend:SI (match_dup 2)))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "udivmodhi4_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(truncate:HI
+	  (udiv:SI
+	    (match_operand:SI 1 "register_operand" "0")
+	    (zero_extend:SI (match_operand:HI 2 "register_operand" "r")))))
+   (set (match_operand:HI 3 "register_operand" "=r")
+	(truncate:HI
+	  (umod:SI
+	    (match_dup 1)
+	    (zero_extend:SI (match_dup 2)))))
+   (clobber (reg:CC CC_REG))]
+  ""
+{
+  if (find_reg_note (insn, REG_UNUSED, operands[3]))
+    return "divxu.w\\t%T2,%S0";
+  else
+    return "divxu.w\\t%T2,%S0\;mov.w\\t%e0,%f3";
+}
+  [(set_attr "length" "4")])
+
+(define_insn_and_split "divmodhi4"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(truncate:HI
+	  (div:SI
+	    (match_operand:SI 1 "register_operand" "0")
+	    (sign_extend:SI (match_operand:HI 2 "register_operand" "r")))))
+   (set (match_operand:HI 3 "register_operand" "=r")
+	(truncate:HI
+	  (mod:SI
+	    (match_dup 1)
+	    (sign_extend:SI (match_dup 2)))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (truncate:HI
+				   (div:SI (match_dup 1)
+					   (sign_extend:SI (match_dup 2)))))
+	      (set (match_dup 3) (truncate:HI
+				   (mod:SI (match_dup 1)
+					   (sign_extend:SI (match_dup 2)))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "divmodhi4_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(truncate:HI
+	  (div:SI
+	    (match_operand:SI 1 "register_operand" "0")
+	    (sign_extend:SI (match_operand:HI 2 "register_operand" "r")))))
+   (set (match_operand:HI 3 "register_operand" "=r")
+	(truncate:HI
+	  (mod:SI
+	    (match_dup 1)
+	    (sign_extend:SI (match_dup 2)))))
+   (clobber (reg:CC CC_REG))]
+  ""
+{
+  if (find_reg_note (insn, REG_UNUSED, operands[3]))
+    return "divxs.w\\t%T2,%S0";
+  else
+    return "divxs.w\\t%T2,%S0\;mov.w\\t%e0,%f3";
+}
+  [(set_attr "length" "6")])
diff --git a/gcc/config/h8300/elf.h b/gcc/config/h8300/elf.h
index ca32673d2a4..06844a590f1 100644
--- a/gcc/config/h8300/elf.h
+++ b/gcc/config/h8300/elf.h
@@ -39,6 +39,6 @@ along with GCC; see the file COPYING3.  If not see
 #define JUMP_TABLES_IN_TEXT_SECTION (flag_pic)
 
 #undef LINK_SPEC
-#define LINK_SPEC "%{mh:%{mn:-m h8300hnelf}} %{mh:%{!mn:-m h8300helf}} %{ms:%{mn:-m h8300snelf}} %{ms:%{!mn:-m h8300self}} %{msx:%{mn:-m h8300sxnelf;:-m h8300sxelf}}"
+#define LINK_SPEC "%{!ms:%{!msx:%{mn:-m h8300hnelf;:-m h8300helf}}} %{ms:%{mn:-m h8300snelf;:-m h8300self}} %{msx:%{mn:-m h8300sxnelf;:-m h8300sxelf}}"
 
 #endif /* h8300/elf.h */
diff --git a/gcc/config/h8300/extensions.md b/gcc/config/h8300/extensions.md
new file mode 100644
index 00000000000..6b69689cfd3
--- /dev/null
+++ b/gcc/config/h8300/extensions.md
@@ -0,0 +1,275 @@
+;; ----------------------------------------------------------------------
+;; EXTEND INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_expand "zero_extendqi<mode>2"
+  [(set (match_operand:HSI 0 "register_operand" "")
+	(zero_extend:HSI (match_operand:QI 1 "general_operand_src" "")))]
+  ""
+  {
+    if (TARGET_H8300SX)
+      operands[1] = force_reg (QImode, operands[1]);
+  })
+
+(define_insn_and_split "*zero_extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+	(zero_extend:HI (match_operand:QI 1 "general_operand_src" "0,g>")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (zero_extend:HI (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*zero_extendqihi2_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+	(zero_extend:HI (match_operand:QI 1 "general_operand_src" "0,g>")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "@
+  extu.w	%T0
+  #"
+  [(set_attr "length" "2,10")])
+
+(define_insn "*zero_extendqihi2_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (zero_extend:HI (match_operand:QI 1 "register_operand" "0>"))
+	  (const_int 0)))
+   (set (match_operand:HI 0 "register_operand" "=r")
+	(zero_extend:HI (match_dup 1)))]
+  ""
+  "extu.w	%T0"
+  [(set_attr "length" "2")])
+
+;; Split the zero extension of a general operand (actually a memory
+;; operand) into a load of the operand and the actual zero extension
+;; so that 1) the length will be accurate, and 2) the zero extensions
+;; appearing at the end of basic blocks may be merged.
+
+(define_split
+  [(set (match_operand:HI 0 "register_operand" "")
+	(zero_extend:HI (match_operand:QI 1 "general_operand_src" "")))
+   (clobber (reg:CC CC_REG))]
+  "reload_completed"
+  [(set (match_dup 2) (match_dup 1))
+   (parallel [(set (match_dup 0) (zero_extend:HI (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[2] = gen_rtx_REG (QImode, REGNO (operands[0]));
+  })
+
+(define_insn "*zero_extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(zero_extend:SI (match_operand:QI 1 "general_operand_src" "0,g>")))]
+  "!reload_completed && !TARGET_H8300SX"
+  "#")
+
+;; Two cases for the !H8/SX target.  One where there is an overlap
+;; between the source and destination, one where there is no overlap
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(zero_extend:SI (match_operand:QI 1 "general_operand_src" "")))]
+  "!TARGET_H8300SX
+    && reg_overlap_mentioned_p (operands[0], operands[1])
+    && reload_completed"
+  [(parallel [(set (match_dup 2) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 3) (zero_extend:HI (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0) (zero_extend:SI (match_dup 3)))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[2] = gen_lowpart (QImode, operands[0]);
+    operands[3] = gen_lowpart (HImode, operands[0]);
+  })
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand" "")
+	(zero_extend:SI (match_operand:QI 1 "general_operand_src" "")))]
+  "!TARGET_H8300SX
+    && !reg_overlap_mentioned_p (operands[0], operands[1])
+    && reload_completed"
+  [(parallel [(set (match_dup 0) (const_int 0))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (strict_low_part (match_dup 2)) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[2] = gen_rtx_REG (QImode, REGNO (operands[0]));
+  })
+
+(define_insn_and_split "*zero_extendqisi2_h8sx"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI (match_operand:QI 1 "register_operand" "0")))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (zero_extend:SI (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*zero_extendqisi2_h8sx_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI (match_operand:QI 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  "extu.l\t#2,%0"
+  [(set_attr "length" "2")])
+
+(define_insn "*zero_extendqisi2_h8sx_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (zero_extend:SI (match_operand:QI 1 "register_operand" "0"))
+	  (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI (match_dup 1)))]
+  "TARGET_H8300SX"
+  "extu.l\t#2,%0"
+  [(set_attr "length" "2")])
+
+(define_expand "zero_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(zero_extend:SI (match_operand:HI 1 "register_operand" "")))]
+  ""
+  "")
+
+(define_insn_and_split "*zero_extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI (match_operand:HI 1 "register_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (zero_extend:SI (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*zero_extendhisi2_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI (match_operand:HI 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "extu.l	%S0"
+  [(set_attr "length" "2")])
+
+(define_insn "*zero_extendhisi2_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (zero_extend:SI (match_operand:HI 1 "register_operand" "0"))
+	  (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r")
+	(zero_extend:SI (match_dup 1)))]
+  ""
+  "extu.l	%S0"
+  [(set_attr "length" "2")])
+
+(define_expand "extendqi<mode>2"
+  [(set (match_operand:HSI 0 "register_operand" "")
+	(sign_extend:HSI (match_operand:QI 1 "register_operand" "")))]
+  ""
+  "")
+
+(define_insn_and_split "*extendqihi2"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (sign_extend:HI (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*extendqihi2_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "exts.w	%T0"
+  [(set_attr "length" "2")])
+
+(define_insn "*extendqihi2_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (sign_extend:HI (match_operand:QI 1 "register_operand" "0"))
+	  (const_int 0)))
+   (set (match_operand:HI 0 "register_operand" "=r")
+	(sign_extend:HI (match_dup 1)))]
+  ""
+  "exts.w	%T0"
+  [(set_attr "length" "2")])
+
+;; The following pattern is needed because without the pattern, the
+;; combiner would split (sign_extend:SI (reg:QI)) into two 24-bit
+;; shifts, one ashift and one ashiftrt.
+
+(define_insn_and_split "*extendqisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (match_operand:QI 1 "register_operand" "0")))]
+  "!TARGET_H8300SX"
+  "#"
+  "&& reload_completed"
+  [(parallel [(set (match_dup 2) (sign_extend:HI (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])
+   (parallel [(set (match_dup 0) (sign_extend:SI (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])]
+  {
+    operands[2] = gen_rtx_REG (HImode, REGNO (operands[0]));
+  })
+
+(define_insn_and_split "*extendqisi2_h8sx"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (match_operand:QI 1 "register_operand" "0")))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (sign_extend:SI (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*extendqisi2_h8sx_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (match_operand:QI 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  "exts.l\t#2,%0"
+  [(set_attr "length" "2")])
+
+(define_insn "*extendqisi2_h8sx_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare
+	  (sign_extend:SI (match_operand:QI 1 "register_operand" "0"))
+	  (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (match_dup 1)))]
+  "TARGET_H8300SX"
+  "exts.l\t#2,%0"
+  [(set_attr "length" "2")])
+
+(define_expand "extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(sign_extend:SI (match_operand:HI 1 "register_operand" "")))]
+  ""
+  "")
+
+(define_insn_and_split "*extendhisi2"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (match_operand:HI 1 "register_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (sign_extend:SI (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*extendhisi2_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (match_operand:HI 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "exts.l	%S0"
+  [(set_attr "length" "2")])
+
+(define_insn "*extendhisi2_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (sign_extend:SI (match_operand:HI 1 "register_operand" "0"))
+	  (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r")
+	(sign_extend:SI (match_dup 1)))]
+  ""
+  "exts.l	%S0"
+  [(set_attr "length" "2")])
+
diff --git a/gcc/config/h8300/genmova.sh b/gcc/config/h8300/genmova.sh
index 22b01cc4e20..8ab018f70e1 100644
--- a/gcc/config/h8300/genmova.sh
+++ b/gcc/config/h8300/genmova.sh
@@ -71,8 +71,7 @@ for s in QI HI; do
 		 (match_operand:$d 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/b.l @(%o2%C2,$src),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 EOF
 	;;
@@ -115,8 +114,7 @@ EOF
 		 (match_operand:$d 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/$opsize.l @(%o2%C2,$src),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 EOF
 	    ;;
@@ -134,8 +132,7 @@ EOF
 		  (const_int $amount)))]
   "TARGET_H8300SX"
   "mova/$opsize.l @(0,$src),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:$d 0 "register_operand" "=r,r")
@@ -144,8 +141,7 @@ EOF
 		 (match_operand:$d 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/$opsize.l @(%o2%C2,$src),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 EOF
 
@@ -174,8 +170,7 @@ EOF
 		(const_int $mask)))]
   "TARGET_H8300SX"
   "mova/$opsize.l @(0,$src),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:$d 0 "register_operand" "=r")
@@ -185,8 +180,7 @@ EOF
 		 (match_operand:$d 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/$opsize.l @(%o2%C2,$src),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 EOF
 	      done
diff --git a/gcc/config/h8300/h8300-modes.def b/gcc/config/h8300/h8300-modes.def
new file mode 100644
index 00000000000..2f36c7ead8d
--- /dev/null
+++ b/gcc/config/h8300/h8300-modes.def
@@ -0,0 +1,21 @@
+/* Definitions of target machine for GNU compiler. 
+   Copyright (C) 2020 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+CC_MODE (CCZN);
+CC_MODE (CCZNV);
diff --git a/gcc/config/h8300/h8300-protos.h b/gcc/config/h8300/h8300-protos.h
index 2416741e76a..0d3eda0611e 100644
--- a/gcc/config/h8300/h8300-protos.h
+++ b/gcc/config/h8300/h8300-protos.h
@@ -26,8 +26,8 @@ along with GCC; see the file COPYING3.  If not see
 /* Declarations for functions used in insn-output.c.  */
 #ifdef RTX_CODE
 extern unsigned int compute_mov_length (rtx *);
-extern const char *output_plussi (rtx *);
-extern unsigned int compute_plussi_length (rtx *);
+extern const char *output_plussi (rtx *, bool);
+extern unsigned int compute_plussi_length (rtx *, bool);
 extern const char *output_a_shift (rtx *);
 extern unsigned int compute_a_shift_length (rtx, rtx *);
 extern const char *output_a_rotate (enum rtx_code, rtx *);
@@ -35,14 +35,16 @@ extern unsigned int compute_a_rotate_length (rtx *);
 extern const char *output_simode_bld (int, rtx[]);
 extern void final_prescan_insn (rtx_insn *, rtx *, int);
 extern int h8300_expand_movsi (rtx[]);
+extern machine_mode  h8300_select_cc_mode (RTX_CODE, rtx, rtx);
 extern void notice_update_cc (rtx, rtx_insn *);
 extern const char *output_logical_op (machine_mode, rtx *);
 extern unsigned int compute_logical_op_length (machine_mode,
 					       rtx *);
+
+extern int compute_logical_op_cc (machine_mode, rtx *);
+extern int compute_a_shift_cc (rtx, rtx *);
 #ifdef HAVE_ATTR_cc
 extern enum attr_cc compute_plussi_cc (rtx *);
-extern enum attr_cc compute_a_shift_cc (rtx, rtx *);
-extern enum attr_cc compute_logical_op_cc (machine_mode, rtx *);
 #endif
 extern void h8300_expand_branch (rtx[]);
 extern void h8300_expand_store (rtx[]);
diff --git a/gcc/config/h8300/h8300.c b/gcc/config/h8300/h8300.c
index d2fea04d8e4..ff20f3193e3 100644
--- a/gcc/config/h8300/h8300.c
+++ b/gcc/config/h8300/h8300.c
@@ -102,9 +102,6 @@ static tree h8300_handle_tiny_data_attribute (tree *, tree, tree, int, bool *);
 static void h8300_print_operand_address (FILE *, machine_mode, rtx);
 static void h8300_print_operand (FILE *, rtx, int);
 static bool h8300_print_operand_punct_valid_p (unsigned char code);
-#ifndef OBJECT_FORMAT_ELF
-static void h8300_asm_named_section (const char *, unsigned int, tree);
-#endif
 static int h8300_register_move_cost (machine_mode, reg_class_t, reg_class_t);
 static int h8300_and_costs (rtx);
 static int h8300_shift_costs (rtx);
@@ -135,13 +132,13 @@ static int pragma_interrupt;
 static int pragma_saveall;
 
 static const char *const names_big[] =
-{ "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7" };
+{ "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7", "cc" };
 
 static const char *const names_extended[] =
-{ "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7" };
+{ "er0", "er1", "er2", "er3", "er4", "er5", "er6", "er7", "cc" };
 
 static const char *const names_upper_extended[] =
-{ "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7" };
+{ "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "cc" };
 
 /* Points to one of the above.  */
 /* ??? The above could be put in an array indexed by CPU_TYPE.  */
@@ -182,14 +179,7 @@ enum shift_type
    QImode, HImode, and SImode, respectively.  Each table is organized
    by, in the order of indices, machine, shift type, and shift count.  */
 
-static enum shift_alg shift_alg_qi[3][3][8] = {
-  {
-    /* TARGET_H8300  */
-    /* 0    1    2    3    4    5    6    7  */
-    { INL, INL, INL, INL, INL, ROT, ROT, ROT }, /* SHIFT_ASHIFT   */
-    { INL, INL, INL, INL, INL, ROT, ROT, ROT }, /* SHIFT_LSHIFTRT */
-    { INL, INL, INL, INL, INL, LOP, LOP, SPC }  /* SHIFT_ASHIFTRT */
-  },
+static enum shift_alg shift_alg_qi[2][3][8] = {
   {
     /* TARGET_H8300H  */
     /* 0    1    2    3    4    5    6    7  */
@@ -206,18 +196,7 @@ static enum shift_alg shift_alg_qi[3][3][8] = {
   }
 };
 
-static enum shift_alg shift_alg_hi[3][3][16] = {
-  {
-    /* TARGET_H8300  */
-    /*  0    1    2    3    4    5    6    7  */
-    /*  8    9   10   11   12   13   14   15  */
-    { INL, INL, INL, INL, INL, INL, INL, SPC,
-      SPC, SPC, SPC, SPC, SPC, SPC, SPC, SPC }, /* SHIFT_ASHIFT   */
-    { INL, INL, INL, INL, INL, LOP, LOP, SPC,
-      SPC, SPC, SPC, SPC, SPC, SPC, SPC, SPC }, /* SHIFT_LSHIFTRT */
-    { INL, INL, INL, INL, INL, LOP, LOP, SPC,
-      SPC, SPC, SPC, SPC, SPC, SPC, SPC, SPC }, /* SHIFT_ASHIFTRT */
-  },
+static enum shift_alg shift_alg_hi[2][3][16] = {
   {
     /* TARGET_H8300H  */
     /*  0    1    2    3    4    5    6    7  */
@@ -242,26 +221,7 @@ static enum shift_alg shift_alg_hi[3][3][16] = {
   }
 };
 
-static enum shift_alg shift_alg_si[3][3][32] = {
-  {
-    /* TARGET_H8300  */
-    /*  0    1    2    3    4    5    6    7  */
-    /*  8    9   10   11   12   13   14   15  */
-    /* 16   17   18   19   20   21   22   23  */
-    /* 24   25   26   27   28   29   30   31  */
-    { INL, INL, INL, LOP, LOP, LOP, LOP, LOP,
-      SPC, LOP, LOP, LOP, LOP, LOP, LOP, LOP,
-      SPC, SPC, SPC, SPC, SPC, LOP, LOP, LOP,
-      SPC, SPC, SPC, SPC, LOP, LOP, LOP, SPC }, /* SHIFT_ASHIFT   */
-    { INL, INL, INL, LOP, LOP, LOP, LOP, LOP,
-      SPC, SPC, LOP, LOP, LOP, LOP, LOP, SPC,
-      SPC, SPC, SPC, LOP, LOP, LOP, LOP, LOP,
-      SPC, SPC, SPC, SPC, SPC, LOP, LOP, SPC }, /* SHIFT_LSHIFTRT */
-    { INL, INL, INL, LOP, LOP, LOP, LOP, LOP,
-      SPC, LOP, LOP, LOP, LOP, LOP, LOP, SPC,
-      SPC, SPC, LOP, LOP, LOP, LOP, LOP, LOP,
-      SPC, SPC, SPC, LOP, LOP, LOP, LOP, SPC }, /* SHIFT_ASHIFTRT */
-  },
+static enum shift_alg shift_alg_si[2][3][32] = {
   {
     /* TARGET_H8300H  */
     /*  0    1    2    3    4    5    6    7  */
@@ -309,7 +269,6 @@ static enum shift_alg shift_alg_si[3][3][32] = {
 
 enum h8_cpu
 {
-  H8_300,
   H8_300H,
   H8_S
 };
@@ -323,53 +282,29 @@ h8300_option_override (void)
   static const char *const h8_pop_ops[2]  = { "pop"  , "pop.l"  };
   static const char *const h8_mov_ops[2]  = { "mov.w", "mov.l"  };
 
-#ifndef OBJECT_FORMAT_ELF
-  if (TARGET_H8300SX)
-    {
-      error ("%<-msx%> is not supported in coff");
-      target_flags |= MASK_H8300S;
-    }
-#endif
-
-  if (TARGET_H8300)
-    {
-      cpu_type = (int) CPU_H8300;
-      h8_reg_names = names_big;
-    }
-  else
-    {
-      /* For this we treat the H8/300H and H8S the same.  */
-      cpu_type = (int) CPU_H8300H;
-      h8_reg_names = names_extended;
-    }
+  /* For this we treat the H8/300H and H8S the same.  */
+  cpu_type = (int) CPU_H8300H;
+  h8_reg_names = names_extended;
   h8_push_op = h8_push_ops[cpu_type];
   h8_pop_op = h8_pop_ops[cpu_type];
   h8_mov_op = h8_mov_ops[cpu_type];
 
+  /* If we're compiling for the H8/S, then turn off H8/300H.  */
+  if (TARGET_H8300S)
+    target_flags &= ~MASK_H8300H;
+
   if (!TARGET_H8300S && TARGET_MAC)
     {
       error ("%<-ms2600%> is used without %<-ms%>");
       target_flags |= MASK_H8300S_1;
     }
 
-  if (TARGET_H8300 && TARGET_NORMAL_MODE)
-    {
-      error ("%<-mn%> is used without %<-mh%> or %<-ms%> or %<-msx%>");
-      target_flags ^= MASK_NORMAL_MODE;
-    }
-
   if (! TARGET_H8300S &&  TARGET_EXR)
     {
       error ("%<-mexr%> is used without %<-ms%>");
       target_flags |= MASK_H8300S_1;
     }
 
-  if (TARGET_H8300 && TARGET_INT32)
-   {
-      error ("%<-mint32%> is not supported for H8300 and H8300L targets");
-      target_flags ^= MASK_INT32;
-   }
-
  if ((!TARGET_H8300S  &&  TARGET_EXR) && (!TARGET_H8300SX && TARGET_EXR))
    {
       error ("%<-mexr%> is used without %<-ms%> or %<-msx%>");
@@ -396,18 +331,6 @@ h8300_option_override (void)
      SHIFT_LOOP.  */
   if (optimize_size)
     {
-      /* H8/300 */
-      shift_alg_hi[H8_300][SHIFT_ASHIFT][5] = SHIFT_LOOP;
-      shift_alg_hi[H8_300][SHIFT_ASHIFT][6] = SHIFT_LOOP;
-      shift_alg_hi[H8_300][SHIFT_ASHIFT][13] = SHIFT_LOOP;
-      shift_alg_hi[H8_300][SHIFT_ASHIFT][14] = SHIFT_LOOP;
-
-      shift_alg_hi[H8_300][SHIFT_LSHIFTRT][13] = SHIFT_LOOP;
-      shift_alg_hi[H8_300][SHIFT_LSHIFTRT][14] = SHIFT_LOOP;
-
-      shift_alg_hi[H8_300][SHIFT_ASHIFTRT][13] = SHIFT_LOOP;
-      shift_alg_hi[H8_300][SHIFT_ASHIFTRT][14] = SHIFT_LOOP;
-
       /* H8/300H */
       shift_alg_hi[H8_300H][SHIFT_ASHIFT][5] = SHIFT_LOOP;
       shift_alg_hi[H8_300H][SHIFT_ASHIFT][6] = SHIFT_LOOP;
@@ -535,38 +458,22 @@ h8300_emit_stack_adjustment (int sign, HOST_WIDE_INT size, bool in_prologue)
   if (size == 0)
     return;
 
-  /* H8/300 cannot add/subtract a large constant with a single
-     instruction.  If a temporary register is available, load the
-     constant to it and then do the addition.  */
-  if (TARGET_H8300
-      && size > 4
-      && !h8300_current_function_interrupt_function_p ()
-      && !(cfun->static_chain_decl != NULL && sign < 0))
+  /* The stack adjustment made here is further optimized by the
+     splitter.  In case of H8/300, the splitter always splits the
+     addition emitted here to make the adjustment interrupt-safe.
+     FIXME: We don't always tag those, because we don't know what
+     the splitter will do.  */
+  if (Pmode == HImode)
     {
-      rtx r3 = gen_rtx_REG (Pmode, 3);
-      F (emit_insn (gen_movhi (r3, GEN_INT (sign * size))), in_prologue);
-      F (emit_insn (gen_addhi3 (stack_pointer_rtx,
-				stack_pointer_rtx, r3)), in_prologue);
+      rtx_insn *x = emit_insn (gen_addhi3 (stack_pointer_rtx,
+					   stack_pointer_rtx,
+					    GEN_INT (sign * size)));
+      if (size < 4)
+        F (x, 0);
     }
   else
-    {
-      /* The stack adjustment made here is further optimized by the
-	 splitter.  In case of H8/300, the splitter always splits the
-	 addition emitted here to make the adjustment interrupt-safe.
-	 FIXME: We don't always tag those, because we don't know what
-	 the splitter will do.  */
-      if (Pmode == HImode)
-	{
-	  rtx_insn *x = emit_insn (gen_addhi3 (stack_pointer_rtx,
-					       stack_pointer_rtx,
-					       GEN_INT (sign * size)));
-	  if (size < 4)
-	    F (x, in_prologue);
-	}
-      else
-	F (emit_insn (gen_addsi3 (stack_pointer_rtx,
-				  stack_pointer_rtx, GEN_INT (sign * size))), in_prologue);
-    }
+    F (emit_insn (gen_addsi3 (stack_pointer_rtx,
+			      stack_pointer_rtx, GEN_INT (sign * size))), 0);
 }
 
 /* Round up frame size SIZE.  */
@@ -609,13 +516,11 @@ push (int rn, bool in_prologue)
   rtx reg = gen_rtx_REG (word_mode, rn);
   rtx x;
 
-  if (TARGET_H8300)
-    x = gen_push_h8300 (reg);
-  else if (!TARGET_NORMAL_MODE)
+  if (!TARGET_NORMAL_MODE)
     x = gen_push_h8300hs_advanced (reg);
   else
     x = gen_push_h8300hs_normal (reg);
-  x = F (emit_insn (x), in_prologue);
+  x = F (emit_insn (x), 0);
   add_reg_note (x, REG_INC, stack_pointer_rtx);
   return x;
 }
@@ -628,9 +533,7 @@ pop (int rn)
   rtx reg = gen_rtx_REG (word_mode, rn);
   rtx x;
 
-  if (TARGET_H8300)
-    x = gen_pop_h8300 (reg);
-  else if (!TARGET_NORMAL_MODE)
+  if (!TARGET_NORMAL_MODE)
     x = gen_pop_h8300hs_advanced (reg);
   else
     x = gen_pop_h8300hs_normal (reg);
@@ -853,7 +756,7 @@ h8300_expand_prologue (void)
     {
       /* Push fp.  */
       push (HARD_FRAME_POINTER_REGNUM, true);
-      F (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx), true);
+      F (emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx), 0);
     }
 
   /* Push the rest of the registers in ascending order.  */
@@ -1049,9 +952,7 @@ split_adds_subs (machine_mode mode, rtx *operands)
     }
 
   /* Try different amounts in descending order.  */
-  for (amount = (TARGET_H8300H || TARGET_H8300S) ? 4 : 2;
-       amount > 0;
-       amount /= 2)
+  for (amount = 4; amount > 0; amount /= 2)
     {
       for (; val >= amount; val -= amount)
 	emit_insn (gen_add (reg, reg, GEN_INT (sign * amount)));
@@ -1273,10 +1174,7 @@ h8300_rtx_costs (rtx x, machine_mode mode ATTRIBUTE_UNUSED, int outer_code,
 		return true;
 	      case 4:
 	      case -4:
-		if (TARGET_H8300H || TARGET_H8300S)
-		  *total = 0 + (outer_code == SET);
-		else
-		  *total = 1;
+		*total = 0 + (outer_code == SET);
 		return true;
 	      }
 	  }
@@ -1565,10 +1463,7 @@ h8300_print_operand (FILE *file, rtx x, int code)
       switch (GET_CODE (x))
 	{
 	case REG:
-	  if (TARGET_H8300)
-	    fprintf (file, "%s", names_big[REGNO (x)]);
-	  else
-	    fprintf (file, "%s", names_upper_extended[REGNO (x)]);
+	  fprintf (file, "%s", names_upper_extended[REGNO (x)]);
 	  break;
 	case MEM:
 	  h8300_print_operand (file, x, 0);
@@ -1592,10 +1487,7 @@ h8300_print_operand (FILE *file, rtx x, int code)
       switch (GET_CODE (x))
 	{
 	case REG:
-	  if (TARGET_H8300)
-	    fprintf (file, "%s", names_big[REGNO (x) + 1]);
-	  else
-	    fprintf (file, "%s", names_big[REGNO (x)]);
+	  fprintf (file, "%s", names_big[REGNO (x)]);
 	  break;
 	case MEM:
 	  x = adjust_address (x, HImode, 2);
@@ -1616,10 +1508,20 @@ h8300_print_operand (FILE *file, rtx x, int code)
 	}
       break;
     case 'j':
-      fputs (cond_string (GET_CODE (x)), file);
+      if (GET_CODE (x) == LT && GET_MODE (XEXP (x, 0)) == E_CCZNmode)
+	fputs ("mi", file);
+      else if (GET_CODE (x) == GE && GET_MODE (XEXP (x, 0)) == E_CCZNmode)
+	fputs ("pl", file);
+      else
+        fputs (cond_string (GET_CODE (x)), file);
       break;
     case 'k':
-      fputs (cond_string (reverse_condition (GET_CODE (x))), file);
+      if (GET_CODE (x) == LT && GET_MODE (XEXP (x, 0)) == E_CCZNmode)
+	fputs ("pl", file);
+      else if (GET_CODE (x) == GE && GET_MODE (XEXP (x, 0)) == E_CCZNmode)
+	fputs ("mi", file);
+      else
+        fputs (cond_string (reverse_condition (GET_CODE (x))), file);
       break;
     case 'm':
       gcc_assert (GET_CODE (x) == CONST_INT);
@@ -1664,8 +1566,7 @@ h8300_print_operand (FILE *file, rtx x, int code)
       if (GET_CODE (x) == CONST_INT)
 	fprintf (file, "#%ld", INTVAL (x) & 0xff);
       else if (GET_CODE (x) == REG)
-	fprintf (file, "%s",
-		 byte_reg (x, TARGET_H8300 ? 2 : 0));
+	fprintf (file, "%s", byte_reg (x, 0));
       else
 	output_operand_lossage ("Expected register or constant integer.");
       break;
@@ -1673,8 +1574,7 @@ h8300_print_operand (FILE *file, rtx x, int code)
       if (GET_CODE (x) == CONST_INT)
 	fprintf (file, "#%ld", (INTVAL (x) >> 8) & 0xff);
       else if (GET_CODE (x) == REG)
-	fprintf (file, "%s",
-		 byte_reg (x, TARGET_H8300 ? 3 : 1));
+	fprintf (file, "%s", byte_reg (x, 1));
       else
 	output_operand_lossage ("Expected register or constant integer.");
       break;
@@ -1870,14 +1770,7 @@ h8300_print_operand_address (FILE *file, machine_mode mode, rtx addr)
 
     case CONST_INT:
       {
-	/* Since the H8/300 only has 16-bit pointers, negative values are also
-	   those >= 32768.  This happens for example with pointer minus a
-	   constant.  We don't want to turn (char *p - 2) into
-	   (char *p + 65534) because loop unrolling can build upon this
-	   (IE: char *p + 131068).  */
 	int n = INTVAL (addr);
-	if (TARGET_H8300)
-	  n = (int) (short) n;
 	fprintf (file, "%d", n);
 	break;
       }
@@ -2037,6 +1930,23 @@ h8300_return_addr_rtx (int count, rtx frame)
   return ret;
 }
 
+
+machine_mode
+h8300_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1)
+{
+  if (op1 == const0_rtx
+      && (cond == EQ || cond == NE || cond == LT || cond == GE)
+      && (GET_CODE (op0) == PLUS || GET_CODE (op0) == MINUS
+          || GET_CODE (op0) == NEG || GET_CODE (op0) == AND
+          || GET_CODE (op0) == IOR || GET_CODE (op0) == XOR
+          || GET_CODE (op0) == NOT || GET_CODE (op0) == ASHIFT
+	  || GET_CODE (op0) == REG || GET_CODE (op0) == MULT))
+    return CCZNmode;
+
+  return CCmode;
+}
+
+#if 0
 /* Update the condition code from the insn.  */
 
 void
@@ -2103,6 +2013,7 @@ notice_update_cc (rtx body, rtx_insn *insn)
       break;
     }
 }
+#endif
 
 /* Given that X occurs in an address of the form (plus X constant),
    return the part of X that is expected to be a register.  There are
@@ -2461,8 +2372,18 @@ static unsigned int
 h8300_binary_length (rtx_insn *insn, const h8300_length_table *table)
 {
   rtx set;
+  rtx pattern;
+
+  if (GET_CODE (insn) != INSN)
+    gcc_unreachable ();
 
-  set = single_set (insn);
+  pattern = PATTERN (insn);
+  if (GET_CODE (pattern) == PARALLEL
+      && GET_CODE (XVECEXP (pattern, 0, 0)) == SET
+      && GET_CODE (SET_SRC (XVECEXP (pattern, 0, 0))) == COMPARE)
+    set = XVECEXP (pattern, 0, 1);
+  else
+    set = single_set (insn);
   gcc_assert (set);
 
   if (BINARY_P (SET_SRC (set)))
@@ -2668,319 +2589,217 @@ compute_mov_length (rtx *operands)
   else
     addr = NULL_RTX;
 
-  if (TARGET_H8300)
-    {
-      unsigned int base_length;
+  unsigned int base_length;
 
-      switch (mode)
-	{
-	case E_QImode:
-	  if (addr == NULL_RTX)
-	    return 2;
+  switch (mode)
+    {
+    case E_QImode:
+      if (addr == NULL_RTX)
+	return 2;
 
-	  /* The eightbit addressing is available only in QImode, so
-	     go ahead and take care of it.  */
-	  if (h8300_eightbit_constant_address_p (addr))
-	    return 2;
+      /* The eightbit addressing is available only in QImode, so
+	 go ahead and take care of it.  */
+      if (h8300_eightbit_constant_address_p (addr))
+	return 2;
 
-	  base_length = 4;
+	  base_length = 8;
 	  break;
 
-	case E_HImode:
-	  if (addr == NULL_RTX)
-	    {
-	      if (REG_P (src))
-		return 2;
+    case E_HImode:
+      if (addr == NULL_RTX)
+	{
+	  if (REG_P (src))
+	    return 2;
 
-	      if (src == const0_rtx)
-		return 2;
+	  if (src == const0_rtx)
+	    return 2;
 
-	      return 4;
-	    }
+	  return 4;
+	}
 
-	  base_length = 4;
-	  break;
+      base_length = 8;
+	break;
 
-	case E_SImode:
-	  if (addr == NULL_RTX)
+    case E_SImode:
+      if (addr == NULL_RTX)
+	{
+	  if (REG_P (src))
 	    {
-	      if (REG_P (src))
+	      if (REGNO (src) == MAC_REG || REGNO (dest) == MAC_REG)
 		return 4;
-
-	      if (GET_CODE (src) == CONST_INT)
-		{
-		  if (src == const0_rtx)
-		    return 4;
-
-		  if ((INTVAL (src) & 0xffff) == 0)
-		    return 6;
-
-		  if ((INTVAL (src) & 0xffff) == 0)
-		    return 6;
-
-		  if ((INTVAL (src) & 0xffff)
-		      == ((INTVAL (src) >> 16) & 0xffff))
-		    return 6;
-		}
-	      return 8;
+	      else
+		return 2;
 	    }
 
-	  base_length = 8;
-	  break;
-
-	case E_SFmode:
-	  if (addr == NULL_RTX)
+	  if (GET_CODE (src) == CONST_INT)
 	    {
-	      if (REG_P (src))
-		return 4;
+	      int val = INTVAL (src);
 
-	      if (satisfies_constraint_G (src))
+	      if (val == 0)
+		return 2;
+
+	      if (val == (val & 0x00ff) || val == (val & 0xff00))
 		return 4;
 
-	      return 8;
+	      switch (val & 0xffffffff)
+		{
+		case 0xffffffff:
+		case 0xfffffffe:
+		case 0xfffffffc:
+		case 0x0000ffff:
+		case 0x0000fffe:
+		case 0xffff0000:
+		case 0xfffe0000:
+		case 0x00010000:
+		case 0x00020000:
+		  return 4;
+		}
 	    }
-
-	  base_length = 8;
-	  break;
-
-	default:
-	  gcc_unreachable ();
+	  return 6;
 	}
 
-      /* Adjust the length based on the addressing mode used.
-	 Specifically, we subtract the difference between the actual
-	 length and the longest one, which is @(d:16,Rs).  For SImode
-	 and SFmode, we double the adjustment because two mov.w are
-	 used to do the job.  */
-
-      /* @Rs+ and @-Rd are 2 bytes shorter than the longest.  */
-      if (GET_CODE (addr) == PRE_DEC
-	  || GET_CODE (addr) == POST_INC)
-	{
-	  if (mode == QImode || mode == HImode)
-	    return base_length - 2;
-	  else
-	    /* In SImode and SFmode, we use two mov.w instructions, so
-	       double the adjustment.  */
-	    return base_length - 4;
-	}
-
-      /* @Rs and @Rd are 2 bytes shorter than the longest.  Note that
-	 in SImode and SFmode, the second mov.w involves an address
-	 with displacement, namely @(2,Rs) or @(2,Rd), so we subtract
-	 only 2 bytes.  */
-      if (GET_CODE (addr) == REG)
-	return base_length - 2;
-
-      return base_length;
-    }
-  else
-    {
-      unsigned int base_length;
+      base_length = 10;
+      break;
 
-      switch (mode)
+    case E_SFmode:
+      if (addr == NULL_RTX)
 	{
-	case E_QImode:
-	  if (addr == NULL_RTX)
-	    return 2;
+	  if (REG_P (src))
+   	    return 2;
 
-	  /* The eightbit addressing is available only in QImode, so
-	     go ahead and take care of it.  */
-	  if (h8300_eightbit_constant_address_p (addr))
+	  if (satisfies_constraint_G (src))
 	    return 2;
 
-	  base_length = 8;
-	  break;
-
-	case E_HImode:
-	  if (addr == NULL_RTX)
-	    {
-	      if (REG_P (src))
-		return 2;
-
-	      if (src == const0_rtx)
-		return 2;
-
-	      return 4;
-	    }
-
-	  base_length = 8;
-	  break;
-
-	case E_SImode:
-	  if (addr == NULL_RTX)
-	    {
-	      if (REG_P (src))
-		{
-		  if (REGNO (src) == MAC_REG || REGNO (dest) == MAC_REG)
-		    return 4;
-		  else
-		    return 2;
-		}
-
-	      if (GET_CODE (src) == CONST_INT)
-		{
-		  int val = INTVAL (src);
+	  return 6;
+	}
 
-		  if (val == 0)
-		    return 2;
+      base_length = 10;
+	break;
 
-		  if (val == (val & 0x00ff) || val == (val & 0xff00))
-		    return 4;
+    default:
+      gcc_unreachable ();
+    }
 
-		  switch (val & 0xffffffff)
-		    {
-		    case 0xffffffff:
-		    case 0xfffffffe:
-		    case 0xfffffffc:
-		    case 0x0000ffff:
-		    case 0x0000fffe:
-		    case 0xffff0000:
-		    case 0xfffe0000:
-		    case 0x00010000:
-		    case 0x00020000:
-		      return 4;
-		    }
-		}
-	      return 6;
-	    }
+  /* Adjust the length based on the addressing mode used.
+     Specifically, we subtract the difference between the actual
+     length and the longest one, which is @(d:24,ERs).  */
 
-	  base_length = 10;
-	  break;
+  /* @ERs+ and @-ERd are 6 bytes shorter than the longest.  */
+  if (GET_CODE (addr) == PRE_DEC
+      || GET_CODE (addr) == POST_INC)
+    return base_length - 6;
 
-	case E_SFmode:
-	  if (addr == NULL_RTX)
-	    {
-	      if (REG_P (src))
-		return 2;
+  /* @ERs and @ERd are 6 bytes shorter than the longest.  */
+  if (GET_CODE (addr) == REG)
+    return base_length - 6;
 
-	      if (satisfies_constraint_G (src))
-		return 2;
+  /* @(d:16,ERs) and @(d:16,ERd) are 4 bytes shorter than the
+     longest.  */
+  if (GET_CODE (addr) == PLUS
+      && GET_CODE (XEXP (addr, 0)) == REG
+      && GET_CODE (XEXP (addr, 1)) == CONST_INT
+      && INTVAL (XEXP (addr, 1)) > -32768
+      && INTVAL (XEXP (addr, 1)) < 32767)
+    return base_length - 4;
 
-	      return 6;
-	    }
+  /* @aa:16 is 4 bytes shorter than the longest.  */
+  if (h8300_tiny_constant_address_p (addr))
+    return base_length - 4;
 
-	  base_length = 10;
-	  break;
+  /* @aa:24 is 2 bytes shorter than the longest.  */
+  if (CONSTANT_P (addr))
+    return base_length - 2;
 
-	default:
-	  gcc_unreachable ();
-	}
-
-      /* Adjust the length based on the addressing mode used.
-	 Specifically, we subtract the difference between the actual
-	 length and the longest one, which is @(d:24,ERs).  */
-
-      /* @ERs+ and @-ERd are 6 bytes shorter than the longest.  */
-      if (GET_CODE (addr) == PRE_DEC
-	  || GET_CODE (addr) == POST_INC)
-	return base_length - 6;
-
-      /* @ERs and @ERd are 6 bytes shorter than the longest.  */
-      if (GET_CODE (addr) == REG)
-	return base_length - 6;
-
-      /* @(d:16,ERs) and @(d:16,ERd) are 4 bytes shorter than the
-	 longest.  */
-      if (GET_CODE (addr) == PLUS
-	  && GET_CODE (XEXP (addr, 0)) == REG
-	  && GET_CODE (XEXP (addr, 1)) == CONST_INT
-	  && INTVAL (XEXP (addr, 1)) > -32768
-	  && INTVAL (XEXP (addr, 1)) < 32767)
-	return base_length - 4;
-
-      /* @aa:16 is 4 bytes shorter than the longest.  */
-      if (h8300_tiny_constant_address_p (addr))
-	return base_length - 4;
-
-      /* @aa:24 is 2 bytes shorter than the longest.  */
-      if (CONSTANT_P (addr))
-	return base_length - 2;
-
-      return base_length;
-    }
+  return base_length;
 }
 
 /* Output an addition insn.  */
 
 const char *
-output_plussi (rtx *operands)
+output_plussi (rtx *operands, bool need_flags)
 {
   machine_mode mode = GET_MODE (operands[0]);
 
   gcc_assert (mode == SImode);
 
-  if (TARGET_H8300)
+  if (GET_CODE (operands[2]) == CONST_INT
+      && register_operand (operands[1], VOIDmode))
     {
-      if (GET_CODE (operands[2]) == REG)
-	return "add.w\t%f2,%f0\n\taddx\t%y2,%y0\n\taddx\t%z2,%z0";
+      HOST_WIDE_INT intval = INTVAL (operands[2]);
 
-      if (GET_CODE (operands[2]) == CONST_INT)
-	{
-	  HOST_WIDE_INT n = INTVAL (operands[2]);
-
-	  if ((n & 0xffffff) == 0)
-	    return "add\t%z2,%z0";
-	  if ((n & 0xffff) == 0)
-	    return "add\t%y2,%y0\n\taddx\t%z2,%z0";
-	  if ((n & 0xff) == 0)
-	    return "add\t%x2,%x0\n\taddx\t%y2,%y0\n\taddx\t%z2,%z0";
-	}
+      if (TARGET_H8300SX && (intval >= 1 && intval <= 7))
+	return "add.l\t%S2,%S0";
+      if (TARGET_H8300SX && (intval >= -7 && intval <= -1))
+	return "sub.l\t%G2,%S0";
 
-      return "add\t%w2,%w0\n\taddx\t%x2,%x0\n\taddx\t%y2,%y0\n\taddx\t%z2,%z0";
-    }
-  else
-    {
-      if (GET_CODE (operands[2]) == CONST_INT
-	  && register_operand (operands[1], VOIDmode))
+      /* See if we can finish with 2 bytes.  */
+
+      switch ((unsigned int) intval & 0xffffffff)
 	{
-	  HOST_WIDE_INT intval = INTVAL (operands[2]);
+	/* INC/DEC set the flags, but adds/subs do not.  So if we
+	   need flags, use the former and not the latter.  */
+	case 0x00000001:
+	  if (need_flags)
+	    return "inc.l\t#1,%S0";
+	  else
+	    return "adds\t%2,%S0";
+	case 0x00000002:
+	  if (need_flags)
+	    return "inc.l\t#2,%S0";
+	  else
+	    return "adds\t%2,%S0";
+	case 0xffffffff:
+	  if (need_flags)
+	    return "dec.l\t#1,%S0";
+	  else
+	    return "subs\t%G2,%S0";
+	case 0xfffffffe:
+	  if (need_flags)
+	    return "dec.l\t#2,%S0";
+	  else
+	    return "subs\t%G2,%S0";
 
-	  if (TARGET_H8300SX && (intval >= 1 && intval <= 7))
-	    return "add.l\t%S2,%S0";
-	  if (TARGET_H8300SX && (intval >= -7 && intval <= -1))
-	    return "sub.l\t%G2,%S0";
+	/* These six cases have optimized paths when we do not
+	   need flags.  Otherwise we let them fallthru.  */
+	case 0x00000004:
+	  if (!need_flags)
+	    return "adds\t%2,%S0";
 
-	  /* See if we can finish with 2 bytes.  */
+	case 0xfffffffc:
+	  if (!need_flags)
+	    return "subs\t%G2,%S0";
 
-	  switch ((unsigned int) intval & 0xffffffff)
+	case 0x00010000:
+	case 0x00020000:
+	  if (!need_flags)
 	    {
-	    case 0x00000001:
-	    case 0x00000002:
-	    case 0x00000004:
-	      return "adds\t%2,%S0";
-
-	    case 0xffffffff:
-	    case 0xfffffffe:
-	    case 0xfffffffc:
-	      return "subs\t%G2,%S0";
-
-	    case 0x00010000:
-	    case 0x00020000:
 	      operands[2] = GEN_INT (intval >> 16);
 	      return "inc.w\t%2,%e0";
-
-	    case 0xffff0000:
-	    case 0xfffe0000:
-	      operands[2] = GEN_INT (intval >> 16);
-	      return "dec.w\t%G2,%e0";
 	    }
 
-	  /* See if we can finish with 4 bytes.  */
-	  if ((intval & 0xffff) == 0)
+	case 0xffff0000:
+	case 0xfffe0000:
+	  if (!need_flags)
 	    {
 	      operands[2] = GEN_INT (intval >> 16);
-	      return "add.w\t%2,%e0";
+	      return "dec.w\t%G2,%e0";
 	    }
 	}
 
-      if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)
+      /* See if we can finish with 4 bytes.  */
+      if ((intval & 0xffff) == 0)
 	{
-	  operands[2] = GEN_INT (-INTVAL (operands[2]));
-	  return "sub.l\t%S2,%S0";
+	  operands[2] = GEN_INT (intval >> 16);
+	  return "add.w\t%2,%e0";
 	}
-      return "add.l\t%S2,%S0";
     }
+
+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)
+    {
+      operands[2] = GEN_INT (-INTVAL (operands[2]));
+      return "sub.l\t%S2,%S0";
+    }
+  return "add.l\t%S2,%S0";
 }
 
 /* ??? It would be much easier to add the h8sx stuff if a single function
@@ -2988,80 +2807,67 @@ output_plussi (rtx *operands)
 /* Compute the length of an addition insn.  */
 
 unsigned int
-compute_plussi_length (rtx *operands)
+compute_plussi_length (rtx *operands, bool need_flags)
 {
   machine_mode mode = GET_MODE (operands[0]);
 
   gcc_assert (mode == SImode);
 
-  if (TARGET_H8300)
+  if (GET_CODE (operands[2]) == CONST_INT
+      && register_operand (operands[1], VOIDmode))
     {
-      if (GET_CODE (operands[2]) == REG)
-	return 6;
+      HOST_WIDE_INT intval = INTVAL (operands[2]);
 
-      if (GET_CODE (operands[2]) == CONST_INT)
-	{
-	  HOST_WIDE_INT n = INTVAL (operands[2]);
+      if (TARGET_H8300SX && (intval >= 1 && intval <= 7))
+	return 2;
+      if (TARGET_H8300SX && (intval >= -7 && intval <= -1))
+	return 2;
 
-	  if ((n & 0xffffff) == 0)
-	    return 2;
-	  if ((n & 0xffff) == 0)
-	    return 4;
-	  if ((n & 0xff) == 0)
-	    return 6;
-	}
+      /* See if we can finish with 2 bytes.  */
 
-      return 8;
-    }
-  else
-    {
-      if (GET_CODE (operands[2]) == CONST_INT
-	  && register_operand (operands[1], VOIDmode))
+      switch ((unsigned int) intval & 0xffffffff)
 	{
-	  HOST_WIDE_INT intval = INTVAL (operands[2]);
-
-	  if (TARGET_H8300SX && (intval >= 1 && intval <= 7))
-	    return 2;
-	  if (TARGET_H8300SX && (intval >= -7 && intval <= -1))
+	case 0x00000001:
+	case 0x00000002:
+	  return 2;
+	case 0x00000004:
+	  if (need_flags)
+	    return 6;
+	  else
 	    return 2;
 
-	  /* See if we can finish with 2 bytes.  */
+	case 0xffffffff:
+	case 0xfffffffe:
+	  return 2;
+	case 0xfffffffc:
+	  if (need_flags)
+	    return 6;
+	  else
+	    return 2;
 
-	  switch ((unsigned int) intval & 0xffffffff)
-	    {
-	    case 0x00000001:
-	    case 0x00000002:
-	    case 0x00000004:
-	      return 2;
-
-	    case 0xffffffff:
-	    case 0xfffffffe:
-	    case 0xfffffffc:
-	      return 2;
-
-	    case 0x00010000:
-	    case 0x00020000:
-	      return 2;
-
-	    case 0xffff0000:
-	    case 0xfffe0000:
-	      return 2;
-	    }
+	case 0x00010000:
+	case 0x00020000:
+	  if (!need_flags)
+	    return 2;
 
-	  /* See if we can finish with 4 bytes.  */
-	  if ((intval & 0xffff) == 0)
-	    return 4;
+	case 0xffff0000:
+	case 0xfffe0000:
+	  if (!need_flags)
+	    return 2;
 	}
 
-      if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)
-	return h8300_length_from_table (operands[0],
-					GEN_INT (-INTVAL (operands[2])),
-					&addl_length_table);
-      else
-	return h8300_length_from_table (operands[0], operands[2],
-					&addl_length_table);
-      return 6;
+      /* See if we can finish with 4 bytes.  */
+      if ((intval & 0xffff) == 0)
+	return 4;
     }
+
+  if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 0)
+    return h8300_length_from_table (operands[0],
+				    GEN_INT (-INTVAL (operands[2])),
+				    &addl_length_table);
+  else
+    return h8300_length_from_table (operands[0], operands[2],
+				    &addl_length_table);
 }
 
 /* Compute which flag bits are valid after an addition insn.  */
@@ -3073,52 +2879,45 @@ compute_plussi_cc (rtx *operands)
 
   gcc_assert (mode == SImode);
 
-  if (TARGET_H8300)
-    {
-      return CC_CLOBBER;
-    }
-  else
+  if (GET_CODE (operands[2]) == CONST_INT
+      && register_operand (operands[1], VOIDmode))
     {
-      if (GET_CODE (operands[2]) == CONST_INT
-	  && register_operand (operands[1], VOIDmode))
-	{
-	  HOST_WIDE_INT intval = INTVAL (operands[2]);
+      HOST_WIDE_INT intval = INTVAL (operands[2]);
 
-	  if (TARGET_H8300SX && (intval >= 1 && intval <= 7))
-	    return CC_SET_ZN;
-	  if (TARGET_H8300SX && (intval >= -7 && intval <= -1))
-	    return CC_SET_ZN;
+      if (TARGET_H8300SX && (intval >= 1 && intval <= 7))
+	return CC_SET_ZN;
+      if (TARGET_H8300SX && (intval >= -7 && intval <= -1))
+	return CC_SET_ZN;
 
-	  /* See if we can finish with 2 bytes.  */
+      /* See if we can finish with 2 bytes.  */
 
-	  switch ((unsigned int) intval & 0xffffffff)
-	    {
-	    case 0x00000001:
-	    case 0x00000002:
-	    case 0x00000004:
-	      return CC_NONE_0HIT;
-
-	    case 0xffffffff:
-	    case 0xfffffffe:
-	    case 0xfffffffc:
-	      return CC_NONE_0HIT;
-
-	    case 0x00010000:
-	    case 0x00020000:
-	      return CC_CLOBBER;
-
-	    case 0xffff0000:
-	    case 0xfffe0000:
-	      return CC_CLOBBER;
-	    }
-
-	  /* See if we can finish with 4 bytes.  */
-	  if ((intval & 0xffff) == 0)
-	    return CC_CLOBBER;
+      switch ((unsigned int) intval & 0xffffffff)
+	{
+	case 0x00000001:
+	case 0x00000002:
+	case 0x00000004:
+	  return CC_NONE_0HIT;
+
+	case 0xffffffff:
+	case 0xfffffffe:
+	case 0xfffffffc:
+	  return CC_NONE_0HIT;
+
+	case 0x00010000:
+	case 0x00020000:
+	  return CC_CLOBBER;
+
+	case 0xffff0000:
+	case 0xfffe0000:
+	  return CC_CLOBBER;
 	}
 
-      return CC_SET_ZN;
+      /* See if we can finish with 4 bytes.  */
+      if ((intval & 0xffff) == 0)
+	return CC_CLOBBER;
     }
+
+  return CC_SET_ZN;
 }
 
 /* Output a logical insn.  */
@@ -3143,8 +2942,6 @@ output_logical_op (machine_mode mode, rtx *operands)
   /* Break up DET into pieces.  */
   const unsigned HOST_WIDE_INT b0 = (det >>  0) & 0xff;
   const unsigned HOST_WIDE_INT b1 = (det >>  8) & 0xff;
-  const unsigned HOST_WIDE_INT b2 = (det >> 16) & 0xff;
-  const unsigned HOST_WIDE_INT b3 = (det >> 24) & 0xff;
   const unsigned HOST_WIDE_INT w0 = (det >>  0) & 0xffff;
   const unsigned HOST_WIDE_INT w1 = (det >> 16) & 0xffff;
   int lower_half_easy_p = 0;
@@ -3172,9 +2969,7 @@ output_logical_op (machine_mode mode, rtx *operands)
     {
     case E_HImode:
       /* First, see if we can finish with one insn.  */
-      if ((TARGET_H8300H || TARGET_H8300S)
-	  && b0 != 0
-	  && b1 != 0)
+      if (b0 != 0 && b1 != 0)
 	{
 	  sprintf (insn_buf, "%s.w\t%%T2,%%T0", opname);
 	  output_asm_insn (insn_buf, operands);
@@ -3196,24 +2991,20 @@ output_logical_op (machine_mode mode, rtx *operands)
 	}
       break;
     case E_SImode:
-      if (TARGET_H8300H || TARGET_H8300S)
-	{
-	  /* Determine if the lower half can be taken care of in no more
-	     than two bytes.  */
-	  lower_half_easy_p = (b0 == 0
-			       || b1 == 0
-			       || (code != IOR && w0 == 0xffff));
-
-	  /* Determine if the upper half can be taken care of in no more
-	     than two bytes.  */
-	  upper_half_easy_p = ((code != IOR && w1 == 0xffff)
-			       || (code == AND && w1 == 0xff00));
-	}
+      /* Determine if the lower half can be taken care of in no more
+	 than two bytes.  */
+      lower_half_easy_p = (b0 == 0
+			   || b1 == 0
+			   || (code != IOR && w0 == 0xffff));
+
+       /* Determine if the upper half can be taken care of in no more
+	  than two bytes.  */
+      upper_half_easy_p = ((code != IOR && w1 == 0xffff)
+			   || (code == AND && w1 == 0xff00));
 
       /* Check if doing everything with one insn is no worse than
 	 using multiple insns.  */
-      if ((TARGET_H8300H || TARGET_H8300S)
-	  && w0 != 0 && w1 != 0
+      if (w0 != 0 && w1 != 0
 	  && !(lower_half_easy_p && upper_half_easy_p)
 	  && !(code == IOR && w1 == 0xffff
 	       && (w0 & 0x8000) != 0 && lower_half_easy_p))
@@ -3229,14 +3020,11 @@ output_logical_op (machine_mode mode, rtx *operands)
 	     1) the special insn (in case of AND or XOR),
 	     2) the word-wise insn, and
 	     3) The byte-wise insn.  */
-	  if (w0 == 0xffff
-	      && (TARGET_H8300 ? (code == AND) : (code != IOR)))
+	  if (w0 == 0xffff && (code != IOR))
 	    output_asm_insn ((code == AND)
 			     ? "sub.w\t%f0,%f0" : "not.w\t%f0",
 			     operands);
-	  else if ((TARGET_H8300H || TARGET_H8300S)
-		   && (b0 != 0)
-		   && (b1 != 0))
+	  else if ((b0 != 0) && (b1 != 0))
 	    {
 	      sprintf (insn_buf, "%s.w\t%%f2,%%f0", opname);
 	      output_asm_insn (insn_buf, operands);
@@ -3255,25 +3043,22 @@ output_logical_op (machine_mode mode, rtx *operands)
 		}
 	    }
 
-	  if ((w1 == 0xffff)
-	      && (TARGET_H8300 ? (code == AND) : (code != IOR)))
+	  if ((w1 == 0xffff) && (code != IOR))
 	    output_asm_insn ((code == AND)
 			     ? "sub.w\t%e0,%e0" : "not.w\t%e0",
 			     operands);
-	  else if ((TARGET_H8300H || TARGET_H8300S)
-		   && code == IOR
+	  else if (code == IOR
 		   && w1 == 0xffff
 		   && (w0 & 0x8000) != 0)
 	    {
 	      output_asm_insn ("exts.l\t%S0", operands);
 	    }
-	  else if ((TARGET_H8300H || TARGET_H8300S)
-		   && code == AND
+	  else if (code == AND
 		   && w1 == 0xff00)
 	    {
 	      output_asm_insn ("extu.w\t%e0", operands);
 	    }
-	  else if (TARGET_H8300H || TARGET_H8300S)
+	  else
 	    {
 	      if (w1 != 0)
 		{
@@ -3281,19 +3066,6 @@ output_logical_op (machine_mode mode, rtx *operands)
 		  output_asm_insn (insn_buf, operands);
 		}
 	    }
-	  else
-	    {
-	      if (b2 != 0)
-		{
-		  sprintf (insn_buf, "%s\t%%y2,%%y0", opname);
-		  output_asm_insn (insn_buf, operands);
-		}
-	      if (b3 != 0)
-		{
-		  sprintf (insn_buf, "%s\t%%z2,%%z0", opname);
-		  output_asm_insn (insn_buf, operands);
-		}
-	    }
 	}
       break;
     default:
@@ -3324,8 +3096,6 @@ compute_logical_op_length (machine_mode mode, rtx *operands)
   /* Break up DET into pieces.  */
   const unsigned HOST_WIDE_INT b0 = (det >>  0) & 0xff;
   const unsigned HOST_WIDE_INT b1 = (det >>  8) & 0xff;
-  const unsigned HOST_WIDE_INT b2 = (det >> 16) & 0xff;
-  const unsigned HOST_WIDE_INT b3 = (det >> 24) & 0xff;
   const unsigned HOST_WIDE_INT w0 = (det >>  0) & 0xffff;
   const unsigned HOST_WIDE_INT w1 = (det >> 16) & 0xffff;
   int lower_half_easy_p = 0;
@@ -3337,9 +3107,7 @@ compute_logical_op_length (machine_mode mode, rtx *operands)
     {
     case E_HImode:
       /* First, see if we can finish with one insn.  */
-      if ((TARGET_H8300H || TARGET_H8300S)
-	  && b0 != 0
-	  && b1 != 0)
+      if (b0 != 0 && b1 != 0)
 	{
 	  length = h8300_length_from_table (operands[1], operands[2],
 					    &logicw_length_table);
@@ -3356,24 +3124,20 @@ compute_logical_op_length (machine_mode mode, rtx *operands)
 	}
       break;
     case E_SImode:
-      if (TARGET_H8300H || TARGET_H8300S)
-	{
-	  /* Determine if the lower half can be taken care of in no more
-	     than two bytes.  */
-	  lower_half_easy_p = (b0 == 0
-			       || b1 == 0
-			       || (code != IOR && w0 == 0xffff));
-
-	  /* Determine if the upper half can be taken care of in no more
-	     than two bytes.  */
-	  upper_half_easy_p = ((code != IOR && w1 == 0xffff)
-			       || (code == AND && w1 == 0xff00));
-	}
+      /* Determine if the lower half can be taken care of in no more
+	 than two bytes.  */
+      lower_half_easy_p = (b0 == 0
+			   || b1 == 0
+			   || (code != IOR && w0 == 0xffff));
+
+      /* Determine if the upper half can be taken care of in no more
+	 than two bytes.  */
+      upper_half_easy_p = ((code != IOR && w1 == 0xffff)
+			   || (code == AND && w1 == 0xff00));
 
       /* Check if doing everything with one insn is no worse than
 	 using multiple insns.  */
-      if ((TARGET_H8300H || TARGET_H8300S)
-	  && w0 != 0 && w1 != 0
+      if (w0 != 0 && w1 != 0
 	  && !(lower_half_easy_p && upper_half_easy_p)
 	  && !(code == IOR && w1 == 0xffff
 	       && (w0 & 0x8000) != 0 && lower_half_easy_p))
@@ -3389,14 +3153,11 @@ compute_logical_op_length (machine_mode mode, rtx *operands)
 	     1) the special insn (in case of AND or XOR),
 	     2) the word-wise insn, and
 	     3) The byte-wise insn.  */
-	  if (w0 == 0xffff
-	      && (TARGET_H8300 ? (code == AND) : (code != IOR)))
+	  if (w0 == 0xffff && (code != IOR))
 	    {
 	      length += 2;
 	    }
-	  else if ((TARGET_H8300H || TARGET_H8300S)
-		   && (b0 != 0)
-		   && (b1 != 0))
+	  else if ((b0 != 0) && (b1 != 0))
 	    {
 	      length += 4;
 	    }
@@ -3409,37 +3170,25 @@ compute_logical_op_length (machine_mode mode, rtx *operands)
 		length += 2;
 	    }
 
-	  if (w1 == 0xffff
-	      && (TARGET_H8300 ? (code == AND) : (code != IOR)))
+	  if (w1 == 0xffff && (code != IOR))
 	    {
 	      length += 2;
 	    }
-	  else if ((TARGET_H8300H || TARGET_H8300S)
-		   && code == IOR
+	  else if (code == IOR
 		   && w1 == 0xffff
 		   && (w0 & 0x8000) != 0)
 	    {
 	      length += 2;
 	    }
-	  else if ((TARGET_H8300H || TARGET_H8300S)
-		   && code == AND
-		   && w1 == 0xff00)
+	  else if (code == AND && w1 == 0xff00)
 	    {
 	      length += 2;
 	    }
-	  else if (TARGET_H8300H || TARGET_H8300S)
+	  else
 	    {
 	      if (w1 != 0)
 		length += 4;
 	    }
-	  else
-	    {
-	      if (b2 != 0)
-		length += 2;
-
-	      if (b3 != 0)
-		length += 2;
-	    }
 	}
       break;
     default:
@@ -3450,7 +3199,7 @@ compute_logical_op_length (machine_mode mode, rtx *operands)
 
 /* Compute which flag bits are valid after a logical insn.  */
 
-enum attr_cc
+int
 compute_logical_op_cc (machine_mode mode, rtx *operands)
 {
   /* Figure out the logical op that we need to perform.  */
@@ -3481,32 +3230,26 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)
     {
     case E_HImode:
       /* First, see if we can finish with one insn.  */
-      if ((TARGET_H8300H || TARGET_H8300S)
-	  && b0 != 0
-	  && b1 != 0)
+      if (b0 != 0 && b1 != 0)
 	{
 	  cc = CC_SET_ZNV;
 	}
       break;
     case E_SImode:
-      if (TARGET_H8300H || TARGET_H8300S)
-	{
-	  /* Determine if the lower half can be taken care of in no more
-	     than two bytes.  */
-	  lower_half_easy_p = (b0 == 0
-			       || b1 == 0
-			       || (code != IOR && w0 == 0xffff));
-
-	  /* Determine if the upper half can be taken care of in no more
-	     than two bytes.  */
-	  upper_half_easy_p = ((code != IOR && w1 == 0xffff)
-			       || (code == AND && w1 == 0xff00));
-	}
+      /* Determine if the lower half can be taken care of in no more
+	 than two bytes.  */
+      lower_half_easy_p = (b0 == 0
+			   || b1 == 0
+			   || (code != IOR && w0 == 0xffff));
+
+      /* Determine if the upper half can be taken care of in no more
+         than two bytes.  */
+      upper_half_easy_p = ((code != IOR && w1 == 0xffff)
+			   || (code == AND && w1 == 0xff00));
 
       /* Check if doing everything with one insn is no worse than
 	 using multiple insns.  */
-      if ((TARGET_H8300H || TARGET_H8300S)
-	  && w0 != 0 && w1 != 0
+      if (w0 != 0 && w1 != 0
 	  && !(lower_half_easy_p && upper_half_easy_p)
 	  && !(code == IOR && w1 == 0xffff
 	       && (w0 & 0x8000) != 0 && lower_half_easy_p))
@@ -3515,8 +3258,7 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)
 	}
       else
 	{
-	  if ((TARGET_H8300H || TARGET_H8300S)
-	      && code == IOR
+	  if (code == IOR
 	      && w1 == 0xffff
 	      && (w0 & 0x8000) != 0)
 	    {
@@ -3530,6 +3272,7 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)
   return cc;
 }
 
+#if 0
 /* Expand a conditional branch.  */
 
 void
@@ -3569,6 +3312,7 @@ h8300_expand_store (rtx operands[])
   tmp = gen_rtx_fmt_ee (code, GET_MODE (dest), cc0_rtx, const0_rtx);
   emit_insn (gen_rtx_SET (dest, tmp));
 }
+#endif
 
 /* Shifts.
 
@@ -3927,8 +3671,7 @@ static void get_shift_alg (enum shift_type,
 /* Given SHIFT_TYPE, SHIFT_MODE, and shift count COUNT, determine the
    best algorithm for doing the shift.  The assembler code is stored
    in the pointers in INFO.  We achieve the maximum efficiency in most
-   cases when !TARGET_H8300.  In case of TARGET_H8300, shifts in
-   SImode in particular have a lot of room to optimize.
+   cases.
 
    We first determine the strategy of the shift algorithm by a table
    lookup.  If that tells us to use a hand crafted assembly code, we
@@ -3942,10 +3685,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 {
   enum h8_cpu cpu;
 
-  /* Find the target CPU.  */
-  if (TARGET_H8300)
-    cpu = H8_300;
-  else if (TARGET_H8300S)
+  if (TARGET_H8300S)
     cpu = H8_S;
   else
     cpu = H8_300H;
@@ -4019,16 +3759,10 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	  switch (shift_type)
 	    {
 	    case SHIFT_ASHIFT:
-	      if (TARGET_H8300)
-		info->special = "shar.b\t%t0\n\tmov.b\t%s0,%t0\n\trotxr.b\t%t0\n\trotr.b\t%s0\n\tand.b\t#0x80,%s0";
-	      else
-		info->special = "shar.b\t%t0\n\tmov.b\t%s0,%t0\n\trotxr.w\t%T0\n\tand.b\t#0x80,%s0";
+	      info->special = "shar.b\t%t0\n\tmov.b\t%s0,%t0\n\trotxr.w\t%T0\n\tand.b\t#0x80,%s0";
 	      goto end;
 	    case SHIFT_LSHIFTRT:
-	      if (TARGET_H8300)
-		info->special = "shal.b\t%s0\n\tmov.b\t%t0,%s0\n\trotxl.b\t%s0\n\trotl.b\t%t0\n\tand.b\t#0x01,%t0";
-	      else
-		info->special = "shal.b\t%s0\n\tmov.b\t%t0,%s0\n\trotxl.w\t%T0\n\tand.b\t#0x01,%t0";
+	      info->special = "shal.b\t%s0\n\tmov.b\t%t0,%s0\n\trotxl.w\t%T0\n\tand.b\t#0x01,%t0";
 	      goto end;
 	    case SHIFT_ASHIFTRT:
 	      info->special = "shal.b\t%s0\n\tmov.b\t%t0,%s0\n\trotxl.b\t%s0\n\tsubx\t%t0,%t0";
@@ -4046,29 +3780,12 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      info->special = "mov.b\t%s0,%t0\n\tsub.b\t%s0,%s0";
 	      goto end;
 	    case SHIFT_LSHIFTRT:
-	      if (TARGET_H8300)
-		{
-		  info->special = "mov.b\t%t0,%s0\n\tsub.b\t%t0,%t0";
-		  info->shift1  = "shlr.b\t%s0";
-		  info->cc_inline = CC_SET_ZNV;
-		}
-	      else
-		{
-		  info->special = "mov.b\t%t0,%s0\n\textu.w\t%T0";
-		  info->cc_special = CC_SET_ZNV;
-		}
+	      info->special = "mov.b\t%t0,%s0\n\textu.w\t%T0";
+	      info->cc_special = CC_SET_ZNV;
 	      goto end;
 	    case SHIFT_ASHIFTRT:
-	      if (TARGET_H8300)
-		{
-		  info->special = "mov.b\t%t0,%s0\n\tbld\t#7,%s0\n\tsubx\t%t0,%t0";
-		  info->shift1  = "shar.b\t%s0";
-		}
-	      else
-		{
-		  info->special = "mov.b\t%t0,%s0\n\texts.w\t%T0";
-		  info->cc_special = CC_SET_ZNV;
-		}
+	      info->special = "mov.b\t%t0,%s0\n\texts.w\t%T0";
+	      info->cc_special = CC_SET_ZNV;
 	      goto end;
 	    }
 	}
@@ -4077,17 +3794,11 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	  switch (shift_type)
 	    {
 	    case SHIFT_ASHIFT:
-	      if (TARGET_H8300)
-		info->special = "mov.b\t%s0,%t0\n\trotr.b\t%t0\n\trotr.b\t%t0\n\tand.b\t#0xC0,%t0\n\tsub.b\t%s0,%s0";
-	      goto end;
 	    case SHIFT_LSHIFTRT:
-	      if (TARGET_H8300)
-		info->special = "mov.b\t%t0,%s0\n\trotl.b\t%s0\n\trotl.b\t%s0\n\tand.b\t#3,%s0\n\tsub.b\t%t0,%t0";
+	      goto end;
 	      goto end;
 	    case SHIFT_ASHIFTRT:
-	      if (TARGET_H8300)
-		info->special = "mov.b\t%t0,%s0\n\tshll.b\t%s0\n\tsubx.b\t%t0,%t0\n\tshll.b\t%s0\n\tmov.b\t%t0,%s0\n\tbst.b\t#0,%s0";
-	      else if (TARGET_H8300H)
+	      if (TARGET_H8300H)
 		{
 		  info->special = "shll.b\t%t0\n\tsubx.b\t%s0,%s0\n\tshll.b\t%t0\n\trotxl.b\t%s0\n\texts.w\t%T0";
 		  info->cc_special = CC_SET_ZNV;
@@ -4115,25 +3826,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
       gcc_unreachable ();
 
     case SIshift:
-      if (TARGET_H8300 && count >= 8 && count <= 9)
-	{
-	  info->remainder = count - 8;
-
-	  switch (shift_type)
-	    {
-	    case SHIFT_ASHIFT:
-	      info->special = "mov.b\t%y0,%z0\n\tmov.b\t%x0,%y0\n\tmov.b\t%w0,%x0\n\tsub.b\t%w0,%w0";
-	      goto end;
-	    case SHIFT_LSHIFTRT:
-	      info->special = "mov.b\t%x0,%w0\n\tmov.b\t%y0,%x0\n\tmov.b\t%z0,%y0\n\tsub.b\t%z0,%z0";
-	      info->shift1  = "shlr\t%y0\n\trotxr\t%x0\n\trotxr\t%w0";
-	      goto end;
-	    case SHIFT_ASHIFTRT:
-	      info->special = "mov.b\t%x0,%w0\n\tmov.b\t%y0,%x0\n\tmov.b\t%z0,%y0\n\tshll\t%z0\n\tsubx\t%z0,%z0";
-	      goto end;
-	    }
-	}
-      else if (count == 8 && !TARGET_H8300)
+      if (count == 8)
 	{
 	  switch (shift_type)
 	    {
@@ -4148,21 +3841,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      goto end;
 	    }
 	}
-      else if (count == 15 && TARGET_H8300)
-	{
-	  switch (shift_type)
-	    {
-	    case SHIFT_ASHIFT:
-	      gcc_unreachable ();
-	    case SHIFT_LSHIFTRT:
-	      info->special = "bld\t#7,%z0\n\tmov.w\t%e0,%f0\n\txor\t%y0,%y0\n\txor\t%z0,%z0\n\trotxl\t%w0\n\trotxl\t%x0\n\trotxl\t%y0";
-	      goto end;
-	    case SHIFT_ASHIFTRT:
-	      info->special = "bld\t#7,%z0\n\tmov.w\t%e0,%f0\n\trotxl\t%w0\n\trotxl\t%x0\n\tsubx\t%y0,%y0\n\tsubx\t%z0,%z0";
-	      goto end;
-	    }
-	}
-      else if (count == 15 && !TARGET_H8300)
+      else if (count == 15)
 	{
 	  switch (shift_type)
 	    {
@@ -4178,8 +3857,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      gcc_unreachable ();
 	    }
 	}
-      else if ((TARGET_H8300 && count >= 16 && count <= 20)
-	       || (TARGET_H8300H && count >= 16 && count <= 19)
+      else if ((TARGET_H8300H && count >= 16 && count <= 19)
 	       || (TARGET_H8300S && count >= 16 && count <= 21))
 	{
 	  info->remainder = count - 16;
@@ -4188,55 +3866,14 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	    {
 	    case SHIFT_ASHIFT:
 	      info->special = "mov.w\t%f0,%e0\n\tsub.w\t%f0,%f0";
-	      if (TARGET_H8300)
-		info->shift1 = "add.w\t%e0,%e0";
-	      goto end;
-	    case SHIFT_LSHIFTRT:
-	      if (TARGET_H8300)
-		{
-		  info->special = "mov.w\t%e0,%f0\n\tsub.w\t%e0,%e0";
-		  info->shift1  = "shlr\t%x0\n\trotxr\t%w0";
-		}
-	      else
-		{
-		  info->special = "mov.w\t%e0,%f0\n\textu.l\t%S0";
-		  info->cc_special = CC_SET_ZNV;
-		}
-	      goto end;
-	    case SHIFT_ASHIFTRT:
-	      if (TARGET_H8300)
-		{
-		  info->special = "mov.w\t%e0,%f0\n\tshll\t%z0\n\tsubx\t%z0,%z0\n\tmov.b\t%z0,%y0";
-		  info->shift1  = "shar\t%x0\n\trotxr\t%w0";
-		}
-	      else
-		{
-		  info->special = "mov.w\t%e0,%f0\n\texts.l\t%S0";
-		  info->cc_special = CC_SET_ZNV;
-		}
-	      goto end;
-	    }
-	}
-      else if (TARGET_H8300 && count >= 24 && count <= 28)
-	{
-	  info->remainder = count - 24;
-
-	  switch (shift_type)
-	    {
-	    case SHIFT_ASHIFT:
-	      info->special = "mov.b\t%w0,%z0\n\tsub.b\t%y0,%y0\n\tsub.w\t%f0,%f0";
-	      info->shift1  = "shll.b\t%z0";
-	      info->cc_inline = CC_SET_ZNV;
 	      goto end;
 	    case SHIFT_LSHIFTRT:
-	      info->special = "mov.b\t%z0,%w0\n\tsub.b\t%x0,%x0\n\tsub.w\t%e0,%e0";
-	      info->shift1  = "shlr.b\t%w0";
-	      info->cc_inline = CC_SET_ZNV;
+	      info->special = "mov.w\t%e0,%f0\n\textu.l\t%S0";
+	      info->cc_special = CC_SET_ZNV;
 	      goto end;
 	    case SHIFT_ASHIFTRT:
-	      info->special = "mov.b\t%z0,%w0\n\tbld\t#7,%w0\n\tsubx\t%x0,%x0\n\tsubx\t%y0,%y0\n\tsubx\t%z0,%z0";
-	      info->shift1  = "shar.b\t%w0";
-	      info->cc_inline = CC_SET_ZNV;
+	      info->special = "mov.w\t%e0,%f0\n\texts.l\t%S0";
+	      info->cc_special = CC_SET_ZNV;
 	      goto end;
 	    }
 	}
@@ -4260,7 +3897,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      goto end;
 	    }
 	}
-      else if (!TARGET_H8300 && count == 28)
+      else if (count == 28)
 	{
 	  switch (shift_type)
 	    {
@@ -4283,7 +3920,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      gcc_unreachable ();
 	    }
 	}
-      else if (!TARGET_H8300 && count == 29)
+      else if (count == 29)
 	{
 	  switch (shift_type)
 	    {
@@ -4309,7 +3946,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      gcc_unreachable ();
 	    }
 	}
-      else if (!TARGET_H8300 && count == 30)
+      else if (count == 30)
 	{
 	  switch (shift_type)
 	    {
@@ -4331,38 +3968,20 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	}
       else if (count == 31)
 	{
-	  if (TARGET_H8300)
-	    {
-	      switch (shift_type)
-		{
-		case SHIFT_ASHIFT:
-		  info->special = "sub.w\t%e0,%e0\n\tshlr\t%w0\n\tmov.w\t%e0,%f0\n\trotxr\t%z0";
-		  goto end;
-		case SHIFT_LSHIFTRT:
-		  info->special = "sub.w\t%f0,%f0\n\tshll\t%z0\n\tmov.w\t%f0,%e0\n\trotxl\t%w0";
-		  goto end;
-		case SHIFT_ASHIFTRT:
-		  info->special = "shll\t%z0\n\tsubx\t%w0,%w0\n\tmov.b\t%w0,%x0\n\tmov.w\t%f0,%e0";
-		  goto end;
-		}
-	    }
-	  else
+	  switch (shift_type)
 	    {
-	      switch (shift_type)
-		{
-		case SHIFT_ASHIFT:
-		  info->special = "shlr.l\t%S0\n\txor.l\t%S0,%S0\n\trotxr.l\t%S0";
-		  info->cc_special = CC_SET_ZNV;
-		  goto end;
-		case SHIFT_LSHIFTRT:
-		  info->special = "shll.l\t%S0\n\txor.l\t%S0,%S0\n\trotxl.l\t%S0";
-		  info->cc_special = CC_SET_ZNV;
-		  goto end;
-		case SHIFT_ASHIFTRT:
-		  info->special = "shll\t%e0\n\tsubx\t%w0,%w0\n\texts.w\t%T0\n\texts.l\t%S0";
-		  info->cc_special = CC_SET_ZNV;
-		  goto end;
-		}
+	    case SHIFT_ASHIFT:
+	      info->special = "shlr.l\t%S0\n\txor.l\t%S0,%S0\n\trotxr.l\t%S0";
+	      info->cc_special = CC_SET_ZNV;
+	      goto end;
+	    case SHIFT_LSHIFTRT:
+	      info->special = "shll.l\t%S0\n\txor.l\t%S0,%S0\n\trotxl.l\t%S0";
+	      info->cc_special = CC_SET_ZNV;
+	      goto end;
+	    case SHIFT_ASHIFTRT:
+	      info->special = "shll\t%e0\n\tsubx\t%w0,%w0\n\texts.w\t%T0\n\texts.l\t%S0";
+	      info->cc_special = CC_SET_ZNV;
+	      goto end;
 	    }
 	}
       gcc_unreachable ();
@@ -4389,9 +4008,7 @@ h8300_shift_needs_scratch_p (int count, machine_mode mode)
     return 1;
 
   /* Find out the target CPU.  */
-  if (TARGET_H8300)
-    cpu = H8_300;
-  else if (TARGET_H8300S)
+  if (TARGET_H8300S)
     cpu = H8_S;
   else
     cpu = H8_300H;
@@ -4541,7 +4158,6 @@ output_a_shift (rtx *operands)
 	    break;
 
 	  case E_HImode:
-	    gcc_assert (TARGET_H8300H || TARGET_H8300S);
 	    sprintf (insn_buf, "and.w\t#%d,%%T0", mask);
 	    break;
 
@@ -4715,7 +4331,6 @@ compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)
 		wlength += 2;
 		break;
 	      case E_SImode:
-		gcc_assert (!TARGET_H8300);
 		wlength += 3;
 		break;
 	      default:
@@ -4747,7 +4362,7 @@ compute_a_shift_length (rtx insn ATTRIBUTE_UNUSED, rtx *operands)
 
 /* Compute which flag bits are valid after a shift insn.  */
 
-enum attr_cc
+int
 compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)
 {
   rtx shift = operands[3];
@@ -4981,8 +4596,7 @@ output_a_rotate (enum rtx_code code, rtx *operands)
 
   /* See if a byte swap (in HImode) or a word swap (in SImode) can
      boost up the rotation.  */
-  if ((mode == HImode && TARGET_H8300 && amount >= 5)
-      || (mode == HImode && TARGET_H8300H && amount >= 6)
+  if ((mode == HImode && TARGET_H8300H && amount >= 6)
       || (mode == HImode && TARGET_H8300S && amount == 8)
       || (mode == SImode && TARGET_H8300H && amount >= 10)
       || (mode == SImode && TARGET_H8300S && amount >= 13))
@@ -5055,8 +4669,7 @@ compute_a_rotate_length (rtx *operands)
 
   /* See if a byte swap (in HImode) or a word swap (in SImode) can
      boost up the rotation.  */
-  if ((mode == HImode && TARGET_H8300 && amount >= 5)
-      || (mode == HImode && TARGET_H8300H && amount >= 6)
+  if ((mode == HImode && TARGET_H8300H && amount >= 6)
       || (mode == HImode && TARGET_H8300S && amount == 8)
       || (mode == SImode && TARGET_H8300H && amount >= 10)
       || (mode == SImode && TARGET_H8300S && amount >= 13))
@@ -5072,7 +4685,7 @@ compute_a_rotate_length (rtx *operands)
 
   /* The H8/300 uses three insns to rotate one bit, taking 6
      length.  */
-  length += amount * ((TARGET_H8300 && mode == HImode) ? 6 : 2);
+  length += amount * 2;
 
   return length;
 }
@@ -5406,41 +5019,24 @@ h8300_encode_section_info (tree decl, rtx rtl, int first)
 const char *
 output_simode_bld (int bild, rtx operands[])
 {
-  if (TARGET_H8300)
-    {
-      /* Clear the destination register.  */
-      output_asm_insn ("sub.w\t%e0,%e0\n\tsub.w\t%f0,%f0", operands);
+  /* Determine if we can clear the destination first.  */
+  int clear_first = (REG_P (operands[0]) && REG_P (operands[1])
+		     && REGNO (operands[0]) != REGNO (operands[1]));
 
-      /* Now output the bit load or bit inverse load, and store it in
-	 the destination.  */
-      if (bild)
-	output_asm_insn ("bild\t%Z2,%Y1", operands);
-      else
-	output_asm_insn ("bld\t%Z2,%Y1", operands);
+  if (clear_first)
+    output_asm_insn ("sub.l\t%S0,%S0", operands);
 
-      output_asm_insn ("bst\t#0,%w0", operands);
-    }
+  /* Output the bit load or bit inverse load.  */
+  if (bild)
+    output_asm_insn ("bild\t%Z2,%Y1", operands);
   else
-    {
-      /* Determine if we can clear the destination first.  */
-      int clear_first = (REG_P (operands[0]) && REG_P (operands[1])
-			 && REGNO (operands[0]) != REGNO (operands[1]));
-
-      if (clear_first)
-	output_asm_insn ("sub.l\t%S0,%S0", operands);
-
-      /* Output the bit load or bit inverse load.  */
-      if (bild)
-	output_asm_insn ("bild\t%Z2,%Y1", operands);
-      else
-	output_asm_insn ("bld\t%Z2,%Y1", operands);
+    output_asm_insn ("bld\t%Z2,%Y1", operands);
 
-      if (!clear_first)
-	output_asm_insn ("xor.l\t%S0,%S0", operands);
+  if (!clear_first)
+    output_asm_insn ("xor.l\t%S0,%S0", operands);
 
-      /* Perform the bit store.  */
-      output_asm_insn ("rotxl.l\t%S0", operands);
-    }
+  /* Perform the bit store.  */
+  output_asm_insn ("rotxl.l\t%S0", operands);
 
   /* All done.  */
   return "";
@@ -5457,16 +5053,6 @@ h8300_reorg (void)
     shorten_branches (get_insns ());
 }
 
-#ifndef OBJECT_FORMAT_ELF
-static void
-h8300_asm_named_section (const char *name, unsigned int flags ATTRIBUTE_UNUSED,
-			 tree decl)
-{
-  /* ??? Perhaps we should be using default_coff_asm_named_section.  */
-  fprintf (asm_out_file, "\t.section %s\n", name);
-}
-#endif /* ! OBJECT_FORMAT_ELF */
-
 /* Nonzero if X is a constant address suitable as an 8-bit absolute,
    which is a special case of the 'R' operand.  */
 
@@ -5499,7 +5085,7 @@ h8300_eightbit_constant_address_p (rtx x)
   addr = INTVAL (x);
 
   return (0
-	  || ((TARGET_H8300 || TARGET_NORMAL_MODE) && IN_RANGE (addr, n1, n2))
+	  || (TARGET_NORMAL_MODE && IN_RANGE (addr, n1, n2))
 	  || (TARGET_H8300H && IN_RANGE (addr, h1, h2))
 	  || (TARGET_H8300S && IN_RANGE (addr, s1, s2)));
 }
@@ -5749,14 +5335,9 @@ h8300_legitimate_address_p (machine_mode mode, rtx x, bool strict)
 static bool
 h8300_hard_regno_mode_ok (unsigned int regno, machine_mode mode)
 {
-  if (TARGET_H8300)
-    /* If an even reg, then anything goes.  Otherwise the mode must be
-       QI or HI.  */
-    return ((regno & 1) == 0) || (mode == HImode) || (mode == QImode);
-  else
-    /* MAC register can only be of SImode.  Otherwise, anything
-       goes.  */
-    return regno == MAC_REG ? mode == SImode : 1;
+  /* MAC register can only be of SImode.  Otherwise, anything
+     goes.  */
+  return regno == MAC_REG ? mode == SImode : 1;
 }
 
 /* Implement TARGET_MODES_TIEABLE_P.  */
@@ -5767,10 +5348,10 @@ h8300_modes_tieable_p (machine_mode mode1, machine_mode mode2)
   return (mode1 == mode2
 	  || ((mode1 == QImode
 	       || mode1 == HImode
-	       || ((TARGET_H8300H || TARGET_H8300S) && mode1 == SImode))
+	       || mode1 == SImode)
 	      && (mode2 == QImode
 		  || mode2 == HImode
-		  || ((TARGET_H8300H || TARGET_H8300S) && mode2 == SImode))));
+		  || mode2 == SImode)));
 }
 
 /* Helper function for the move patterns.  Make sure a move is legitimate.  */
@@ -5796,8 +5377,13 @@ h8300_move_ok (rtx dest, rtx src)
   else
     return true;
 
-  /* Validate that auto-inc doesn't affect OTHER.  */
-  if (GET_RTX_CLASS (GET_CODE (addr)) != RTX_AUTOINC)
+  /* Validate that auto-inc doesn't affect OTHER.
+     But allow them post-reload.  Reload can create such RTL even
+     though it's not technically valid.  The semantics are well
+     defined by the hardware and match what one would expect
+     (the value pushed is the stack pointer's value at the start
+     of the instruction.  */
+  if (reload_completed || GET_RTX_CLASS (GET_CODE (addr)) != RTX_AUTOINC)
     return true;
   addr = XEXP (addr, 0);
 
@@ -5856,7 +5442,7 @@ static bool
 h8300_return_in_memory (const_tree type, const_tree fntype ATTRIBUTE_UNUSED)
 {
   return (TYPE_MODE (type) == BLKmode
-	  || GET_MODE_SIZE (TYPE_MODE (type)) > (TARGET_H8300 ? 4 : 8));
+	  || GET_MODE_SIZE (TYPE_MODE (type)) > 8);
 }
 
 /* We emit the entire trampoline here.  Depending on the pointer size,
@@ -6015,4 +5601,7 @@ h8300_push_rounding (poly_int64 bytes)
 #undef TARGET_HAVE_SPECULATION_SAFE_VALUE
 #define TARGET_HAVE_SPECULATION_SAFE_VALUE speculation_safe_value_not_needed
 
+#undef TARGET_FLAGS_REGNUM
+#define TARGET_FLAGS_REGNUM 12
+
 struct gcc_target targetm = TARGET_INITIALIZER;
diff --git a/gcc/config/h8300/h8300.h b/gcc/config/h8300/h8300.h
index 32e5f7dc5cf..eb78175c50d 100644
--- a/gcc/config/h8300/h8300.h
+++ b/gcc/config/h8300/h8300.h
@@ -23,11 +23,6 @@ along with GCC; see the file COPYING3.  If not see
 #ifndef GCC_H8300_H
 #define GCC_H8300_H
 
-/* Which CPU to compile for.
-   We use int for CPU_TYPE to avoid lots of casts.  */
-#if 0 /* defined in insn-attr.h, here for documentation */
-enum attr_cpu { CPU_H8300, CPU_H8300H };
-#endif
 extern int cpu_type;
 
 /* Various globals defined in h8300.c.  */
@@ -57,7 +52,7 @@ extern const char * const *h8_reg_names;
 	      builtin_define ("__NORMAL_MODE__");	\
 	    }						\
 	}						\
-      else if (TARGET_H8300H)				\
+      else						\
 	{						\
 	  builtin_define ("__H8300H__");		\
 	  builtin_assert ("cpu=h8300h");		\
@@ -67,23 +62,16 @@ extern const char * const *h8_reg_names;
 	      builtin_define ("__NORMAL_MODE__");	\
 	    }						\
 	}						\
-      else						\
-	{						\
-	  builtin_define ("__H8300__");			\
-	  builtin_assert ("cpu=h8300");			\
-	  builtin_assert ("machine=h8300");		\
-	}						\
     }							\
   while (0)
 
-#define LINK_SPEC "%{mh:%{mn:-m h8300hn}} %{mh:%{!mn:-m h8300h}} %{ms:%{mn:-m h8300sn}} %{ms:%{!mn:-m h8300s}}"
+#define LINK_SPEC "%{!ms:%{mn:-m h8300hn}} %{!ms:%{!mn:-m h8300h}} %{ms:%{mn:-m h8300sn}} %{ms:%{!mn:-m h8300s}}"
 
 #define LIB_SPEC "%{mrelax:-relax} %{g:-lg} %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p}"
 
 /* Macros used in the machine description to test the flags.  */
 
 /* Select between the H8/300 and H8/300H CPUs.  */
-#define TARGET_H8300	(! TARGET_H8300H && ! TARGET_H8300S)
 #define TARGET_H8300S	(TARGET_H8300S_1 || TARGET_H8300SX)
 /* Some multiply instructions are not available in all H8SX variants.
    Use this macro instead of TARGET_H8300SX to indicate this, even
@@ -116,7 +104,7 @@ extern const char * const *h8_reg_names;
 /* Default target_flags if no switches specified.  */
 
 #ifndef TARGET_DEFAULT
-#define TARGET_DEFAULT (MASK_QUICKCALL)
+#define TARGET_DEFAULT (MASK_H8300H | MASK_QUICKCALL)
 #endif
 
 /* We want dwarf2 info available to gdb.  */
@@ -156,7 +144,7 @@ extern const char * const *h8_reg_names;
 #define MAX_BITS_PER_WORD	32
 
 /* Width of a word, in units (bytes).  */
-#define UNITS_PER_WORD		(TARGET_H8300H || TARGET_H8300S ? 4 : 2)
+#define UNITS_PER_WORD		4
 #define MIN_UNITS_PER_WORD	2
 
 #define SHORT_TYPE_SIZE	16
@@ -170,7 +158,7 @@ extern const char * const *h8_reg_names;
 #define MAX_FIXED_MODE_SIZE	32
 
 /* Allocation boundary (in *bits*) for storing arguments in argument list.  */
-#define PARM_BOUNDARY (TARGET_H8300H || TARGET_H8300S ? 32 : 16)
+#define PARM_BOUNDARY 32
 
 /* Allocation boundary (in *bits*) for the code of a function.  */
 #define FUNCTION_BOUNDARY 16
@@ -184,10 +172,10 @@ extern const char * const *h8_reg_names;
 /* No data type wants to be aligned rounder than this.
    32-bit values are aligned as such on the H8/300H and H8S for speed.  */
 #define BIGGEST_ALIGNMENT \
-(((TARGET_H8300H || TARGET_H8300S) && ! TARGET_ALIGN_300) ? 32 : 16)
+((! TARGET_ALIGN_300) ? 32 : 16)
 
-/* The stack goes in 16/32 bit lumps.  */
-#define STACK_BOUNDARY (TARGET_H8300 ? 16 : 32)
+/* The stack goes in 32 bit lumps.  */
+#define STACK_BOUNDARY 32
 
 /* Define this if move instructions will actually fail to work
    when given unaligned data.  */
@@ -209,14 +197,14 @@ extern const char * const *h8_reg_names;
    eliminated during reloading in favor of either the stack or frame
    pointer.  */
 
-#define FIRST_PSEUDO_REGISTER 12
+#define FIRST_PSEUDO_REGISTER 13
 
 /* 1 for registers that have pervasive standard uses
    and are not available for the register allocator.  */
 
 #define FIXED_REGISTERS				\
-/* r0 r1 r2 r3 r4 r5 r6 r7 mac ap rap fp */	\
-  { 0, 0, 0, 0, 0, 0, 0, 1,  0, 1,  1, 1 }
+/* r0 r1 r2 r3 r4 r5 r6 r7 mac ap rap fp cc */	\
+  { 0, 0, 0, 0, 0, 0, 0, 1,  0, 1,  1, 1, 1 }
 
 /* 1 for registers not available across function calls.
    These must include the FIXED_REGISTERS and also any
@@ -230,11 +218,11 @@ extern const char * const *h8_reg_names;
 
 #define CALL_USED_REGISTERS			\
 /* r0 r1 r2 r3 r4 r5 r6 r7 mac ap rap fp */	\
-  { 1, 1, 1, 1, 0, 0, 0, 1,  1, 1,  1, 1 }
+  { 1, 1, 1, 1, 0, 0, 0, 1,  1, 1,  1, 1, 1 }
 
 #define REG_ALLOC_ORDER				\
 /* r0 r1 r2 r3 r4 r5 r6 r7 mac ap rap  fp */	\
-  { 2, 3, 0, 1, 4, 5, 6, 8,  7, 9, 10, 11 }
+  { 2, 3, 0, 1, 4, 5, 6, 8,  7, 9, 10, 11, 12 }
 
 /* A C expression that is nonzero if hard register NEW_REG can be
    considered for use as a rename register for OLD_REG register */
@@ -480,8 +468,8 @@ struct cum_arg
   (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF	\
    || (GET_CODE (X) == CONST_INT				\
        /* We handle signed and unsigned offsets here.  */	\
-       && INTVAL (X) > (TARGET_H8300 ? -0x10000 : -0x1000000)	\
-       && INTVAL (X) < (TARGET_H8300 ? 0x10000 : 0x1000000))	\
+       && INTVAL (X) > -0x1000000				\
+       && INTVAL (X) < 0x1000000)				\
    || (GET_CODE (X) == HIGH || GET_CODE (X) == CONST))
 
 /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx
@@ -532,9 +520,11 @@ struct cum_arg
 
 /* Max number of bytes we can move from memory to memory
    in one reasonably fast instruction.  */
-#define MOVE_MAX	(TARGET_H8300H || TARGET_H8300S ? 4 : 2)
+#define MOVE_MAX	4
 #define MAX_MOVE_MAX	4
 
+#define SELECT_CC_MODE(OP, X, Y)       h8300_select_cc_mode (OP, X, Y)
+
 /* Nonzero if access to memory by bytes is slow and undesirable.  */
 #define SLOW_BYTE_ACCESS TARGET_SLOWBYTE
 
@@ -547,18 +537,18 @@ struct cum_arg
    After generation of rtl, the compiler makes no further distinction
    between pointers and any other objects of this machine mode.  */
 #define Pmode								      \
-  ((TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE ? SImode : HImode)
+  (!TARGET_NORMAL_MODE ? SImode : HImode)
 
 /* ANSI C types.
    We use longs for the H8/300H and the H8S because ints can be 16 or 32.
    GCC requires SIZE_TYPE to be the same size as pointers.  */
 #define SIZE_TYPE								\
-  (TARGET_H8300 || TARGET_NORMAL_MODE ? TARGET_INT32 ? "short unsigned int" : "unsigned int" : "long unsigned int")
+  (TARGET_NORMAL_MODE ? TARGET_INT32 ? "short unsigned int" : "unsigned int" : "long unsigned int")
 #define PTRDIFF_TYPE						\
-  (TARGET_H8300 || TARGET_NORMAL_MODE ? TARGET_INT32 ? "short int" : "int" : "long int")
+  (TARGET_NORMAL_MODE ? TARGET_INT32 ? "short int" : "int" : "long int")
 
 #define POINTER_SIZE							\
-  ((TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE ? 32 : 16)
+  (!TARGET_NORMAL_MODE ? 32 : 16)
 
 #define WCHAR_TYPE "short unsigned int"
 #define WCHAR_TYPE_SIZE 16
@@ -613,7 +603,7 @@ struct cum_arg
 
 /* The assembler op to get a word, 2 bytes for the H8/300, 4 for H8/300H.  */
 #define ASM_WORD_OP							\
-  (TARGET_H8300 || TARGET_NORMAL_MODE ? "\t.word\t" : "\t.long\t")
+  (TARGET_NORMAL_MODE ? "\t.word\t" : "\t.long\t")
 
 #define TEXT_SECTION_ASM_OP "\t.section .text"
 #define DATA_SECTION_ASM_OP "\t.section .data"
@@ -647,7 +637,7 @@ struct cum_arg
    This sequence is indexed by compiler's hard-register-number (see above).  */
 
 #define REGISTER_NAMES \
-{ "r0", "r1", "r2", "r3", "r4", "r5", "r6", "sp", "mac", "ap", "rap", "fp" }
+{ "r0", "r1", "r2", "r3", "r4", "r5", "r6", "sp", "mac", "ap", "rap", "fp", "cc" }
 
 #define ADDITIONAL_REGISTER_NAMES \
 { {"er0", 0}, {"er1", 1}, {"er2", 2}, {"er3", 3}, {"er4", 4}, \
@@ -659,10 +649,6 @@ struct cum_arg
 #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \
    ASM_OUTPUT_LABEL (FILE, NAME)
 
-/* The prefix to add to user-visible assembler symbols.  */
-
-#define USER_LABEL_PREFIX "_"
-
 /* This is how to store into the string LABEL
    the symbol_ref name of an internal numbered label where
    PREFIX is the class of label and NUM is the number within the class.
diff --git a/gcc/config/h8300/h8300.md b/gcc/config/h8300/h8300.md
index a86b8ea2074..51316ee381a 100644
--- a/gcc/config/h8300/h8300.md
+++ b/gcc/config/h8300/h8300.md
@@ -65,7 +65,8 @@
    (MAC_REG	 8)
    (AP_REG	 9)
    (RAP_REG	10)
-   (FP_REG	11)])
+   (FP_REG	11)
+   (CC_REG	12)])
 
 ;; ----------------------------------------------------------------------
 ;; ATTRIBUTES
@@ -167,8 +168,7 @@
 
 (define_asm_attributes
   [(set (attr "length")
-	(cond [(match_test "TARGET_H8300") (const_int 4)
-	       (match_test "TARGET_H8300H") (const_int 10)
+	(cond [(match_test "TARGET_H8300H") (const_int 10)
 	       (match_test "TARGET_H8300S") (const_int 10)]
 	      (const_int 14)))])
 
@@ -196,5336 +196,18 @@
 
 (define_code_iterator ors [ior xor])
 
-;; ----------------------------------------------------------------------
-;; MOVE INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-;; movqi
-
-(define_insn "*movqi_h8nosx"
-  [(set (match_operand:QI 0 "general_operand_dst" "=r,r ,<,r,r,m")
-	(match_operand:QI 1 "general_operand_src" " I,r>,r,n,m,r"))]
-  "(TARGET_H8300 || TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX
-    && h8300_move_ok (operands[0], operands[1])"
-  "@
-   sub.b	%X0,%X0
-   mov.b	%R1,%X0
-   mov.b	%X1,%R0
-   mov.b	%R1,%X0
-   mov.b	%R1,%X0
-   mov.b	%X1,%R0"
-  [(set (attr "length")
-	(symbol_ref "compute_mov_length (operands)"))
-   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv,set_znv")])
-
-(define_insn "*movqi_h8sx"
-  [(set (match_operand:QI 0 "general_operand_dst" "=Z,rQ")
-	(match_operand:QI 1 "general_operand_src" "P4>X,rQi"))]
-  "TARGET_H8300SX"
-  "@
-    mov.b	%X1:4,%X0
-    mov.b	%X1,%X0"
-  [(set_attr "length_table" "mov_imm4,movb")
-   (set_attr "cc" "set_znv")])
-
-(define_expand "mov<mode>"
-  [(set (match_operand:QHSIF 0 "general_operand_dst" "")
-	(match_operand:QHSIF 1 "general_operand_src" ""))]
-  ""
-  {
-    enum machine_mode mode = <MODE>mode;
-    if (TARGET_H8300 && (mode == SImode || mode == SFmode))
-      {
-	/* The original H8/300 needs to split up 32 bit moves.  */
-	if (h8300_expand_movsi (operands))
-	  DONE;
-      }
-    else if (!TARGET_H8300SX)
-      {
-	/* Other H8 chips, except the H8/SX family can only handle a
-	   single memory operand, which is checked by h8300_move_ok.
-
-	   We could perhaps have h8300_move_ok handle the H8/SX better
-	   and just remove the !TARGET_H8300SX conditional.  */
-	if (!h8300_move_ok (operands[0], operands[1]))
-	  operands[1] = copy_to_mode_reg (mode, operand1);
-      }
-  })
-
-(define_insn "movstrictqi"
-  [(set (strict_low_part (match_operand:QI 0 "general_operand_dst" "+r,r"))
-			 (match_operand:QI 1 "general_operand_src" "I,rmi>"))]
-  ""
-  "@
-   sub.b	%X0,%X0
-   mov.b	%X1,%X0"
-  [(set_attr "length" "2,*")
-   (set_attr "length_table" "*,movb")
-   (set_attr "cc" "set_zn,set_znv")])
-
-;; movhi
-
-(define_insn "*movhi_h8nosx"
-  [(set (match_operand:HI 0 "general_operand_dst" "=r,r,<,r,r,m")
-	(match_operand:HI 1 "general_operand_src" "I,r>,r,i,m,r"))]
-  "(TARGET_H8300 || TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX
-    && h8300_move_ok (operands[0], operands[1])"
-  "@
-   sub.w	%T0,%T0
-   mov.w	%T1,%T0
-   mov.w	%T1,%T0
-   mov.w	%T1,%T0
-   mov.w	%T1,%T0
-   mov.w	%T1,%T0"
-  [(set (attr "length")
-	(symbol_ref "compute_mov_length (operands)"))
-   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv,set_znv")])
-
-(define_insn "*movhi_h8sx"
-  [(set (match_operand:HI 0 "general_operand_dst" "=r,r,Z,Q,rQ")
-	(match_operand:HI 1 "general_operand_src" "I,P3>X,P4>X,IP8>X,rQi"))]
-  "TARGET_H8300SX"
-  "@
-   sub.w	%T0,%T0
-   mov.w	%T1:3,%T0
-   mov.w	%T1:4,%T0
-   mov.w	%T1,%T0
-   mov.w	%T1,%T0"
-  [(set_attr "length_table" "*,*,mov_imm4,short_immediate,movw")
-   (set_attr "length" "2,2,*,*,*")
-   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv")])
-
-(define_insn "movstricthi"
-  [(set (strict_low_part (match_operand:HI 0 "general_operand_dst" "+r,r,r"))
-			 (match_operand:HI 1 "general_operand_src" "I,P3>X,rmi"))]
-  ""
-  "@
-   sub.w	%T0,%T0
-   mov.w	%T1,%T0
-   mov.w	%T1,%T0"
-  [(set_attr "length" "2,2,*")
-   (set_attr "length_table" "*,*,movw")
-   (set_attr "cc" "set_zn,set_znv,set_znv")])
-
-;; movsi
-
-(define_insn "*movsi_h8300"
-  [(set (match_operand:SI 0 "general_operand_dst" "=r,r,r,o,<,r")
-	(match_operand:SI 1 "general_operand_src" "I,r,io,r,r,>"))]
-  "TARGET_H8300
-   && h8300_move_ok (operands[0], operands[1])"
-{
-  unsigned int rn = -1;
-  switch (which_alternative)
-    {
-    case 0:
-      return "sub.w	%e0,%e0\;sub.w	%f0,%f0";
-    case 1:
-      if (REGNO (operands[0]) < REGNO (operands[1]))
-	return "mov.w	%e1,%e0\;mov.w	%f1,%f0";
-      else
-	return "mov.w	%f1,%f0\;mov.w	%e1,%e0";
-    case 2:
-      /* Make sure we don't trample the register we index with.  */
-      if (GET_CODE (operands[1]) == MEM)
-	{
-	  rtx inside = XEXP (operands[1], 0);
-	  if (REG_P (inside))
-	    {
-	      rn = REGNO (inside);
-	    }
-	  else if (GET_CODE (inside) == PLUS)
-	    {
-	      rtx lhs = XEXP (inside, 0);
-	      rtx rhs = XEXP (inside, 1);
-	      if (REG_P (lhs)) rn = REGNO (lhs);
-	      if (REG_P (rhs)) rn = REGNO (rhs);
-	    }
-	}
-      if (rn == REGNO (operands[0]))
-	{
-	  /* Move the second word first.  */
-	  return "mov.w	%f1,%f0\;mov.w	%e1,%e0";
-	}
-      else
-	{
-	  if (GET_CODE (operands[1]) == CONST_INT)
-	    {
-	      /* If either half is zero, use sub.w to clear that
-		 half.  */
-	      if ((INTVAL (operands[1]) & 0xffff) == 0)
-		return "mov.w	%e1,%e0\;sub.w	%f0,%f0";
-	      if (((INTVAL (operands[1]) >> 16) & 0xffff) == 0)
-		return "sub.w	%e0,%e0\;mov.w	%f1,%f0";
-	      /* If the upper half and the lower half are the same,
-		 copy one half to the other.  */
-	      if ((INTVAL (operands[1]) & 0xffff)
-		  == ((INTVAL (operands[1]) >> 16) & 0xffff))
-		return "mov.w\\t%e1,%e0\;mov.w\\t%e0,%f0";
-	    }
-	  return "mov.w	%e1,%e0\;mov.w	%f1,%f0";
-	}
-    case 3:
-      return "mov.w	%e1,%e0\;mov.w	%f1,%f0";
-    case 4:
-      return "mov.w	%f1,%T0\;mov.w	%e1,%T0";
-    case 5:
-      return "mov.w	%T1,%e0\;mov.w	%T1,%f0";
-    default:
-      gcc_unreachable ();
-    }
-}
-  [(set (attr "length")
-	(symbol_ref "compute_mov_length (operands)"))])
-
-(define_insn "*movsi_h8300hs"
-  [(set (match_operand:SI 0 "general_operand_dst" "=r,r,r,<,r,r,m,*a,*a,r")
-	(match_operand:SI 1 "general_operand_src" "I,r,i,r,>,m,r,I,r,*a"))]
-  "(TARGET_H8300S || TARGET_H8300H) && !TARGET_H8300SX
-    && h8300_move_ok (operands[0], operands[1])"
-{
-  switch (which_alternative)
-    {
-    case 0:
-      return "sub.l	%S0,%S0";
-    case 7:
-      return "clrmac";
-    case 8:
-      return "clrmac\;ldmac %1,macl";
-    case 9:
-      return "stmac	macl,%0";
-    default:
-      if (GET_CODE (operands[1]) == CONST_INT)
-	{
-	  int val = INTVAL (operands[1]);
-
-	  /* Look for constants which can be made by adding an 8-bit
-	     number to zero in one of the two low bytes.  */
-	  if (val == (val & 0xff))
-	    {
-	      operands[1] = GEN_INT ((char) val & 0xff);
-	      return "sub.l\\t%S0,%S0\;add.b\\t%1,%w0";
-	    }
-
-	  if (val == (val & 0xff00))
-	    {
-	      operands[1] = GEN_INT ((char) (val >> 8) & 0xff);
-	      return "sub.l\\t%S0,%S0\;add.b\\t%1,%x0";
-	    }
-
-	  /* Look for constants that can be obtained by subs, inc, and
-	     dec to 0.  */
-	  switch (val & 0xffffffff)
-	    {
-	    case 0xffffffff:
-	      return "sub.l\\t%S0,%S0\;subs\\t#1,%S0";
-	    case 0xfffffffe:
-	      return "sub.l\\t%S0,%S0\;subs\\t#2,%S0";
-	    case 0xfffffffc:
-	      return "sub.l\\t%S0,%S0\;subs\\t#4,%S0";
-
-	    case 0x0000ffff:
-	      return "sub.l\\t%S0,%S0\;dec.w\\t#1,%f0";
-	    case 0x0000fffe:
-	      return "sub.l\\t%S0,%S0\;dec.w\\t#2,%f0";
-
-	    case 0xffff0000:
-	      return "sub.l\\t%S0,%S0\;dec.w\\t#1,%e0";
-	    case 0xfffe0000:
-	      return "sub.l\\t%S0,%S0\;dec.w\\t#2,%e0";
-
-	    case 0x00010000:
-	      return "sub.l\\t%S0,%S0\;inc.w\\t#1,%e0";
-	    case 0x00020000:
-	      return "sub.l\\t%S0,%S0\;inc.w\\t#2,%e0";
-	    }
-	}
-    }
-   return "mov.l	%S1,%S0";
-}
-  [(set (attr "length")
-	(symbol_ref "compute_mov_length (operands)"))
-   (set_attr "cc" "set_zn,set_znv,clobber,set_znv,set_znv,set_znv,set_znv,none_0hit,none_0hit,set_znv")])
-
-(define_insn "*movsi_h8sx"
-  [(set (match_operand:SI 0 "general_operand_dst" "=r,r,Q,rQ,*a,*a,r")
-	(match_operand:SI 1 "general_operand_src" "I,P3>X,IP8>X,rQi,I,r,*a"))]
-  "TARGET_H8300SX"
-  "@
-   sub.l	%S0,%S0
-   mov.l	%S1:3,%S0
-   mov.l	%S1,%S0
-   mov.l	%S1,%S0
-   clrmac
-   clrmac\;ldmac	%1,macl
-   stmac	macl,%0"
-  [(set_attr "length_table" "*,*,short_immediate,movl,*,*,*")
-   (set_attr "length" "2,2,*,*,2,6,4")
-   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,none_0hit,none_0hit,set_znv")])
-
-(define_insn "*movsf_h8sx"
-  [(set (match_operand:SF 0 "general_operand_dst" "=r,rQ")
-	(match_operand:SF 1 "general_operand_src" "G,rQi"))]
-  "TARGET_H8300SX"
-  "@
-    sub.l	%S0,%S0
-    mov.l	%S1,%S0"
-  [(set_attr "length" "2,*")
-   (set_attr "length_table" "*,movl")
-   (set_attr "cc" "set_zn,set_znv")])
-
+(include "movepush.md")
 (include "mova.md")
-
-(define_insn "*movsf_h8300"
-  [(set (match_operand:SF 0 "general_operand_dst" "=r,r,r,o,<,r")
-	(match_operand:SF 1 "general_operand_src" "G,r,io,r,r,>"))]
-  "TARGET_H8300
-   && (register_operand (operands[0], SFmode)
-       || register_operand (operands[1], SFmode))"
-{
-  /* Copy of the movsi stuff.  */
-  unsigned int rn = -1;
-  switch (which_alternative)
-    {
-    case 0:
-      return "sub.w	%e0,%e0\;sub.w	%f0,%f0";
-    case 1:
-      if (REGNO (operands[0]) < REGNO (operands[1]))
-	return "mov.w	%e1,%e0\;mov.w	%f1,%f0";
-      else
-	return "mov.w	%f1,%f0\;mov.w	%e1,%e0";
-    case 2:
-      /* Make sure we don't trample the register we index with.  */
-      if (GET_CODE (operands[1]) == MEM)
-	{
-	  rtx inside = XEXP (operands[1], 0);
-	  if (REG_P (inside))
-	    {
-	      rn = REGNO (inside);
-	    }
-	  else if (GET_CODE (inside) == PLUS)
-	    {
-	      rtx lhs = XEXP (inside, 0);
-	      rtx rhs = XEXP (inside, 1);
-	      if (REG_P (lhs)) rn = REGNO (lhs);
-	      if (REG_P (rhs)) rn = REGNO (rhs);
-	    }
-	}
-      if (rn == REGNO (operands[0]))
-	/* Move the second word first.  */
-	return "mov.w	%f1,%f0\;mov.w	%e1,%e0";
-      else
-	/* Move the first word first.  */
-	return "mov.w	%e1,%e0\;mov.w	%f1,%f0";
-
-    case 3:
-      return "mov.w	%e1,%e0\;mov.w	%f1,%f0";
-    case 4:
-      return "mov.w	%f1,%T0\;mov.w	%e1,%T0";
-    case 5:
-      return "mov.w	%T1,%e0\;mov.w	%T1,%f0";
-    default:
-      gcc_unreachable ();
-    }
-}
-  [(set (attr "length")
-	(symbol_ref "compute_mov_length (operands)"))])
-
-(define_insn "*movsf_h8300hs"
-  [(set (match_operand:SF 0 "general_operand_dst" "=r,r,r,m,<,r")
-	(match_operand:SF 1 "general_operand_src" "G,r,im,r,r,>"))]
-  "(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX
-    && (register_operand (operands[0], SFmode)
-	|| register_operand (operands[1], SFmode))"
-  "@
-   sub.l	%S0,%S0
-   mov.l	%S1,%S0
-   mov.l	%S1,%S0
-   mov.l	%S1,%S0
-   mov.l	%S1,%S0
-   mov.l	%S1,%S0"
-  [(set (attr "length")
-	(symbol_ref "compute_mov_length (operands)"))
-   (set_attr "cc" "set_zn,set_znv,set_znv,set_znv,set_znv,set_znv")])
-
-;; ----------------------------------------------------------------------
-;; PUSH INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_insn "*pushqi1_h8300"
-  [(set (mem:QI
-	(pre_modify:HI
-	  (reg:HI SP_REG)
-	  (plus:HI (reg:HI SP_REG) (const_int -2))))
-	(match_operand:QI 0 "register_no_sp_elim_operand" "r"))]
-  "TARGET_H8300"
-  "mov.w\\t%T0,@-r7"
-  [(set_attr "length" "2")])
-
-(define_insn "*push1_h8300hs_<QHI:mode>"
-  [(set (mem:QHI
-	(pre_modify:P
-	  (reg:P SP_REG)
-	  (plus:P (reg:P SP_REG) (const_int -4))))
-	(match_operand:QHI 0 "register_no_sp_elim_operand" "r"))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mov.l\\t%S0,@-er7"
-  [(set_attr "length" "4")])
-
-
-;; ----------------------------------------------------------------------
-;; TEST INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_insn ""
-  [(set (cc0)
-	(compare (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "r,U")
-				  (const_int 1)
-				  (match_operand 1 "const_int_operand" "n,n"))
-		 (const_int 0)))]
-  "TARGET_H8300"
-  "btst	%Z1,%Y0"
-  [(set_attr "length" "2,4")
-   (set_attr "cc" "set_zn,set_zn")])
-
-(define_insn_and_split "*tst_extzv_1_n"
-  [(set (cc0)
-	(compare (zero_extract:SI (match_operand:QI 0 "general_operand_src" "r,U,mn>")
-				  (const_int 1)
-				  (match_operand 1 "const_int_operand" "n,n,n"))
-		 (const_int 0)))
-   (clobber (match_scratch:QI 2 "=X,X,&r"))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "@
-   btst\\t%Z1,%Y0
-   btst\\t%Z1,%Y0
-   #"
-  "&& reload_completed
-   && !satisfies_constraint_U (operands[0])"
-  [(set (match_dup 2)
-	(match_dup 0))
-   (parallel [(set (cc0) (compare (zero_extract:SI (match_dup 2)
-						   (const_int 1)
-						   (match_dup 1))
-				  (const_int 0)))
-	      (clobber (scratch:QI))])]
-  ""
-  [(set_attr "length" "2,8,10")
-   (set_attr "cc" "set_zn,set_zn,set_zn")])
-
-(define_insn ""
-  [(set (cc0)
-	(compare (zero_extract:HSI (match_operand:HSI 0 "register_operand" "r")
-				   (const_int 1)
-				   (match_operand 1 "const_int_operand" "n"))
-		 (const_int 0)))]
-  "(TARGET_H8300 || TARGET_H8300H || TARGET_H8300S)
-    && INTVAL (operands[1]) <= 15"
-  "btst	%Z1,%Y0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_zn")])
-
-(define_insn_and_split "*tstsi_upper_bit"
-  [(set (cc0)
-	(compare (zero_extract:SI (match_operand:SI 0 "register_operand" "r")
-				  (const_int 1)
-				  (match_operand 1 "const_int_operand" "n"))
-		 (const_int 0)))
-   (clobber (match_scratch:SI 2 "=&r"))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && INTVAL (operands[1]) >= 16"
-  "#"
-  "&& reload_completed"
-  [(set (match_dup 2)
-	(ior:SI (and:SI (match_dup 2)
-			(const_int -65536))
-		(lshiftrt:SI (match_dup 0)
-			     (const_int 16))))
-   (set (cc0)
-	(compare (zero_extract:SI (match_dup 2)
-				  (const_int 1)
-				  (match_dup 3))
-		 (const_int 0)))]
-  {
-    operands[3] = GEN_INT (INTVAL (operands[1]) - 16);
-  })
-
-(define_insn "*tstsi_variable_bit"
-  [(set (cc0)
-	(compare (zero_extract:SI (match_operand:SI 0 "register_operand" "r")
-				  (const_int 1)
-				  (and:SI (match_operand:SI 1 "register_operand" "r")
-					  (const_int 7)))
-		 (const_int 0)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "btst	%w1,%w0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_zn")])
-
-(define_insn_and_split "*tstsi_variable_bit_qi"
-  [(set (cc0)
-	(compare (zero_extract:SI (zero_extend:SI (match_operand:QI 0 "general_operand_src" "r,U,mn>"))
-				  (const_int 1)
-				  (and:SI (match_operand:SI 1 "register_operand" "r,r,r")
-					  (const_int 7)))
-		 (const_int 0)))
-   (clobber (match_scratch:QI 2 "=X,X,&r"))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "@
-   btst\\t%w1,%X0
-   btst\\t%w1,%X0
-   #"
-  "&& reload_completed
-   && !satisfies_constraint_U (operands[0])"
-  [(set (match_dup 2)
-	(match_dup 0))
-   (parallel [(set (cc0)
-		   (compare (zero_extract:SI (zero_extend:SI (match_dup 2))
-					     (const_int 1)
-					     (and:SI (match_dup 1)
-						     (const_int 7)))
-			    (const_int 0)))
-	      (clobber (scratch:QI))])]
-  ""
-  [(set_attr "length" "2,8,10")
-   (set_attr "cc" "set_zn,set_zn,set_zn")])
-
-(define_insn "*tst<mode>"
-  [(set (cc0)
-	(compare (match_operand:QHI 0 "register_operand" "r")
-		 (const_int 0)))]
-  ""
-  {
-    if (<MODE>mode == QImode)
-      return "mov.b	%X0,%X0";
-    else if (<MODE>mode == HImode)
-      return "mov.w	%T0,%T0";
-    gcc_unreachable ();
-  }
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_znv")])
-
-(define_insn "*tsthi_upper"
-  [(set (cc0)
-	(compare (and:HI (match_operand:HI 0 "register_operand" "r")
-			 (const_int -256))
-		 (const_int 0)))]
-  ""
-  "mov.b	%t0,%t0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_znv")])
-
-(define_insn "*tstsi"
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "r")
-		 (const_int 0)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mov.l	%S0,%S0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_znv")])
-
-(define_insn "*tstsi_upper"
-  [(set (cc0)
-	(compare (and:SI (match_operand:SI 0 "register_operand" "r")
-			 (const_int -65536))
-		 (const_int 0)))]
-  ""
-  "mov.w	%e0,%e0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_znv")])
-
-(define_insn "*cmpqi"
-  [(set (cc0)
-	(compare (match_operand:QI 0 "h8300_dst_operand" "rQ")
-		 (match_operand:QI 1 "h8300_src_operand" "rQi")))]
-  ""
-  "cmp.b	%X1,%X0"
-  [(set_attr "length_table" "add")
-   (set_attr "cc" "compare")])
-
-(define_insn "*cmphi_h8300_znvc"
-  [(set (cc0)
-	(compare (match_operand:HI 0 "register_operand" "r")
-		 (match_operand:HI 1 "register_operand" "r")))]
-  "TARGET_H8300"
-  "cmp.w	%T1,%T0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "compare")])
-
-(define_insn "*cmphi_h8300hs_znvc"
-  [(set (cc0)
-	(compare (match_operand:HI 0 "h8300_dst_operand" "rU,rQ")
-		 (match_operand:HI 1 "h8300_src_operand" "P3>X,rQi")))]
-  "TARGET_H8300H || TARGET_H8300S"
-{
-  switch (which_alternative)
-    {
-    case 0:
-      if (!TARGET_H8300SX)
-	return "cmp.w	%T1,%T0";
-      else
-	return "cmp.w	%T1:3,%T0";
-    case 1:
-      return "cmp.w	%T1,%T0";
-    default:
-      gcc_unreachable ();
-      }
-}
-  [(set_attr "length_table" "short_immediate,add")
-   (set_attr "cc" "compare,compare")])
-
-(define_insn "cmpsi"
-  [(set (cc0)
-	(compare (match_operand:SI 0 "h8300_dst_operand" "r,rQ")
-		 (match_operand:SI 1 "h8300_src_operand" "P3>X,rQi")))]
-  "TARGET_H8300H || TARGET_H8300S"
-{
-  switch (which_alternative)
-    {
-    case 0:
-      if (!TARGET_H8300SX)
-	return "cmp.l	%S1,%S0";
-      else
-	return "cmp.l	%S1:3,%S0";
-    case 1:
-      return "cmp.l	%S1,%S0";
-    default:
-      gcc_unreachable ();
-    }
-}
-  [(set_attr "length" "2,*")
-   (set_attr "length_table" "*,add")
-   (set_attr "cc" "compare,compare")])
-
-;; ----------------------------------------------------------------------
-;; ADD INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_expand "add<mode>3"
-  [(set (match_operand:QHSI 0 "register_operand" "")
-	(plus:QHSI (match_operand:QHSI 1 "register_operand" "")
-		   (match_operand:QHSI 2 "h8300_src_operand" "")))]
-  ""
-  "")
-
-(define_insn "*addqi3"
-  [(set (match_operand:QI 0 "h8300_dst_operand" "=rQ")
-	(plus:QI (match_operand:QI 1 "h8300_dst_operand" "%0")
-		 (match_operand:QI 2 "h8300_src_operand" "rQi")))]
-  "h8300_operands_match_p (operands)"
-  "add.b	%X2,%X0"
-  [(set_attr "length_table" "add")
-   (set_attr "cc" "set_zn")])
-
-(define_insn "*addhi3_h8300"
-  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r,r")
-	(plus:HI (match_operand:HI 1 "register_operand" "%0,0,0,0,0")
-		 (match_operand:HI 2 "h8300_src_operand" "L,N,J,n,r")))]
-  "TARGET_H8300"
-  "@
-   adds	%2,%T0
-   subs	%G2,%T0
-   add.b	%t2,%t0
-   add.b	%s2,%s0\;addx	%t2,%t0
-   add.w	%T2,%T0"
-  [(set_attr "length" "2,2,2,4,2")
-   (set_attr "cc" "none_0hit,none_0hit,clobber,clobber,set_zn")])
-
-;; This splitter is very important to make the stack adjustment
-;; interrupt-safe.  The combination of add.b and addx is unsafe!
-;;
-;; We apply this split after the peephole2 pass so that we won't end
-;; up creating too many adds/subs when a scratch register is
-;; available, which is actually a common case because stack unrolling
-;; tends to happen immediately after a function call.
-
-(define_split
-  [(set (match_operand:HI 0 "stack_pointer_operand" "")
-	(plus:HI (match_dup 0)
-		 (match_operand 1 "const_int_gt_2_operand" "")))]
-  "TARGET_H8300 && epilogue_completed"
-  [(const_int 0)]
-  {
-    split_adds_subs (HImode, operands);
-    DONE;
-  })
-
-(define_peephole2
-  [(match_scratch:HI 2 "r")
-   (set (match_operand:HI 0 "stack_pointer_operand" "")
-	(plus:HI (match_dup 0)
-		 (match_operand:HI 1 "const_int_ge_8_operand" "")))]
-  "TARGET_H8300"
-  [(set (match_dup 2)
-	(match_dup 1))
-   (set (match_dup 0)
-	(plus:HI (match_dup 0)
-		 (match_dup 2)))]
-  "")
-
-(define_insn "*addhi3_h8300hs"
-  [(set (match_operand:HI 0 "register_operand" "=r,r,r,r,r")
-	(plus:HI (match_operand:HI 1 "register_operand" "%0,0,0,0,0")
-		 (match_operand:HI 2 "h8300_src_operand" "L,N,J,n,r")))]
-  "(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX"
-  "@
-   adds	%2,%S0
-   subs	%G2,%S0
-   add.b	%t2,%t0
-   add.w	%T2,%T0
-   add.w	%T2,%T0"
-  [(set_attr "length" "2,2,2,4,2")
-   (set_attr "cc" "none_0hit,none_0hit,clobber,set_zn,set_zn")])
-
-(define_insn "*add<mode>3_incdec"
-  [(set (match_operand:HSI 0 "register_operand" "=r,r")
-	(unspec:HSI [(match_operand:HSI 1 "register_operand" "0,0")
-		     (match_operand:HSI 2 "incdec_operand" "M,O")]
-		    UNSPEC_INCDEC))]
-  "TARGET_H8300H || TARGET_H8300S"
-  {
-    if (which_alternative == 0)
-      return <MODE>mode == HImode ? "inc.w\t%2,%T0" : "inc.l\t%2,%S0";
-    else if (which_alternative == 1)
-      return <MODE>mode == HImode ? "dec.w\t%G2,%T0" : "dec.l\t%G2,%S0";
-    gcc_unreachable ();
-   }
-  [(set_attr "length" "2,2")
-   (set_attr "cc" "set_zn,set_zn")])
-
-(define_insn "*addhi3_h8sx"
-  [(set (match_operand:HI 0 "h8300_dst_operand" "=rU,rU,r,rQ")
-	(plus:HI (match_operand:HI 1 "h8300_dst_operand" "%0,0,0,0")
-		 (match_operand:HI 2 "h8300_src_operand" "P3>X,P3<X,J,rQi")))]
-  "TARGET_H8300SX && h8300_operands_match_p (operands)"
-  "@
-   add.w	%T2:3,%T0
-   sub.w	%G2:3,%T0
-   add.b	%t2,%t0
-   add.w	%T2,%T0"
-  [(set_attr "length_table" "short_immediate,short_immediate,*,add")
-   (set_attr "length" "*,*,2,*")
-   (set_attr "cc" "set_zn")])
-
-(define_split
-  [(set (match_operand:HI 0 "register_operand" "")
-	(plus:HI (match_dup 0)
-		 (match_operand:HI 1 "two_insn_adds_subs_operand" "")))]
-  ""
-  [(const_int 0)]
-  {
-    split_adds_subs (HImode, operands);
-    DONE;
-  })
-
-
-(define_insn "*addsi_h8300"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(plus:SI (match_operand:SI 1 "register_operand" "%0,0")
-		 (match_operand:SI 2 "h8300_src_operand" "n,r")))]
-  "TARGET_H8300"
-{
-  return output_plussi (operands);
-}
-  [(set (attr "length")
-	(symbol_ref "compute_plussi_length (operands)"))
-   (set (attr "cc")
-	(symbol_ref "compute_plussi_cc (operands)"))])
-
-(define_insn "*addsi_h8300hs"
-  [(set (match_operand:SI 0 "h8300_dst_operand" "=rQ,rQ")
-	(plus:SI (match_operand:SI 1 "h8300_dst_operand" "%0,0")
-		 (match_operand:SI 2 "h8300_src_operand" "i,rQ")))]
-  "(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)"
-{
-  return output_plussi (operands);
-}
-  [(set (attr "length")
-	(symbol_ref "compute_plussi_length (operands)"))
-   (set (attr "cc")
-	(symbol_ref "compute_plussi_cc (operands)"))])
-
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(plus:SI (match_dup 0)
-		 (match_operand:SI 1 "two_insn_adds_subs_operand" "")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  [(const_int 0)]
-  {
-    split_adds_subs (SImode, operands);
-    DONE;
-  })
-
-;; ----------------------------------------------------------------------
-;; SUBTRACT INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_expand "sub<mode>3"
-  [(set (match_operand:QHSI 0 "register_operand" "")
-	(minus:QHSI (match_operand:QHSI 1 "register_operand" "")
-		    (match_operand:QHSI 2 "h8300_src_operand" "")))]
-  ""
-  {
-    if (TARGET_H8300 && <MODE>mode == SImode)
-      operands[2] = force_reg (SImode, operands[2]);
-  })
-
-(define_insn "*subqi3"
-  [(set (match_operand:QI 0 "h8300_dst_operand" "=rQ")
-	(minus:QI (match_operand:QI 1 "h8300_dst_operand" "0")
-		  (match_operand:QI 2 "h8300_dst_operand" "rQ")))]
-  "h8300_operands_match_p (operands)"
-  "sub.b	%X2,%X0"
-  [(set_attr "length_table" "add")
-   (set_attr "cc" "set_zn")])
-
-(define_insn "*subhi3_h8300"
-  [(set (match_operand:HI 0 "register_operand" "=r,r")
-	(minus:HI (match_operand:HI 1 "register_operand" "0,0")
-		  (match_operand:HI 2 "h8300_src_operand" "r,n")))]
-  "TARGET_H8300"
-  "@
-   sub.w	%T2,%T0
-   add.b	%E2,%s0\;addx	%F2,%t0"
-  [(set_attr "length" "2,4")
-   (set_attr "cc" "set_zn,clobber")])
-
-(define_insn "*sub<mode>3_h8300hs"
-  [(set (match_operand:HSI 0 "h8300_dst_operand" "=rQ,rQ")
-	(minus:HSI (match_operand:HSI 1 "h8300_dst_operand" "0,0")
-		   (match_operand:HSI 2 "h8300_src_operand" "rQ,i")))]
-  "(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)"
-  { 
-    if (<MODE>mode == HImode)
-      return "sub.w	%T2,%T0";
-    else if (<MODE>mode == SImode)
-      return "sub.l	%S2,%S0";
-    gcc_unreachable ();
-  }
-  [(set_attr "length_table" "add")
-   (set_attr "cc" "set_zn")])
-
-(define_insn "*subsi3_h8300"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(minus:SI (match_operand:SI 1 "register_operand" "0")
-		  (match_operand:SI 2 "register_operand" "r")))]
-  "TARGET_H8300"
-  "sub.w	%f2,%f0\;subx	%y2,%y0\;subx	%z2,%z0"
-  [(set_attr "length" "6")])
-
-
-;; ----------------------------------------------------------------------
-;; MULTIPLY INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-;; Note that the H8/300 can only handle umulqihi3.
-
-(define_expand "mulqihi3"
-  [(set (match_operand:HI 0 "register_operand" "")
-	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" ""))
-		 ;; intentionally-mismatched modes
-		 (match_operand:QI 2 "reg_or_nibble_operand" "")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  {
-    if (GET_MODE (operands[2]) != VOIDmode)
-      operands[2] = gen_rtx_SIGN_EXTEND (HImode, operands[2]);
-  })
-
-(define_insn "*mulqihi3_const"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (match_operand:QI 2 "nibble_operand" "IP4>X")))]
-  "TARGET_H8300SX"
-  "mulxs.b	%X2,%T0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_insn "*mulqihi3"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (sign_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mulxs.b	%X2,%T0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_expand "mulhisi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" ""))
-		 ;; intentionally-mismatched modes
-		 (match_operand:HI 2 "reg_or_nibble_operand" "")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  {
-    if (GET_MODE (operands[2]) != VOIDmode)
-      operands[2] = gen_rtx_SIGN_EXTEND (SImode, operands[2]);
-  })
-
-(define_insn "*mulhisi3_const"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (match_operand:SI 2 "nibble_operand" "IP4>X")))]
-  "TARGET_H8300SX"
-  "mulxs.w	%T2,%S0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_insn "*mulhisi3"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (sign_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mulxs.w	%T2,%S0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_expand "umulqihi3"
-  [(set (match_operand:HI 0 "register_operand" "")
-	(mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" ""))
-		 ;; intentionally-mismatched modes
-		 (match_operand:QI 2 "reg_or_nibble_operand" "")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  {
-    if (GET_MODE (operands[2]) != VOIDmode)
-      operands[2] = gen_rtx_ZERO_EXTEND (HImode, operands[2]);
-  })
-
-(define_insn "*umulqihi3_const"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (match_operand:QI 2 "nibble_operand" "IP4>X")))]
-  "TARGET_H8300SX"
-  "mulxu.b	%X2,%T0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_insn "*umulqihi3"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (zero_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
-  ""
-  "mulxu.b	%X2,%T0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "none_0hit")])
-
-(define_expand "umulhisi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(mult:SI (zero_extend:SI (match_operand:HI 1 "register_operand" ""))
-		 ;; intentionally-mismatched modes
-		 (match_operand:HI 2 "reg_or_nibble_operand" "")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  {
-    if (GET_MODE (operands[2]) != VOIDmode)
-      operands[2] = gen_rtx_ZERO_EXTEND (SImode, operands[2]);
-  })
-
-(define_insn "*umulhisi3_const"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (zero_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (match_operand:SI 2 "nibble_operand" "IP4>X")))]
-  "TARGET_H8300SX"
-  "mulxu.w	%T2,%S0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_insn "*umulhisi3"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (zero_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (zero_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mulxu.w	%T2,%S0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "none_0hit")])
-
-;; We could have used mulu.[wl] here, but mulu.[lw] is only available
-;; on a H8SX with a multiplier, whereas muls.w seems to be available
-;; on all H8SX variants.
-
-(define_insn "mul<mode>3"
-  [(set (match_operand:HSI 0 "register_operand" "=r")
-        (mult:HSI (match_operand:HSI 1 "register_operand" "%0")
-		  (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X")))]
-  "TARGET_H8300SX"
-  { return <MODE>mode == HImode ? "muls.w\\t%T2,%T0" : "muls.l\\t%S2,%S0"; }
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_insn "smulsi3_highpart"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(truncate:SI
-	 (lshiftrt:DI
-	  (mult:DI
-	   (sign_extend:DI (match_operand:SI 1 "register_operand" "%0"))
-	   (sign_extend:DI (match_operand:SI 2 "reg_or_nibble_operand" "r IP4>X")))
-	  (const_int 32))))]
-  "TARGET_H8300SXMUL"
-  "muls/u.l\\t%S2,%S0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_insn "umulsi3_highpart"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(truncate:SI
-	  (ashiftrt:DI
-	    (mult:DI
-	      (zero_extend:DI (match_operand:SI 1 "register_operand" "%0"))
-	      (zero_extend:DI (match_operand:SI 2 "reg_or_nibble_operand" "r IP4>X")))
-	    (const_int 32))))]
-  "TARGET_H8300SX"
-  "mulu/u.l\\t%S2,%S0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "none_0hit")])
-
-;; This is a "bridge" instruction.  Combine can't cram enough insns
-;; together to crate a MAC instruction directly, but it can create
-;; this instruction, which then allows combine to create the real
-;; MAC insn.
-;;
-;; Unfortunately, if combine doesn't create a MAC instruction, this
-;; insn must generate reasonably correct code.  Egad.
-
-(define_insn ""
-  [(set (match_operand:SI 0 "register_operand" "=a")
-	(mult:SI
-	  (sign_extend:SI
-	    (mem:HI (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
-	  (sign_extend:SI
-	    (mem:HI (post_inc:SI (match_operand:SI 2 "register_operand" "r"))))))]
-  "TARGET_MAC"
-  "clrmac\;mac	@%2+,@%1+"
-  [(set_attr "length" "6")
-   (set_attr "cc" "none_0hit")])
-
-(define_insn ""
-  [(set (match_operand:SI 0 "register_operand" "=a")
-	(plus:SI (mult:SI
-	  (sign_extend:SI (mem:HI
-	    (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
-	  (sign_extend:SI (mem:HI
-	    (post_inc:SI (match_operand:SI 2 "register_operand" "r")))))
-	      (match_operand:SI 3 "register_operand" "0")))]
-  "TARGET_MAC"
-  "mac	@%2+,@%1+"
-  [(set_attr "length" "4")
-   (set_attr "cc" "none_0hit")])
-
-;; ----------------------------------------------------------------------
-;; DIVIDE/MOD INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_insn "udiv<mode>3"
-  [(set (match_operand:HSI 0 "register_operand" "=r")
-	(udiv:HSI (match_operand:HSI 1 "register_operand" "0")
-		  (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X")))]
-  "TARGET_H8300SX"
-  { return <MODE>mode == HImode ? "divu.w\\t%T2,%T0" : "divu.l\\t%S2,%S0"; }
-  [(set_attr "length" "4")])
-
-(define_insn "div<mode>3"
-  [(set (match_operand:HSI 0 "register_operand" "=r")
-	(div:HSI (match_operand:HSI 1 "register_operand" "0")
-		 (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X")))]
-  "TARGET_H8300SX"
-  { return <MODE>mode == HImode ? "divs.w\\t%T2,%T0" : "divs.l\\t%S2,%S0"; }
-  [(set_attr "length" "4")])
-
-(define_insn "udivmodqi4"
-  [(set (match_operand:QI 0 "register_operand" "=r")
-	(truncate:QI
-	  (udiv:HI
-	    (match_operand:HI 1 "register_operand" "0")
-	    (zero_extend:HI (match_operand:QI 2 "register_operand" "r")))))
-   (set (match_operand:QI 3 "register_operand" "=r")
-	(truncate:QI
-	  (umod:HI
-	    (match_dup 1)
-	    (zero_extend:HI (match_dup 2)))))]
-  ""
-{
-  if (find_reg_note (insn, REG_UNUSED, operands[3]))
-    return "divxu.b\\t%X2,%T0";
-  else
-    return "divxu.b\\t%X2,%T0\;mov.b\\t%t0,%s3";
-}
-  [(set_attr "length" "4")])
-
-(define_insn "divmodqi4"
-  [(set (match_operand:QI 0 "register_operand" "=r")
-	(truncate:QI
-	  (div:HI
-	    (match_operand:HI 1 "register_operand" "0")
-	    (sign_extend:HI (match_operand:QI 2 "register_operand" "r")))))
-   (set (match_operand:QI 3 "register_operand" "=r")
-	(truncate:QI
-	  (mod:HI
-	    (match_dup 1)
-	    (sign_extend:HI (match_dup 2)))))]
-  "TARGET_H8300H || TARGET_H8300S"
-{
-  if (find_reg_note (insn, REG_UNUSED, operands[3]))
-    return "divxs.b\\t%X2,%T0";
-  else
-    return "divxs.b\\t%X2,%T0\;mov.b\\t%t0,%s3";
-}
-  [(set_attr "length" "6")])
-
-(define_insn "udivmodhi4"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(truncate:HI
-	  (udiv:SI
-	    (match_operand:SI 1 "register_operand" "0")
-	    (zero_extend:SI (match_operand:HI 2 "register_operand" "r")))))
-   (set (match_operand:HI 3 "register_operand" "=r")
-	(truncate:HI
-	  (umod:SI
-	    (match_dup 1)
-	    (zero_extend:SI (match_dup 2)))))]
-  "TARGET_H8300H || TARGET_H8300S"
-{
-  if (find_reg_note (insn, REG_UNUSED, operands[3]))
-    return "divxu.w\\t%T2,%S0";
-  else
-    return "divxu.w\\t%T2,%S0\;mov.w\\t%e0,%f3";
-}
-  [(set_attr "length" "4")])
-
-(define_insn "divmodhi4"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(truncate:HI
-	  (div:SI
-	    (match_operand:SI 1 "register_operand" "0")
-	    (sign_extend:SI (match_operand:HI 2 "register_operand" "r")))))
-   (set (match_operand:HI 3 "register_operand" "=r")
-	(truncate:HI
-	  (mod:SI
-	    (match_dup 1)
-	    (sign_extend:SI (match_dup 2)))))]
-  "TARGET_H8300H || TARGET_H8300S"
-{
-  if (find_reg_note (insn, REG_UNUSED, operands[3]))
-    return "divxs.w\\t%T2,%S0";
-  else
-    return "divxs.w\\t%T2,%S0\;mov.w\\t%e0,%f3";
-}
-  [(set_attr "length" "6")])
-
-;; ----------------------------------------------------------------------
-;; AND INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_insn "bclrqi_msx"
-  [(set (match_operand:QI 0 "bit_register_indirect_operand" "=WU")
-	(and:QI (match_operand:QI 1 "bit_register_indirect_operand" "%0")
-		(match_operand:QI 2 "single_zero_operand" "Y0")))]
-  "TARGET_H8300SX && rtx_equal_p (operands[0], operands[1])"
-  "bclr\\t%W2,%0"
-  [(set_attr "length" "8")])
-
-(define_split
-  [(set (match_operand:HI 0 "bit_register_indirect_operand")
-	(and:HI (match_operand:HI 1 "bit_register_indirect_operand")
-		(match_operand:HI 2 "single_zero_operand")))]
-  "TARGET_H8300SX"
-  [(set (match_dup 0)
-	(and:QI (match_dup 1)
-		(match_dup 2)))]
-  {
-    if (abs (INTVAL (operands[2])) > 0xFF)
-      {
-	operands[0] = adjust_address (operands[0], QImode, 0);
-	operands[1] = adjust_address (operands[1], QImode, 0);
-	operands[2] = GEN_INT ((INTVAL (operands[2])) >> 8);
-      }
-    else
-      {
-	operands[0] = adjust_address (operands[0], QImode, 1);
-	operands[1] = adjust_address (operands[1], QImode, 1);
-      }
-  })
-
-(define_insn "bclrhi_msx"
-  [(set (match_operand:HI 0 "bit_register_indirect_operand" "=m")
-	(and:HI (match_operand:HI 1 "bit_register_indirect_operand" "%0")
-		(match_operand:HI 2 "single_zero_operand" "Y0")))]
-  "TARGET_H8300SX"
-  "bclr\\t%W2,%0"
-  [(set_attr "length" "8")])
-
-(define_insn "*andqi3_2"
-  [(set (match_operand:QI 0 "bit_operand" "=U,rQ,r")
-	(and:QI (match_operand:QI 1 "bit_operand" "%0,0,WU")
-		(match_operand:QI 2 "h8300_src_operand" "Y0,rQi,IP1>X")))]
-  "TARGET_H8300SX"
-  "@
-   bclr\\t %W2,%R0
-   and  %X2,%X0
-   bfld %2,%1,%R0"
-  [(set_attr "length" "8,*,8")
-   (set_attr "length_table" "*,logicb,*")
-   (set_attr "cc" "none_0hit,set_znv,none_0hit")])
-
-(define_insn "andqi3_1"
-  [(set (match_operand:QI 0 "bit_operand" "=U,r")
-	(and:QI (match_operand:QI 1 "bit_operand" "%0,0")
-		(match_operand:QI 2 "h8300_src_operand" "Y0,rn")))]
-  "register_operand (operands[0], QImode)
-   || single_zero_operand (operands[2], QImode)"
-  "@
-   bclr %W2,%R0
-   and  %X2,%X0"
-  [(set_attr "length" "2,8")
-   (set_attr "cc" "none_0hit,set_znv")])
-
-(define_expand "and<mode>3"
-  [(set (match_operand:QHSI 0 "register_operand" "")
-	(and:QHSI (match_operand:QHSI 1 "register_operand" "")
-		  (match_operand:QHSI 2 "h8300_src_operand" "")))]
-  ""
-  "")
-
-(define_insn "*andor<mode>3"
-  [(set (match_operand:QHSI 0 "register_operand" "=r")
-	(ior:QHSI (and:QHSI (match_operand:QHSI 2 "register_operand" "r")
-			    (match_operand:QHSI 3 "single_one_operand" "n"))
-		  (match_operand:QHSI 1 "register_operand" "0")))]
-  "(<MODE>mode == QImode
-    || <MODE>mode == HImode
-    || (<MODE>mode == SImode
-	&& (INTVAL (operands[3]) & 0xffff) != 0))"
-  {
-    if (<MODE>mode == QImode)
-      return "bld\\t%V3,%X2\;bor\\t%V3,%X0\;bst\\t%V3,%X0";
-
-    if (<MODE>mode == HImode)
-      {
-	operands[3] = GEN_INT (INTVAL (operands[3]) & 0xffff);
-	if (INTVAL (operands[3]) > 128)
-	  {
-	    operands[3] = GEN_INT (INTVAL (operands[3]) >> 8);
-	    return "bld\\t%V3,%t2\;bor\\t%V3,%t0\;bst\\t%V3,%t0";
-	  }
-	return "bld\\t%V3,%s2\;bor\\t%V3,%s0\;bst\\t%V3,%s0";
-      }
-
-    if (<MODE>mode == SImode)
-      {
-	operands[3] = GEN_INT (INTVAL (operands[3]) & 0xffff);
-	if (INTVAL (operands[3]) > 128)
-	  {
-	    operands[3] = GEN_INT (INTVAL (operands[3]) >> 8);
-	    return "bld\\t%V3,%x2\;bor\\t%V3,%x0\;bst\\t%V3,%x0";
-	  }
-	return "bld\\t%V3,%w2\;bor\\t%V3,%w0\;bst\\t%V3,%w0";
-      }
-
-    gcc_unreachable ();
-	
-  }
-  [(set_attr "length" "6")])
-
-(define_insn "*andorsi3_shift_8"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (and:SI (ashift:SI (match_operand:SI 2 "register_operand" "r")
-				   (const_int 8))
-			(const_int 65280))
-		(match_operand:SI 1 "register_operand" "0")))]
-  ""
-  "or.b\\t%w2,%x0"
-  [(set_attr "length" "2")])
-
-;; ----------------------------------------------------------------------
-;; OR/XOR INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_insn "b<code>qi_msx"
-  [(set (match_operand:QI 0 "bit_register_indirect_operand" "=WU")
-	(ors:QI (match_operand:QI 1 "bit_register_indirect_operand" "%0")
-		(match_operand:QI 2 "single_one_operand" "Y2")))]
-  "TARGET_H8300SX && rtx_equal_p (operands[0], operands[1])"
-  { return <CODE> == IOR ? "bset\\t%V2,%0" : "bnot\\t%V2,%0"; }
-  [(set_attr "length" "8")])
-
-(define_insn "b<code>hi_msx"
-  [(set (match_operand:HI 0 "bit_register_indirect_operand" "=m")
-	(ors:HI (match_operand:HI 1 "bit_register_indirect_operand" "%0")
-		(match_operand:HI 2 "single_one_operand" "Y2")))]
-  "TARGET_H8300SX"
-  { return <CODE> == IOR ? "bset\\t%V2,%0" : "bnot\\t%V2,%0"; }
-  [(set_attr "length" "8")])
-
-(define_insn "<code>qi3_1"
-  [(set (match_operand:QI 0 "bit_operand" "=U,rQ")
-	(ors:QI (match_operand:QI 1 "bit_operand" "%0,0")
-		(match_operand:QI 2 "h8300_src_operand" "Y2,rQi")))]
-  "TARGET_H8300SX || register_operand (operands[0], QImode)
-   || single_one_operand (operands[2], QImode)"
-  {
-    if (which_alternative == 0)
-      return <CODE> == IOR ? "bset\\t%V2,%R0" : "bnot\\t%V2,%R0"; 
-    else if (which_alternative == 1)
-      return <CODE> == IOR ? "or\\t%X2,%X0" : "xor\\t%X2,%X0";
-    gcc_unreachable ();
-  }
-  [(set_attr "length" "8,*")
-   (set_attr "length_table" "*,logicb")
-   (set_attr "cc" "none_0hit,set_znv")])
-
-(define_expand "<code><mode>3"
-  [(set (match_operand:QHSI 0 "register_operand" "")
-	(ors:QHSI (match_operand:QHSI 1 "register_operand" "")
-		  (match_operand:QHSI 2 "h8300_src_operand" "")))]
-  ""
-  "")
-
-;; ----------------------------------------------------------------------
-;; {AND,IOR,XOR}{HI3,SI3} PATTERNS
-;; ----------------------------------------------------------------------
-
-(define_insn "*logical<mode>3"
-  [(set (match_operand:HSI 0 "h8300_dst_operand" "=rQ")
-	(match_operator:HSI 3 "bit_operator"
-	  [(match_operand:HSI 1 "h8300_dst_operand" "%0")
-	   (match_operand:HSI 2 "h8300_src_operand" "rQi")]))]
-  "h8300_operands_match_p (operands)"
-  { return output_logical_op (<MODE>mode, operands); }
-  [(set (attr "length")
-	(symbol_ref "compute_logical_op_length (<MODE>mode, operands)"))
-   (set (attr "cc")
-	(symbol_ref "compute_logical_op_cc (<MODE>mode, operands)"))])
-
-;; ----------------------------------------------------------------------
-;; NEGATION INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_expand "neg<mode>2"
-  [(set (match_operand:QHSIF 0 "register_operand" "")
-	(neg:QHSIF (match_operand:QHSIF 1 "register_operand" "")))]
-  ""
-  {
-    enum machine_mode mode = <MODE>mode;
-    if (TARGET_H8300)
-      {
-	if (mode == QImode || mode == SFmode)
-	  ;
-	else if (mode == HImode)
-	  {
-	    emit_insn (gen_neghi2_h8300 (operands[0], operands[1]));
-	    DONE;
-	  }
-	else if (mode == SImode)
-	  {
-	    emit_insn (gen_negsi2_h8300 (operands[0], operands[1]));
-	    DONE;
-	  }
-      }
-  })
-
-(define_insn "*negqi2"
-  [(set (match_operand:QI 0 "h8300_dst_operand" "=rQ")
-	(neg:QI (match_operand:QI 1 "h8300_dst_operand" "0")))]
-  ""
-  "neg	%X0"
-  [(set_attr "length_table" "unary")
-   (set_attr "cc" "set_zn")])
-
-(define_expand "neg<mode>2_h8300"
-  [(set (match_dup 2)
-	(not:HSI (match_operand:HSI 1 "register_operand" "")))
-   (set (match_dup 2) (plus:HSI (match_dup 2) (const_int 1)))
-   (set (match_operand:HSI 0 "register_operand" "")
-	(match_dup 2))]
-  ""
-  {
-    operands[2] = gen_reg_rtx (<MODE>mode);
-  })
-
-(define_insn "*neghi2_h8300hs"
-  [(set (match_operand:HI 0 "h8300_dst_operand" "=rQ")
-	(neg:HI (match_operand:HI 1 "h8300_dst_operand" "0")))]
-  "(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)"
-  "neg.w	%T0"
-  [(set_attr "length_table" "unary")
-   (set_attr "cc" "set_zn")])
-
-(define_insn "*negsi2_h8300hs"
-  [(set (match_operand:SI 0 "h8300_dst_operand" "=rQ")
-	(neg:SI (match_operand:SI 1 "h8300_dst_operand" "0")))]
-  "(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)"
-  "neg.l	%S0"
-  [(set_attr "length_table" "unary")
-   (set_attr "cc" "set_zn")])
-
-(define_insn "*negsf2_h8300"
-  [(set (match_operand:SF 0 "register_operand" "=r")
-	(neg:SF (match_operand:SF 1 "register_operand" "0")))]
-  "TARGET_H8300"
-  "xor.b\\t#128,%z0"
-  [(set_attr "length" "2")])
-
-(define_insn "*negsf2_h8300hs"
-  [(set (match_operand:SF 0 "register_operand" "=r")
-	(neg:SF (match_operand:SF 1 "register_operand" "0")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "xor.w\\t#32768,%e0"
-  [(set_attr "length" "4")])
-
-;; ----------------------------------------------------------------------
-;; ABSOLUTE VALUE INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_expand "abssf2"
-  [(set (match_operand:SF 0 "register_operand" "")
-	(abs:SF (match_operand:SF 1 "register_operand" "")))]
-  ""
-  "")
-
-(define_insn "*abssf2_h8300"
-  [(set (match_operand:SF 0 "register_operand" "=r")
-	(abs:SF (match_operand:SF 1 "register_operand" "0")))]
-  "TARGET_H8300"
-  "and.b\\t#127,%z0"
-  [(set_attr "length" "2")])
-
-(define_insn "*abssf2_h8300hs"
-  [(set (match_operand:SF 0 "register_operand" "=r")
-	(abs:SF (match_operand:SF 1 "register_operand" "0")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "and.w\\t#32767,%e0"
-  [(set_attr "length" "4")])
-
-;; ----------------------------------------------------------------------
-;; NOT INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_expand "one_cmpl<mode>2"
-  [(set (match_operand:QHSI 0 "register_operand" "")
-	(not:QHSI (match_operand:QHSI 1 "register_operand" "")))]
-  ""
-  "")
-
-(define_insn "*one_cmplqi2"
-  [(set (match_operand:QI 0 "h8300_dst_operand" "=rQ")
-	(not:QI (match_operand:QI 1 "h8300_dst_operand" "0")))]
-  ""
-  "not	%X0"
-  [(set_attr "length_table" "unary")
-   (set_attr "cc" "set_znv")])
-
-(define_insn "*one_cmplhi2_h8300"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(not:HI (match_operand:HI 1 "register_operand" "0")))]
-  "TARGET_H8300"
-  "not	%s0\;not	%t0"
-  [(set_attr "length" "4")])
-
-(define_insn "*one_cmplhi2_h8300hs"
-  [(set (match_operand:HI 0 "h8300_dst_operand" "=rQ")
-	(not:HI (match_operand:HI 1 "h8300_dst_operand" "0")))]
-  "(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)"
-  "not.w	%T0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length_table" "unary")])
-
-(define_insn "*one_cmplsi2_h8300"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(not:SI (match_operand:SI 1 "register_operand" "0")))]
-  "TARGET_H8300"
-  "not	%w0\;not	%x0\;not	%y0\;not	%z0"
-  [(set_attr "length" "8")])
-
-(define_insn "*one_cmplsi2_h8300hs"
-  [(set (match_operand:SI 0 "h8300_dst_operand" "=rQ")
-	(not:SI (match_operand:SI 1 "h8300_dst_operand" "0")))]
-  "(TARGET_H8300H || TARGET_H8300S) && h8300_operands_match_p (operands)"
-  "not.l	%S0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length_table" "unary")])
-
-;; ----------------------------------------------------------------------
-;; JUMP INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-;; Conditional jump instructions
-
-(define_expand "cbranchqi4"
-  [(use (match_operator 0 "ordered_comparison_operator"
-         [(match_operand:QI 1 "h8300_dst_operand" "")
-          (match_operand:QI 2 "h8300_src_operand" "")]))
-   (use (match_operand 3 ""))]
-  ""
-  {
-    h8300_expand_branch (operands);
-    DONE;
-  })
-
-(define_expand "cbranchhi4"
-  [(use (match_operator 0 "ordered_comparison_operator"
-         [(match_operand:HI 1 "h8300_dst_operand" "")
-          (match_operand:HI 2 "h8300_src_operand" "")]))
-   (use (match_operand 3 ""))]
-  ""
-  {
-    /* Force operand1 into a register if we're compiling
-       for the H8/300.  */
-    if ((GET_CODE (operands[2]) != REG && operands[2] != const0_rtx)
-	&& TARGET_H8300)
-      operands[2] = force_reg (HImode, operands[2]);
-    h8300_expand_branch (operands);
-    DONE;
-  })
-
-(define_expand "cbranchsi4"
-  [(use (match_operator 0 "ordered_comparison_operator"
-         [(match_operand:SI 1 "h8300_dst_operand" "")
-          (match_operand:SI 2 "h8300_src_operand" "")]))
-   (use (match_operand 3 ""))]
-  "TARGET_H8300H || TARGET_H8300S"
-  {
-    h8300_expand_branch (operands);
-    DONE;
-  })
-
-(define_insn "branch_true"
-  [(set (pc)
-	(if_then_else (match_operator 1 "comparison_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 0 "" ""))
-		      (pc)))]
-  ""
-{
-  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
-      && (GET_CODE (operands[1]) == GT
-	  || GET_CODE (operands[1]) == GE
-	  || GET_CODE (operands[1]) == LE
-	  || GET_CODE (operands[1]) == LT))
-    {
-      cc_status.flags &= ~CC_OVERFLOW_UNUSABLE;
-      return 0;
-    }
-
-  if (get_attr_length (insn) == 2)
-    return "b%j1	%l0";
-  else if (get_attr_length (insn) == 4)
-    return "b%j1	%l0:16";
-  else
-    return "b%k1	.Lh8BR%=\;jmp	@%l0\\n.Lh8BR%=:";
-}
- [(set_attr "type" "branch")
-   (set_attr "cc" "none")])
-
-(define_insn "branch_false"
-  [(set (pc)
-	(if_then_else (match_operator 1 "comparison_operator"
-		       [(cc0) (const_int 0)])
-		      (pc)
-		      (label_ref (match_operand 0 "" ""))))]
-  ""
-{
-  if ((cc_status.flags & CC_OVERFLOW_UNUSABLE) != 0
-      && (GET_CODE (operands[1]) == GT
-	  || GET_CODE (operands[1]) == GE
-	  || GET_CODE (operands[1]) == LE
-	  || GET_CODE (operands[1]) == LT))
-    {
-      cc_status.flags &= ~CC_OVERFLOW_UNUSABLE;
-      return 0;
-    }
-
-  if (get_attr_length (insn) == 2)
-    return "b%k1	%l0";
-  else if (get_attr_length (insn) == 4)
-    return "b%k1	%l0:16";
-  else
-    return "b%j1	.Lh8BR%=\;jmp	@%l0\\n.Lh8BR%=:";
-}
-  [(set_attr "type" "branch")
-   (set_attr "cc" "none")])
-
-(define_insn "*brabc"
-  [(set (pc)
-	(if_then_else (eq (zero_extract (match_operand:QI 1 "bit_memory_operand" "WU")
-					(const_int 1)
-					(match_operand:QI 2 "immediate_operand" "n"))
-			  (const_int 0))
-		      (label_ref (match_operand 0 "" ""))
-		      (pc)))]
-  "TARGET_H8300SX"
-{
-  switch (get_attr_length (insn)
-	  - h8300_insn_length_from_table (insn, operands))
-    {
-    case 2:
-      return "bra/bc	%2,%R1,%l0";
-    case 4:
-      return "bra/bc	%2,%R1,%l0:16";
-    default:
-      return "bra/bs	%2,%R1,.Lh8BR%=\;jmp	@%l0\\n.Lh8BR%=:";
-    }
-}
-  [(set_attr "type" "bitbranch")
-   (set_attr "length_table" "bitbranch")
-   (set_attr "cc" "none")])
-
-(define_insn "*brabs"
-  [(set (pc)
-	(if_then_else (ne (zero_extract (match_operand:QI 1 "bit_memory_operand" "WU")
-					(const_int 1)
-					(match_operand:QI 2 "immediate_operand" "n"))
-			  (const_int 0))
-		      (label_ref (match_operand 0 "" ""))
-		      (pc)))]
-  "TARGET_H8300SX"
-{
-  switch (get_attr_length (insn)
-	  - h8300_insn_length_from_table (insn, operands))
-    {
-    case 2:
-      return "bra/bs	%2,%R1,%l0";
-    case 4:
-      return "bra/bs	%2,%R1,%l0:16";
-    default:
-      return "bra/bc	%2,%R1,.Lh8BR%=\;jmp	@%l0\\n.Lh8BR%=:";
-    }
-}
-  [(set_attr "type" "bitbranch")
-   (set_attr "length_table" "bitbranch")
-   (set_attr "cc" "none")])
-
-;; Unconditional and other jump instructions.
-
-(define_insn "jump"
-  [(set (pc)
-	(label_ref (match_operand 0 "" "")))]
-  ""
-{
-  if (final_sequence != 0)
-    {
-      if (get_attr_length (insn) == 2)
-	return "bra/s	%l0";
-      else
-	{
-	  /* The branch isn't short enough to use bra/s.  Output the
-	     branch and delay slot in their normal order.
-
-	     If this is a backward branch, it will now be branching two
-	     bytes further than previously thought.  The length-based
-	     test for bra vs. jump is very conservative though, so the
-	     branch will still be within range.  */
-	  rtx_sequence *seq;
-	  int seen;
-
-	  seq = final_sequence;
-	  final_sequence = 0;
-	  final_scan_insn (seq->insn (1), asm_out_file, optimize, 1, & seen);
-	  final_scan_insn (seq->insn (0), asm_out_file, optimize, 1, & seen);
-	  seq->insn (1)->set_deleted ();
-	  return "";
-	}
-    }
-  else if (get_attr_length (insn) == 2)
-    return "bra	%l0";
-  else if (get_attr_length (insn) == 4)
-    return "bra	%l0:16";
-  else
-    return "jmp	@%l0";
-}
-  [(set_attr "type" "branch")
-   (set (attr "delay_slot")
-	(if_then_else (match_test "TARGET_H8300SX")
-		      (const_string "jump")
-		      (const_string "none")))
-   (set_attr "cc" "none")])
-
-;; This is a define expand, because pointers may be either 16 or 32 bits.
-
-(define_expand "tablejump"
-  [(parallel [(set (pc) (match_operand 0 "register_operand" ""))
-	      (use (label_ref (match_operand 1 "" "")))])]
-  ""
-  "")
-
-(define_insn "*tablejump_h8300"
-  [(set (pc) (match_operand:HI 0 "register_operand" "r"))
-   (use (label_ref (match_operand 1 "" "")))]
-  "TARGET_H8300"
-  "jmp	@%0"
-  [(set_attr "cc" "none")
-   (set_attr "length" "2")])
-
-(define_insn "*tablejump_h8300hs_advanced"
-  [(set (pc) (match_operand:SI 0 "register_operand" "r"))
-   (use (label_ref (match_operand 1 "" "")))]
-  "(TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE"
-  "jmp	@%0"
-  [(set_attr "cc" "none")
-   (set_attr "length" "2")])
-
-(define_insn "*tablejump_h8300hs_normal"
-  [(set (pc) (match_operand:HI 0 "register_operand" "r"))
-   (use (label_ref (match_operand 1 "" "")))]
-  "(TARGET_H8300H || TARGET_H8300S) && TARGET_NORMAL_MODE"
-  "jmp @%S0"
-  [(set_attr "cc" "none")
-   (set_attr "length" "2")])
-
-;; This is a define expand, because pointers may be either 16 or 32 bits.
-
-(define_expand "indirect_jump"
-  [(set (pc) (match_operand 0 "jump_address_operand" ""))]
-  ""
-  "")
-
-(define_insn "*indirect_jump_h8300"
-  [(set (pc) (match_operand:HI 0 "jump_address_operand" "Vr"))]
-  "TARGET_H8300"
-  "jmp	@%0"
-  [(set_attr "cc" "none")
-   (set_attr "length" "2")])
-
-(define_insn "*indirect_jump_h8300hs_advanced"
-  [(set (pc) (match_operand:SI 0 "jump_address_operand" "Vr"))]
-  "(TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE"
-  "jmp @%0"
-  [(set_attr "cc" "none")
-   (set_attr "length" "2")])
-
-(define_insn "*indirect_jump_h8300hs_normal"
-  [(set (pc) (match_operand:HI 0 "jump_address_operand" "Vr"))]
-  "(TARGET_H8300H || TARGET_H8300S) && TARGET_NORMAL_MODE"
-  "jmp @%S0"
-  [(set_attr "cc" "none")
-   (set_attr "length" "2")])
-
-;; Call subroutine with no return value.
-
-;; ??? Even though we use HImode here, this works on the H8/300H and H8S.
-
-(define_expand "call"
-  [(call (match_operand:QI 0 "call_expander_operand" "")
-	 (match_operand 1 "general_operand" ""))]
-  ""
-  {
-    if (!register_operand (XEXP (operands[0], 0), Pmode)
-	&& GET_CODE (XEXP (operands[0], 0)) != SYMBOL_REF)
-      XEXP (operands[0], 0) = force_reg (Pmode, XEXP (operands[0], 0));
-  })
-
-(define_insn "call_insn_<mode>"
-  [(call (mem:QI (match_operand 0 "call_insn_operand" "Cr"))
-	         (match_operand:P 1 "general_operand" "g"))]
-  ""
-{
-  rtx xoperands[1];
-  xoperands[0] = gen_rtx_MEM (QImode, operands[0]);
-  gcc_assert (GET_MODE (operands[0]) == Pmode);
-  if (GET_CODE (XEXP (xoperands[0], 0)) == SYMBOL_REF
-      && (SYMBOL_REF_FLAGS (XEXP (xoperands[0], 0)) & SYMBOL_FLAG_FUNCVEC_FUNCTION))
-    output_asm_insn ("jsr\\t@%0:8", xoperands);
-  else
-    output_asm_insn ("jsr\\t%0", xoperands);
-  return "";
-}
-  [(set_attr "type" "call")
-   (set (attr "length")
-	(if_then_else (match_operand:QI 0 "small_call_insn_operand" "")
-		      (const_int 2)
-		      (const_int 4)))])
-
-;; Call subroutine, returning value in operand 0
-;; (which must be a hard register).
-
-;; ??? Even though we use HImode here, this works on the H8/300H and H8S.
-
-(define_expand "call_value"
-  [(set (match_operand 0 "" "")
-	(call (match_operand:QI 1 "call_expander_operand" "")
-	      (match_operand 2 "general_operand" "")))]
-  ""
-  {
-    if (!register_operand (XEXP (operands[1], 0), Pmode)
-	&& GET_CODE (XEXP (operands[1], 0)) != SYMBOL_REF)
-      XEXP (operands[1], 0) = force_reg (Pmode, XEXP (operands[1], 0));
-  })
-
-(define_insn "call_value_insn_<mode>"
-  [(set (match_operand 0 "" "=r")
-	(call (mem:QI (match_operand 1 "call_insn_operand" "Cr"))
-		      (match_operand:P 2 "general_operand" "g")))]
-  ""
-{
-  rtx xoperands[2];
-  gcc_assert (GET_MODE (operands[1]) == Pmode);
-  xoperands[0] = operands[0];
-  xoperands[1] = gen_rtx_MEM (QImode, operands[1]);
-  if (GET_CODE (XEXP (xoperands[1], 0)) == SYMBOL_REF
-      && (SYMBOL_REF_FLAGS (XEXP (xoperands[1], 0)) & SYMBOL_FLAG_FUNCVEC_FUNCTION))
-    output_asm_insn ("jsr\\t@%1:8", xoperands);
-  else
-    output_asm_insn ("jsr\\t%1", xoperands);
-  return "";
-}
-  [(set_attr "type" "call")
-   (set (attr "length")
-	(if_then_else (match_operand:QI 0 "small_call_insn_operand" "")
-		      (const_int 2)
-		      (const_int 4)))])
-
-(define_insn "nop"
-  [(const_int 0)]
-  ""
-  "nop"
-  [(set_attr "cc" "none")
-   (set_attr "length" "2")])
-
-;; ----------------------------------------------------------------------
-;; PROLOGUE/EPILOGUE-RELATED INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_expand "push_h8300"
-  [(set (mem:HI (pre_dec:HI (reg:HI SP_REG)))
-        (match_operand:HI 0 "register_operand" ""))]
-  "TARGET_H8300"
-  "")
-
-(define_expand "push_h8300hs_advanced"
-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-        (match_operand:SI 0 "register_operand" ""))]
-  "TARGET_H8300H && TARGET_H8300S && !TARGET_NORMAL_MODE"
-  "")
-
-(define_expand "push_h8300hs_normal"
-  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
-        (match_operand:SI 0 "register_operand" ""))]
-  "TARGET_H8300H && TARGET_H8300S && TARGET_NORMAL_MODE"
-  "")
-
-(define_expand "pop_h8300"
-  [(set (match_operand:HI 0 "register_operand" "")
-	(mem:HI (post_inc:HI (reg:HI SP_REG))))]
-  "TARGET_H8300"
-  "")
-
-(define_expand "pop_h8300hs_advanced"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(mem:SI (post_inc:SI (reg:SI SP_REG))))]
-  "TARGET_H8300H && TARGET_H8300S && !TARGET_NORMAL_MODE"
-  "")
-
-(define_expand "pop_h8300hs_normal"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(mem:SI (post_inc:HI (reg:HI SP_REG))))]
-  "TARGET_H8300H && TARGET_H8300S && TARGET_NORMAL_MODE"
-  "")
-
-(define_insn "ldm_h8300sx"
-  [(match_parallel           0 "h8300_ldm_parallel"
-    [(set (match_operand:SI 1 "register_operand" "")
-	  (match_operand:SI 2 "memory_operand" ""))])]
-  "TARGET_H8300S"
-{
-  operands[3] = SET_DEST (XVECEXP (operands[0], 0,
-				   XVECLEN (operands[0], 0) - 2));
-  return "ldm.l\t@er7+,%S1-%S3";
-}
-  [(set_attr "cc" "none")
-   (set_attr "length" "4")])
-
-(define_insn "stm_h8300sx"
-  [(match_parallel           0 "h8300_stm_parallel"
-    [(set (match_operand:SI 1 "memory_operand" "")
-	  (match_operand:SI 2 "register_operand" ""))])]
-  "TARGET_H8300S"
-{
-  operands[3] = SET_SRC (XVECEXP (operands[0], 0,
-				  XVECLEN (operands[0], 0) - 2));
-  return "stm.l\t%S2-%S3,@-er7";
-}
-  [(set_attr "cc" "none")
-   (set_attr "length" "4")])
-
-(define_insn "return_h8sx"
-  [(match_parallel           0 "h8300_return_parallel"
-    [(return)
-     (set (match_operand:SI 1 "register_operand" "")
-	  (match_operand:SI 2 "memory_operand" ""))])]
-  "TARGET_H8300SX"
-{
-  operands[3] = SET_DEST (XVECEXP (operands[0], 0,
-				   XVECLEN (operands[0], 0) - 2));
-  if (h8300_current_function_interrupt_function_p ()
-      || h8300_current_function_monitor_function_p ())
-    return "rte/l\t%S1-%S3";
-  else
-    return "rts/l\t%S1-%S3";
-}
-  [(set_attr "cc" "none")
-   (set_attr "can_delay" "no")
-   (set_attr "length" "2")])
-
-(define_expand "return"
-  [(return)]
-  "h8300_can_use_return_insn_p ()"
-  "")
-
-(define_insn "*return_1"
-  [(return)]
-  "reload_completed"
-{
-  if (h8300_current_function_interrupt_function_p ()
-      || h8300_current_function_monitor_function_p ())
-    return "rte";
-  else
-    return "rts";
-}
-  [(set_attr "cc" "none")
-   (set_attr "can_delay" "no")
-   (set_attr "length" "2")])
-
-(define_expand "prologue"
-  [(const_int 0)]
-  ""
-  {
-    h8300_expand_prologue ();
-    DONE;
-  })
-
-(define_expand "epilogue"
-  [(return)]
-  ""
-  {
-    h8300_expand_epilogue ();
-    DONE;
-  })
-
-(define_insn "monitor_prologue"
-  [(unspec_volatile [(const_int 0)] UNSPEC_MONITOR)]
-  ""
-{
-  if (TARGET_H8300)
-    return "subs\\t#2,r7\;mov.w\\tr0,@-r7\;stc\\tccr,r0l\;mov.b\tr0l,@(2,r7)\;mov.w\\t@r7+,r0\;orc\t#128,ccr";
-  else if (TARGET_H8300H && TARGET_NORMAL_MODE)
-    return "subs\\t#2,er7\;mov.l\\ter0,@-er7\;stc\\tccr,r0l\;mov.b\\tr0l,@(4,er7)\;mov.l\\t@er7+,er0\;orc\\t#128,ccr";
-  else if (TARGET_H8300H)
-    return "mov.l\\ter0,@-er7\;stc\\tccr,r0l\;mov.b\\tr0l,@(4,er7)\;mov.l\\t@er7+,er0\;orc\\t#128,ccr";
-  else if (TARGET_H8300S && TARGET_NEXR )
-    return "mov.l\\ter0,@-er7\;stc\tccr,r0l\;mov.b\tr0l,@(4,er7)\;mov.l\\t@er7+,er0\;orc\t#128,ccr";
-  else if (TARGET_H8300S && TARGET_NEXR && TARGET_NORMAL_MODE)
-    return "subs\\t#2,er7\;mov.l\\ter0,@-er7\;stc\tccr,r0l\;mov.b\tr0l,@(4,er7)\;mov.l\\t@er7+,er0\;orc\t#128,ccr";
-  else if (TARGET_H8300S && TARGET_NORMAL_MODE)
-    return "subs\\t#2,er7\;stc\texr,@-er7\;mov.l\\ter0,@-er7\;stc\tccr,r0l\;mov.b\tr0l,@(6,er7)\;mov.l\\t@er7+,er0\;orc\t#128,ccr";
-  else if (TARGET_H8300S)
-    return "stc\texr,@-er7\;mov.l\\ter0,@-er7\;stc\tccr,r0l\;mov.b\tr0l,@(6,er7)\;mov.l\\t@er7+,er0\;orc\t#128,ccr";
-  gcc_unreachable ();
-}
-  [(set_attr "length" "20")])
-
-;; ----------------------------------------------------------------------
-;; EXTEND INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-(define_expand "zero_extendqi<mode>2"
-  [(set (match_operand:HSI 0 "register_operand" "")
-	(zero_extend:HSI (match_operand:QI 1 "general_operand_src" "")))]
-  ""
-  {
-    if (TARGET_H8300SX)
-      operands[1] = force_reg (QImode, operands[1]);
-  })
-
-(define_insn "*zero_extendqihi2_h8300"
-  [(set (match_operand:HI 0 "register_operand" "=r,r")
-	(zero_extend:HI (match_operand:QI 1 "general_operand_src" "0,g>")))]
-  "TARGET_H8300"
-  "@
-  mov.b	#0,%t0
-  #"
-  [(set_attr "length" "2,10")])
-
-(define_insn "*zero_extendqihi2_h8300hs"
-  [(set (match_operand:HI 0 "register_operand" "=r,r")
-	(zero_extend:HI (match_operand:QI 1 "general_operand_src" "0,g>")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "@
-  extu.w	%T0
-  #"
-  [(set_attr "length" "2,10")
-   (set_attr "cc" "set_znv,set_znv")])
-
-;; Split the zero extension of a general operand (actually a memory
-;; operand) into a load of the operand and the actual zero extension
-;; so that 1) the length will be accurate, and 2) the zero extensions
-;; appearing at the end of basic blocks may be merged.
-
-(define_split
-  [(set (match_operand:HI 0 "register_operand" "")
-	(zero_extend:HI (match_operand:QI 1 "general_operand_src" "")))]
-  "reload_completed"
-  [(set (match_dup 2)
-	(match_dup 1))
-   (set (match_dup 0)
-	(zero_extend:HI (match_dup 2)))]
-  {
-    operands[2] = gen_rtx_REG (QImode, REGNO (operands[0]));
-  })
-
-
-(define_insn "*zero_extendqisi2_h8300"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(zero_extend:SI (match_operand:QI 1 "general_operand_src" "0,g>")))]
-  "TARGET_H8300"
-  "@
-  mov.b	#0,%x0\;sub.w	%e0,%e0
-  mov.b	%R1,%w0\;mov.b	#0,%x0\;sub.w	%e0,%e0"
-  [(set_attr "length" "4,8")])
-
-(define_insn "*zero_extendqisi2_h8300hs"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(zero_extend:SI (match_operand:QI 1 "general_operand_src" "0,g>")))]
-  "(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX"
-  "#")
-
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(zero_extend:SI (match_operand:QI 1 "general_operand_src" "")))]
-  "(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX
-    && reg_overlap_mentioned_p (operands[0], operands[1])
-    && reload_completed"
-  [(set (match_dup 2)
-	(match_dup 1))
-   (set (match_dup 3)
-	(zero_extend:HI (match_dup 2)))
-   (set (match_dup 0)
-	(zero_extend:SI (match_dup 3)))]
-  {
-    operands[2] = gen_lowpart (QImode, operands[0]);
-    operands[3] = gen_lowpart (HImode, operands[0]);
-  })
-
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(zero_extend:SI (match_operand:QI 1 "general_operand_src" "")))]
-  "(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX
-    && !reg_overlap_mentioned_p (operands[0], operands[1])
-    && reload_completed"
-  [(set (match_dup 0)
-	(const_int 0))
-   (set (strict_low_part (match_dup 2))
-	(match_dup 1))]
-  {
-    operands[2] = gen_rtx_REG (QImode, REGNO (operands[0]));
-  })
-
-(define_insn "*zero_extendqisi2_h8sx"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(zero_extend:SI (match_operand:QI 1 "register_operand" "0")))]
-  "TARGET_H8300SX"
-  "extu.l\t#2,%0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_znv")])
-
-(define_expand "zero_extendhisi2"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(zero_extend:SI (match_operand:HI 1 "register_operand" "")))]
-  ""
-  "")
-
-;; %e prints the high part of a CONST_INT, not the low part.  Arggh.
-(define_insn "*zero_extendhisi2_h8300"
-  [(set (match_operand:SI 0 "register_operand" "=r,r,r")
-	(zero_extend:SI (match_operand:HI 1 "general_operand_src" "0,i,g>")))]
-  "TARGET_H8300"
-  "@
-  sub.w	%e0,%e0
-  mov.w	%f1,%f0\;sub.w	%e0,%e0
-  mov.w	%e1,%f0\;sub.w	%e0,%e0"
-  [(set_attr "length" "2,4,6")])
-
-(define_insn "*zero_extendhisi2_h8300hs"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(zero_extend:SI (match_operand:HI 1 "register_operand" "0")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "extu.l	%S0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_znv")])
-
-(define_expand "extendqi<mode>2"
-  [(set (match_operand:HSI 0 "register_operand" "")
-	(sign_extend:HSI (match_operand:QI 1 "register_operand" "")))]
-  ""
-  "")
-
-(define_insn "*extendqihi2_h8300"
-  [(set (match_operand:HI 0 "register_operand" "=r,r")
-	(sign_extend:HI (match_operand:QI 1 "general_operand_src" "0,g>")))]
-  "TARGET_H8300"
-  "@
-  bld	#7,%s0\;subx	%t0,%t0
-  mov.b	%R1,%s0\;bld	#7,%s0\;subx	%t0,%t0"
-  [(set_attr "length" "4,8")])
-
-(define_insn "*extendqihi2_h8300hs"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(sign_extend:HI (match_operand:QI 1 "register_operand" "0")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "exts.w	%T0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_znv")])
-
-(define_insn "*extendqisi2_h8300"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(sign_extend:SI (match_operand:QI 1 "general_operand_src" "0,g>")))]
-  "TARGET_H8300"
-  "@
-  bld	#7,%w0\;subx	%x0,%x0\;subx	%y0,%y0\;subx	%z0,%z0
-  mov.b	%R1,%w0\;bld	#7,%w0\;subx	%x0,%x0\;subx	%y0,%y0\;subx	%z0,%z0"
-  [(set_attr "length" "8,12")])
-
-;; The following pattern is needed because without the pattern, the
-;; combiner would split (sign_extend:SI (reg:QI)) into two 24-bit
-;; shifts, one ashift and one ashiftrt.
-
-(define_insn_and_split "*extendqisi2_h8300hs"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(sign_extend:SI (match_operand:QI 1 "register_operand" "0")))]
-  "(TARGET_H8300H || TARGET_H8300S) && !TARGET_H8300SX"
-  "#"
-  "&& reload_completed"
-  [(set (match_dup 2)
-	(sign_extend:HI (match_dup 1)))
-   (set (match_dup 0)
-	(sign_extend:SI (match_dup 2)))]
-  {
-    operands[2] = gen_rtx_REG (HImode, REGNO (operands[0]));
-  })
-
-(define_insn "*extendqisi2_h8sx"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(sign_extend:SI (match_operand:QI 1 "register_operand" "0")))]
-  "TARGET_H8300SX"
-  "exts.l\t#2,%0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_znv")])
-
-(define_expand "extendhisi2"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(sign_extend:SI (match_operand:HI 1 "register_operand" "")))]
-  ""
-  "")
-
-(define_insn "*extendhisi2_h8300"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(sign_extend:SI (match_operand:HI 1 "general_operand_src" "0,g>")))]
-  "TARGET_H8300"
-  "@
-  bld	#7,%x0\;subx	%y0,%y0\;subx	%z0,%z0
-  mov.w	%T1,%f0\;bld	#7,%x0\;subx	%y0,%y0\;subx	%z0,%z0"
-  [(set_attr "length" "6,10")])
-
-(define_insn "*extendhisi2_h8300hs"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(sign_extend:SI (match_operand:HI 1 "register_operand" "0")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "exts.l	%S0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_znv")])
-
-;; ----------------------------------------------------------------------
-;; SHIFTS
-;; ----------------------------------------------------------------------
-;;
-;; We make some attempt to provide real efficient shifting.  One example is
-;; doing an 8-bit shift of a 16-bit value by moving a byte reg into the other
-;; reg and moving 0 into the former reg.
-;;
-;; We also try to achieve this in a uniform way.  IE: We don't try to achieve
-;; this in both rtl and at insn emit time.  Ideally, we'd use rtl as that would
-;; give the optimizer more cracks at the code.  However, we wish to do things
-;; like optimizing shifting the sign bit to bit 0 by rotating the other way.
-;; There is rtl to handle this (rotate + and), but the H8/300 doesn't handle
-;; 16-bit rotates.  Also, if we emit complicated rtl, combine may not be able
-;; to detect cases it can optimize.
-;;
-;; For these and other fuzzy reasons, I've decided to go the less pretty but
-;; easier "do it at insn emit time" route.
-
-;; QI BIT SHIFTS
-
-(define_expand "ashlqi3"
-  [(set (match_operand:QI 0 "register_operand" "")
-	(ashift:QI (match_operand:QI 1 "register_operand" "")
-		   (match_operand:QI 2 "nonmemory_operand" "")))]
-  ""
-  {
-    if (expand_a_shift (QImode, ASHIFT, operands))
-    DONE;
-  })
-
-(define_expand "ashrqi3"
-  [(set (match_operand:QI 0 "register_operand" "")
-	(ashiftrt:QI (match_operand:QI 1 "register_operand" "")
-		     (match_operand:QI 2 "nonmemory_operand" "")))]
-  ""
-  {
-    if (expand_a_shift (QImode, ASHIFTRT, operands))
-    DONE;
-  })
-
-(define_expand "lshrqi3"
-  [(set (match_operand:QI 0 "register_operand" "")
-	(lshiftrt:QI (match_operand:QI 1 "register_operand" "")
-		     (match_operand:QI 2 "nonmemory_operand" "")))]
-  ""
-  {
-    if (expand_a_shift (QImode, LSHIFTRT, operands))
-    DONE;
-  })
-
-(define_insn ""
-  [(set (match_operand:QI 0 "h8300_dst_operand" "=rQ")
-	(match_operator:QI 3 "h8sx_unary_shift_operator"
-	 [(match_operand:QI 1 "h8300_dst_operand" "0")
-	  (match_operand:QI 2 "const_int_operand" "")]))]
-  "h8300_operands_match_p (operands)"
-{
-  return output_h8sx_shift (operands, 'b', 'X');
-}
-  [(set_attr "length_table" "unary")
-   (set_attr "cc" "set_znv")])
-
-(define_insn ""
-  [(set (match_operand:QI 0 "register_operand" "=r")
-	(match_operator:QI 3 "h8sx_binary_shift_operator"
-	 [(match_operand:QI 1 "register_operand" "0")
-	  (match_operand:QI 2 "nonmemory_operand" "r P3>X")]))]
-  ""
-{
-  return output_h8sx_shift (operands, 'b', 'X');
-}
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_znv")])
-
-(define_insn "*shiftqi"
-  [(set (match_operand:QI 0 "register_operand" "=r,r")
-	(match_operator:QI 3 "nshift_operator"
-	 [(match_operand:QI 1 "register_operand" "0,0")
-	  (match_operand:QI 2 "nonmemory_operand" "R,rn")]))
-   (clobber (match_scratch:QI 4 "=X,&r"))]
-  ""
-{
-  return output_a_shift (operands);
-}
-  [(set (attr "length")
-	(symbol_ref "compute_a_shift_length (insn, operands)"))
-   (set (attr "cc")
-	(symbol_ref "compute_a_shift_cc (insn, operands)"))])
-
-;; HI BIT SHIFTS
-
-(define_expand "ashlhi3"
-  [(set (match_operand:HI 0 "register_operand" "")
-	(ashift:HI (match_operand:HI 1 "register_operand" "")
-		   (match_operand:QI 2 "nonmemory_operand" "")))]
-  ""
-  {
-    if (expand_a_shift (HImode, ASHIFT, operands))
-    DONE;
-  })
-
-(define_expand "lshrhi3"
-  [(set (match_operand:HI 0 "register_operand" "")
-	(lshiftrt:HI (match_operand:HI 1 "register_operand" "")
-		     (match_operand:QI 2 "nonmemory_operand" "")))]
-  ""
-  {
-    if (expand_a_shift (HImode, LSHIFTRT, operands))
-    DONE;
-  })
-
-(define_expand "ashrhi3"
-  [(set (match_operand:HI 0 "register_operand" "")
-	(ashiftrt:HI (match_operand:HI 1 "register_operand" "")
-		     (match_operand:QI 2 "nonmemory_operand" "")))]
-  ""
-  {
-    if (expand_a_shift (HImode, ASHIFTRT, operands))
-    DONE;
-  })
-
-(define_insn ""
-  [(set (match_operand:HI 0 "h8300_dst_operand" "=rQ")
-	(match_operator:HI 3 "h8sx_unary_shift_operator"
-	 [(match_operand:HI 1 "h8300_dst_operand" "0")
-	  (match_operand:QI 2 "const_int_operand" "")]))]
-  "h8300_operands_match_p (operands)"
-{
-  return output_h8sx_shift (operands, 'w', 'T');
-}
-  [(set_attr "length_table" "unary")
-   (set_attr "cc" "set_znv")])
-
-(define_insn ""
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(match_operator:HI 3 "h8sx_binary_shift_operator"
-	 [(match_operand:HI 1 "register_operand" "0")
-	  (match_operand:QI 2 "nonmemory_operand" "r P4>X")]))]
-  ""
-{
-  return output_h8sx_shift (operands, 'w', 'T');
-}
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_znv")])
-
-(define_insn "*shifthi"
-  [(set (match_operand:HI 0 "register_operand" "=r,r")
-	(match_operator:HI 3 "nshift_operator"
-	 [(match_operand:HI 1 "register_operand" "0,0")
-	  (match_operand:QI 2 "nonmemory_operand" "S,rn")]))
-   (clobber (match_scratch:QI 4 "=X,&r"))]
-  ""
-{
-  return output_a_shift (operands);
-}
-  [(set (attr "length")
-	(symbol_ref "compute_a_shift_length (insn, operands)"))
-   (set (attr "cc")
-	(symbol_ref "compute_a_shift_cc (insn, operands)"))])
-
-;;  SI BIT SHIFTS
-
-(define_expand "ashlsi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(ashift:SI (match_operand:SI 1 "register_operand" "")
-		   (match_operand:QI 2 "nonmemory_operand" "")))]
-  ""
-  {
-    if (expand_a_shift (SImode, ASHIFT, operands))
-    DONE;
-  })
-
-(define_expand "lshrsi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(lshiftrt:SI (match_operand:SI 1 "register_operand" "")
-		     (match_operand:QI 2 "nonmemory_operand" "")))]
-  ""
-  {
-    if (expand_a_shift (SImode, LSHIFTRT, operands))
-    DONE;
-  })
-
-(define_expand "ashrsi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(ashiftrt:SI (match_operand:SI 1 "register_operand" "")
-		     (match_operand:QI 2 "nonmemory_operand" "")))]
-  ""
-  {
-    if (expand_a_shift (SImode, ASHIFTRT, operands))
-    DONE;
-  })
-
-(define_insn ""
-  [(set (match_operand:SI 0 "h8300_dst_operand" "=rQ")
-	(match_operator:SI 3 "h8sx_unary_shift_operator"
-	 [(match_operand:SI 1 "h8300_dst_operand" "0")
-	  (match_operand:QI 2 "const_int_operand" "")]))]
-  "h8300_operands_match_p (operands)"
-{
-  return output_h8sx_shift (operands, 'l', 'S');
-}
-  [(set_attr "length_table" "unary")
-   (set_attr "cc" "set_znv")])
-
-(define_insn ""
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(match_operator:SI 3 "h8sx_binary_shift_operator"
-	 [(match_operand:SI 1 "register_operand" "0")
-	  (match_operand:QI 2 "nonmemory_operand" "r P5>X")]))]
-  ""
-{
-  return output_h8sx_shift (operands, 'l', 'S');
-}
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_znv")])
-
-(define_insn "*shiftsi"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(match_operator:SI 3 "nshift_operator"
-	 [(match_operand:SI 1 "register_operand" "0,0")
-	  (match_operand:QI 2 "nonmemory_operand" "T,rn")]))
-   (clobber (match_scratch:QI 4 "=X,&r"))]
-  ""
-{
-  return output_a_shift (operands);
-}
-  [(set (attr "length")
-	(symbol_ref "compute_a_shift_length (insn, operands)"))
-   (set (attr "cc")
-	(symbol_ref "compute_a_shift_cc (insn, operands)"))])
-
-;; Split a variable shift into a loop.  If the register containing
-;; the shift count dies, then we just use that register.
-
-(define_split
-  [(set (match_operand 0 "register_operand" "")
-	(match_operator 2 "nshift_operator"
-	 [(match_dup 0)
-	  (match_operand:QI 1 "register_operand" "")]))
-   (clobber (match_operand:QI 3 "register_operand" ""))]
-  "epilogue_completed
-   && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))"
-  [(set (cc0) (compare (match_dup 1) (const_int 0)))
-   (set (pc)
-        (if_then_else (le (cc0) (const_int 0))
-		      (label_ref (match_dup 5))
-		      (pc)))
-   (match_dup 4)
-   (parallel
-     [(set (match_dup 0)
-	   (match_op_dup 2 [(match_dup 0) (const_int 1)]))
-      (clobber (scratch:QI))])
-   (set (match_dup 1) (plus:QI (match_dup 1) (const_int -1)))
-   (set (cc0) (compare (match_dup 1) (const_int 0)))
-   (set (pc)
-        (if_then_else (ne (cc0) (const_int 0))
-		      (label_ref (match_dup 4))
-		      (pc)))
-   (match_dup 5)]
-  {
-    operands[4] = gen_label_rtx ();
-    operands[5] = gen_label_rtx ();
-  })
-
-(define_split
-  [(set (match_operand 0 "register_operand" "")
-	(match_operator 2 "nshift_operator"
-	 [(match_dup 0)
-	  (match_operand:QI 1 "register_operand" "")]))
-   (clobber (match_operand:QI 3 "register_operand" ""))]
-  "epilogue_completed
-   && !find_regno_note (insn, REG_DEAD, REGNO (operands[1]))"
-  [(set (match_dup 3)
-	(match_dup 1))
-   (set (cc0) (compare (match_dup 3) (const_int 0)))
-   (set (pc)
-        (if_then_else (le (cc0) (const_int 0))
-		      (label_ref (match_dup 5))
-		      (pc)))
-   (match_dup 4)
-   (parallel
-     [(set (match_dup 0)
-	   (match_op_dup 2 [(match_dup 0) (const_int 1)]))
-      (clobber (scratch:QI))])
-   (set (match_dup 3) (plus:QI (match_dup 3) (const_int -1)))
-   (set (cc0) (compare (match_dup 3) (const_int 0)))
-   (set (pc)
-        (if_then_else (ne (cc0) (const_int 0))
-		      (label_ref (match_dup 4))
-		      (pc)))
-   (match_dup 5)]
-  {
-    operands[4] = gen_label_rtx ();
-    operands[5] = gen_label_rtx ();
-  })
-
-;; ----------------------------------------------------------------------
-;; ROTATIONS
-;; ----------------------------------------------------------------------
-
-(define_expand "rotl<mode>3"
-  [(set (match_operand:QHI 0 "register_operand" "")
-	(rotate:QHI (match_operand:QHI 1 "register_operand" "")
-		    (match_operand:QI 2 "nonmemory_operand" "")))]
-  ""
-  {
-    if (expand_a_rotate (operands))
-    DONE;
-  })
-
-(define_insn "rotl<mode>3_1"
-  [(set (match_operand:QHI 0 "register_operand" "=r")
-	(rotate:QHI (match_operand:QHI 1 "register_operand" "0")
-		    (match_operand:QI 2 "immediate_operand" "")))]
-  ""
-{
-  return output_a_rotate (ROTATE, operands);
-}
-  [(set (attr "length")
-	(symbol_ref "compute_a_rotate_length (operands)"))])
-
-(define_expand "rotlsi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(rotate:SI (match_operand:SI 1 "register_operand" "")
-		   (match_operand:QI 2 "nonmemory_operand" "")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  {
-    if (expand_a_rotate (operands))
-    DONE;
-  })
-
-(define_insn "rotlsi3_1"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(rotate:SI (match_operand:SI 1 "register_operand" "0")
-		   (match_operand:QI 2 "immediate_operand" "")))]
-  "TARGET_H8300H || TARGET_H8300S"
-{
-  return output_a_rotate (ROTATE, operands);
-}
-  [(set (attr "length")
-	(symbol_ref "compute_a_rotate_length (operands)"))])
-
-;; -----------------------------------------------------------------
-;; BIT FIELDS
-;; -----------------------------------------------------------------
-;; The H8/300 has given 1/8th of its opcode space to bitfield
-;; instructions so let's use them as well as we can.
-
-;; You'll never believe all these patterns perform one basic action --
-;; load a bit from the source, optionally invert the bit, then store it
-;; in the destination (which is known to be zero).
-;;
-;; Combine obviously need some work to better identify this situation and
-;; canonicalize the form better.
-
-;;
-;; Normal loads with a 16bit destination.
-;;
-
-(define_insn ""
-  [(set (match_operand:HI 0 "register_operand" "=&r")
-	(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
-			 (const_int 1)
-			 (match_operand:HI 2 "immediate_operand" "n")))]
-  "TARGET_H8300"
-  "sub.w	%0,%0\;bld	%Z2,%Y1\;bst	#0,%X0"
-  [(set_attr "length" "6")])
-
-;;
-;; Inverted loads with a 16bit destination.
-;;
-
-(define_insn ""
-  [(set (match_operand:HI 0 "register_operand" "=&r")
-	(zero_extract:HI (xor:HI (match_operand:HI 1 "register_operand" "r")
-				 (match_operand:HI 3 "const_int_operand" "n"))
-			 (const_int 1)
-			 (match_operand:HI 2 "const_int_operand" "n")))]
-  "(TARGET_H8300 || TARGET_H8300SX)
-    && (1 << INTVAL (operands[2])) == INTVAL (operands[3])"
-  "sub.w	%0,%0\;bild	%Z2,%Y1\;bst	#0,%X0"
-  [(set_attr "length" "8")])
-
-;;
-;; Normal loads with a 32bit destination.
-;;
-
-(define_insn "*extzv_1_r_h8300"
-  [(set (match_operand:SI 0 "register_operand" "=&r")
-	(zero_extract:SI (match_operand:HI 1 "register_operand" "r")
-			 (const_int 1)
-			 (match_operand 2 "const_int_operand" "n")))]
-  "TARGET_H8300 && INTVAL (operands[2]) < 16"
-{
-  return output_simode_bld (0, operands);
-}
-  [(set_attr "length" "8")])
-
-(define_insn "*extzv_1_r_h8300hs"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(zero_extract:SI (match_operand:SI 1 "register_operand" "?0,r")
-			 (const_int 1)
-			 (match_operand 2 "const_int_operand" "n,n")))]
-  "(TARGET_H8300H || TARGET_H8300S) && INTVAL (operands[2]) < 16"
-{
-  return output_simode_bld (0, operands);
-}
-  [(set_attr "cc" "set_znv,set_znv")
-   (set_attr "length" "8,6")])
-
-;;
-;; Inverted loads with a 32bit destination.
-;;
-
-(define_insn "*extzv_1_r_inv_h8300"
-  [(set (match_operand:SI 0 "register_operand" "=&r")
-	(zero_extract:SI (xor:HI (match_operand:HI 1 "register_operand" "r")
-				 (match_operand:HI 3 "const_int_operand" "n"))
-			 (const_int 1)
-			 (match_operand 2 "const_int_operand" "n")))]
-  "TARGET_H8300 && INTVAL (operands[2]) < 16
-   && (1 << INTVAL (operands[2])) == INTVAL (operands[3])"
-{
-  return output_simode_bld (1, operands);
-}
-  [(set_attr "length" "8")])
-
-(define_insn "*extzv_1_r_inv_h8300hs"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(zero_extract:SI (xor:SI (match_operand:SI 1 "register_operand" "?0,r")
-				 (match_operand 3 "const_int_operand" "n,n"))
-			 (const_int 1)
-			 (match_operand 2 "const_int_operand" "n,n")))]
-  "(TARGET_H8300H || TARGET_H8300S) && INTVAL (operands[2]) < 16
-    && (1 << INTVAL (operands[2])) == INTVAL (operands[3])"
-{
-  return output_simode_bld (1, operands);
-}
-  [(set_attr "cc" "set_znv,set_znv")
-   (set_attr "length" "8,6")])
-
-(define_expand "insv"
-  [(set (zero_extract:HI (match_operand:HI 0 "general_operand" "")
-			 (match_operand:HI 1 "general_operand" "")
-			 (match_operand:HI 2 "general_operand" ""))
-	(match_operand:HI 3 "general_operand" ""))]
-  "TARGET_H8300 || TARGET_H8300SX"
-  {
-    if (TARGET_H8300SX)
-      {
-	if (GET_CODE (operands[1]) == CONST_INT
-	    && GET_CODE (operands[2]) == CONST_INT
-	    && INTVAL (operands[1]) <= 8
-	    && INTVAL (operands[2]) >= 0
-	    && INTVAL (operands[1]) + INTVAL (operands[2]) <= 8
-	    && memory_operand (operands[0], GET_MODE (operands[0])))
-	  {
-	    /* If the source operand is zero, it's better to use AND rather
-	       than BFST.  Likewise OR if the operand is all ones.  */
-	    if (GET_CODE (operands[3]) == CONST_INT)
-	      {
-		HOST_WIDE_INT mask = (1 << INTVAL (operands[1])) - 1;
-		if ((INTVAL (operands[3]) & mask) == 0)
-		  FAIL;
-		if ((INTVAL (operands[3]) & mask) == mask)
-		  FAIL;
-	      }
-	    if (! bit_memory_operand (operands[0], GET_MODE (operands[0])))
-	      {
-		if (!can_create_pseudo_p ())
-		  FAIL;
-		operands[0] =  replace_equiv_address (operands[0], force_reg (Pmode,
-						      XEXP (operands[0], 0)));
-	      }
-	    operands[3] = gen_lowpart (QImode, operands[3]);
-	    if (! operands[3])
-	      FAIL;
-	    if (! register_operand (operands[3], QImode))
-	      {
-		if (!can_create_pseudo_p ())
-		  FAIL;
-		operands[3] = force_reg (QImode, operands[3]);
-	      }
-	    emit_insn (gen_bfst (adjust_address (operands[0], QImode, 0),
-						 operands[3], operands[1], operands[2]));
-	    DONE;
-	  }
-	FAIL;
-      }
-
-    /* We only have single bit bit-field instructions.  */
-    if (INTVAL (operands[1]) != 1)
-      FAIL;
-
-    /* For now, we don't allow memory operands.  */
-    if (GET_CODE (operands[0]) == MEM
-	|| GET_CODE (operands[3]) == MEM)
-      FAIL;
-
-    if (GET_CODE (operands[3]) != REG)
-      operands[3] = force_reg (HImode, operands[3]);
-  })
-
-(define_insn ""
-  [(set (zero_extract:HI (match_operand:HI 0 "register_operand" "+r")
-			 (const_int 1)
-			 (match_operand:HI 1 "immediate_operand" "n"))
-	(match_operand:HI 2 "register_operand" "r"))]
-  ""
-  "bld	#0,%R2\;bst	%Z1,%Y0 ; i1"
-  [(set_attr "length" "4")])
-
-(define_expand "extzv"
-  [(set (match_operand:HI 0 "register_operand" "")
-	(zero_extract:HI (match_operand:HI 1 "bit_operand" "")
-			 (match_operand:HI 2 "general_operand" "")
-			 (match_operand:HI 3 "general_operand" "")))]
-  "TARGET_H8300 || TARGET_H8300SX"
-  {
-    if (TARGET_H8300SX)
-      {
-	if (GET_CODE (operands[2]) == CONST_INT
-	    && GET_CODE (operands[3]) == CONST_INT
-	    && INTVAL (operands[2]) <= 8
-	    && INTVAL (operands[3]) >= 0
-	    && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8
-	    && memory_operand (operands[1], QImode))
-	  {
-	    rtx temp;
-
-	    /* Optimize the case where we're extracting into a paradoxical
-	       subreg.  It's only necessary to extend to the inner reg.  */
-	    if (GET_CODE (operands[0]) == SUBREG
-		&& subreg_lowpart_p (operands[0])
-		&& (GET_MODE_SIZE (GET_MODE (SUBREG_REG (operands[0])))
-		    < GET_MODE_SIZE (GET_MODE (operands[0])))
-		&& (GET_MODE_CLASS (GET_MODE (SUBREG_REG (operands[0])))
-		    == MODE_INT))
-	      operands[0] = SUBREG_REG (operands[0]);
-
-	    if (!can_create_pseudo_p ())
-	      temp = gen_lowpart (QImode, operands[0]);
-	    else
-	      temp = gen_reg_rtx (QImode);
-	    if (! temp)
-	      FAIL;
-            if (! bit_memory_operand (operands[1], QImode))
-	      {
-		if (!can_create_pseudo_p ())
-		  FAIL;
-		operands[1] = replace_equiv_address (operands[1],
-						     force_reg (Pmode, XEXP (operands[1], 0)));
-	      }
-	    emit_insn (gen_bfld (temp, operands[1], operands[2], operands[3]));
-	    convert_move (operands[0], temp, 1);
-	    DONE;
-          }
-	FAIL;
-      }
-
-    /* We only have single bit bit-field instructions.  */
-    if (INTVAL (operands[2]) != 1)
-      FAIL;
-
-    /* For now, we don't allow memory operands.  */
-    if (GET_CODE (operands[1]) == MEM)
-      FAIL;
-  })
-
-;; BAND, BOR, and BXOR patterns
-
-(define_insn ""
-  [(set (match_operand:HI 0 "bit_operand" "=Ur")
-	(match_operator:HI 4 "bit_operator"
-	 [(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
-			   (const_int 1)
-			   (match_operand:HI 2 "immediate_operand" "n"))
-	  (match_operand:HI 3 "bit_operand" "0")]))]
-  ""
-  "bld	%Z2,%Y1\;b%c4	#0,%R0\;bst	#0,%R0; bl1"
-  [(set_attr "length" "6")])
-
-(define_insn ""
-  [(set (match_operand:HI 0 "bit_operand" "=Ur")
-	(match_operator:HI 5 "bit_operator"
-	 [(zero_extract:HI (match_operand:HI 1 "register_operand" "r")
-			   (const_int 1)
-			   (match_operand:HI 2 "immediate_operand" "n"))
-	  (zero_extract:HI (match_operand:HI 3 "register_operand" "r")
-			   (const_int 1)
-			   (match_operand:HI 4 "immediate_operand" "n"))]))]
-  ""
-  "bld	%Z2,%Y1\;b%c5	%Z4,%Y3\;bst	#0,%R0; bl3"
-  [(set_attr "length" "6")])
-
-(define_insn "bfld"
-  [(set (match_operand:QI 0 "register_operand" "=r")
-	(zero_extract:QI (match_operand:QI 1 "bit_memory_operand" "WU")
-			 (match_operand:QI 2 "immediate_operand" "n")
-			 (match_operand:QI 3 "immediate_operand" "n")))]
-  "TARGET_H8300SX && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8"
-{
-  operands[2] = GEN_INT ((1 << (INTVAL (operands[2]) + INTVAL (operands[3])))
-			 - (1 << INTVAL (operands[3])));
-  return "bfld	%2,%1,%R0";
-}
-  [(set_attr "cc" "none_0hit")
-   (set_attr "length_table" "bitfield")])
-
-(define_insn "bfst"
-  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU")
-			 (match_operand:QI 2 "immediate_operand" "n")
-			 (match_operand:QI 3 "immediate_operand" "n"))
-	(match_operand:QI 1 "register_operand" "r"))]
-  "TARGET_H8300SX && INTVAL (operands[2]) + INTVAL (operands[3]) <= 8"
-{
-  operands[2] = GEN_INT ((1 << (INTVAL (operands[2]) + INTVAL (operands[3])))
-			 - (1 << INTVAL (operands[3])));
-  return "bfst	%R1,%2,%0";
-}
-  [(set_attr "cc" "none_0hit")
-   (set_attr "length_table" "bitfield")])
-
-(define_expand "cstoreqi4"
-  [(use (match_operator 1 "eqne_operator"
-         [(match_operand:QI 2 "h8300_dst_operand" "")
-          (match_operand:QI 3 "h8300_src_operand" "")]))
-   (clobber (match_operand:HI 0 "register_operand"))]
-  "TARGET_H8300SX"
-  {
-    h8300_expand_store (operands);
-    DONE;
-  })
-
-(define_expand "cstorehi4"
-  [(use (match_operator 1 "eqne_operator"
-         [(match_operand:HI 2 "h8300_dst_operand" "")
-          (match_operand:HI 3 "h8300_src_operand" "")]))
-   (clobber (match_operand:HI 0 "register_operand"))]
-  "TARGET_H8300SX"
-  {
-    h8300_expand_store (operands);
-    DONE;
-  })
-
-(define_expand "cstoresi4"
-  [(use (match_operator 1 "eqne_operator"
-         [(match_operand:SI 2 "h8300_dst_operand" "")
-          (match_operand:SI 3 "h8300_src_operand" "")]))
-   (clobber (match_operand:HI 0 "register_operand"))]
-  "TARGET_H8300SX"
-  {
-    h8300_expand_store (operands);
-    DONE;
-  })
-
-(define_insn "*bstzhireg"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(match_operator:HI 1 "eqne_operator" [(cc0) (const_int 0)]))]
-  "TARGET_H8300SX"
-  "mulu.w	#0,%T0\;b%k1	.Lh8BR%=\;inc.w	#1,%T0\\n.Lh8BR%=:"
-  [(set_attr "cc" "clobber")])
-
-(define_insn_and_split "*cmpstz"
-  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU,WU")
-			 (const_int 1)
-			 (match_operand:QI 1 "immediate_operand" "n,n"))
-	(match_operator:QI 2 "eqne_operator"
-	 [(match_operand 3 "h8300_dst_operand" "r,rQ")
-	  (match_operand 4 "h8300_src_operand" "I,rQi")]))]
-  "TARGET_H8300SX
-   && (GET_MODE (operands[3]) == GET_MODE (operands[4])
-       || GET_CODE (operands[4]) == CONST_INT)
-   && GET_MODE_CLASS (GET_MODE (operands[3])) == MODE_INT
-   && GET_MODE_SIZE (GET_MODE (operands[3])) <= 4"
-  "#"
-  "reload_completed"
-  [(set (cc0) (match_dup 5))
-   (set (zero_extract:QI (match_dup 0) (const_int 1) (match_dup 1))
-	(match_op_dup:QI 2 [(cc0) (const_int 0)]))]
-  {
-    operands[5] = gen_rtx_COMPARE (VOIDmode, operands[3], operands[4]);
-  }
-  [(set_attr "cc" "set_znv,compare")])
-
-(define_insn "*bstz"
-  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU")
-			 (const_int 1)
-			 (match_operand:QI 1 "immediate_operand" "n"))
-	(eq:QI (cc0) (const_int 0)))]
-  "TARGET_H8300SX && reload_completed"
-  "bstz	%1,%0"
-  [(set_attr "cc" "none_0hit")
-   (set_attr "length_table" "unary")])
-
-(define_insn "*bistz"
-  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU")
-			 (const_int 1)
-			 (match_operand:QI 1 "immediate_operand" "n"))
-	(ne:QI (cc0) (const_int 0)))]
-  "TARGET_H8300SX && reload_completed"
-  "bistz	%1,%0"
-  [(set_attr "cc" "none_0hit")
-   (set_attr "length_table" "unary")])
-
-(define_insn_and_split "*cmpcondbset"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
-	(if_then_else:QI (match_operator 1 "eqne_operator"
-			  [(match_operand 2 "h8300_dst_operand" "r,rQ")
-			   (match_operand 3 "h8300_src_operand" "I,rQi")])
-			 (ior:QI (match_operand:QI 4 "bit_memory_operand" "0,0")
-				 (match_operand:QI 5 "single_one_operand" "n,n"))
-			 (match_dup 4)))]
-  "TARGET_H8300SX"
-  "#"
-  "reload_completed"
-  [(set (cc0) (match_dup 6))
-   (set (match_dup 0)
-	(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])
-			 (ior:QI (match_dup 4) (match_dup 5))
-			 (match_dup 4)))]
-  {
-    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
-  }
-  [(set_attr "cc" "set_znv,compare")])
-
-(define_insn "*condbset"
-  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
-	(if_then_else:QI (match_operator:QI 2 "eqne_operator"
-			  [(cc0) (const_int 0)])
-			 (ior:QI (match_operand:QI 3 "bit_memory_operand" "0")
-				 (match_operand:QI 1 "single_one_operand" "n"))
-			 (match_dup 3)))]
-  "TARGET_H8300SX && reload_completed"
-  "bset/%j2\t%V1,%0"
-  [(set_attr "cc" "none_0hit")
-   (set_attr "length_table" "logicb")])
-
-(define_insn_and_split "*cmpcondbclr"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
-	(if_then_else:QI (match_operator 1 "eqne_operator"
-			  [(match_operand 2 "h8300_dst_operand" "r,rQ")
-			   (match_operand 3 "h8300_src_operand" "I,rQi")])
-			 (and:QI (match_operand:QI 4 "bit_memory_operand" "0,0")
-				 (match_operand:QI 5 "single_zero_operand" "n,n"))
-			 (match_dup 4)))]
-  "TARGET_H8300SX"
-  "#"
-  "reload_completed"
-  [(set (cc0) (match_dup 6))
-   (set (match_dup 0)
-	(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])
-			 (and:QI (match_dup 4) (match_dup 5))
-			 (match_dup 4)))]
-  {
-    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
-  }
-  [(set_attr "cc" "set_znv,compare")])
-
-(define_insn "*condbclr"
-  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
-	(if_then_else:QI (match_operator:QI 2 "eqne_operator"
-			  [(cc0) (const_int 0)])
-			 (and:QI (match_operand:QI 3 "bit_memory_operand" "0")
-				 (match_operand:QI 1 "single_zero_operand" "n"))
-			 (match_dup 3)))]
-  "TARGET_H8300SX && reload_completed"
-  "bclr/%j2\t%W1,%0"
-  [(set_attr "cc" "none_0hit")
-   (set_attr "length_table" "logicb")])
-
-(define_insn_and_split "*cmpcondbsetreg"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
-	(if_then_else:QI (match_operator 1 "eqne_operator"
-			  [(match_operand 2 "h8300_dst_operand" "r,rQ")
-			   (match_operand 3 "h8300_src_operand" "I,rQi")])
-			 (ior:QI (match_operand:QI 4 "bit_memory_operand" "0,0")
-				 (ashift:QI (const_int 1)
-					    (match_operand:QI 5 "register_operand" "r,r")))
-			 (match_dup 4)))]
-  "TARGET_H8300SX"
-  "#"
-  "reload_completed"
-  [(set (cc0) (match_dup 6))
-   (set (match_dup 0)
-	(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])
-			 (ior:QI (match_dup 4)
-				 (ashift:QI (const_int 1)
-					    (match_operand:QI 5 "register_operand" "r,r")))
-			 (match_dup 4)))]
-  {
-    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
-  }
-  [(set_attr "cc" "set_znv,compare")])
-
-(define_insn "*condbsetreg"
-  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
-	(if_then_else:QI (match_operator:QI 2 "eqne_operator"
-			  [(cc0) (const_int 0)])
-			 (ior:QI (match_operand:QI 3 "bit_memory_operand" "0")
-				 (ashift:QI (const_int 1)
-					    (match_operand:QI 1 "register_operand" "r")))
-			 (match_dup 3)))]
-  "TARGET_H8300SX && reload_completed"
-  "bset/%j2\t%R1,%0"
-  [(set_attr "cc" "none_0hit")
-   (set_attr "length_table" "logicb")])
-
-(define_insn_and_split "*cmpcondbclrreg"
-  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
-	(if_then_else:QI (match_operator 1 "eqne_operator"
-			  [(match_operand 2 "h8300_dst_operand" "r,rQ")
-			   (match_operand 3 "h8300_src_operand" "I,rQi")])
-			 (and:QI (match_operand:QI 4 "bit_memory_operand" "0,0")
-				 (ashift:QI (const_int 1)
-					    (match_operand:QI 5 "register_operand" "r,r")))
-			 (match_dup 4)))]
-  "TARGET_H8300SX"
-  "#"
-  "reload_completed"
-  [(set (cc0) (match_dup 6))
-   (set (match_dup 0)
-	(if_then_else:QI (match_op_dup 1 [(cc0) (const_int 0)])
-			 (and:QI (match_dup 4)
-				 (ashift:QI (const_int 1)
-					    (match_operand:QI 5 "register_operand" "r,r")))
-			 (match_dup 4)))]
-  {
-    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
-  }
-  [(set_attr "cc" "set_znv,compare")])
-
-(define_insn "*condbclrreg"
-  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
-	(if_then_else:QI (match_operator:QI 2 "eqne_operator"
-			  [(cc0) (const_int 0)])
-			 (and:QI (match_operand:QI 3 "bit_memory_operand" "0")
-				 (ashift:QI (const_int 1)
-					    (match_operand:QI 1 "register_operand" "r")))
-			 (match_dup 3)))]
-  "TARGET_H8300SX && reload_completed"
-  "bclr/%j2\t%R1,%0"
-  [(set_attr "cc" "none_0hit")
-   (set_attr "length_table" "logicb")])
-
-
-;; -----------------------------------------------------------------
-;; COMBINE PATTERNS
-;; -----------------------------------------------------------------
-
-;; insv:SI
-
-(define_insn "*insv_si_1_n"
-  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
-			 (const_int 1)
-			 (match_operand:SI 1 "const_int_operand" "n"))
-	(match_operand:SI 2 "register_operand" "r"))]
-  "(TARGET_H8300H || TARGET_H8300S) && INTVAL (operands[1]) < 16"
-  "bld\\t#0,%w2\;bst\\t%Z1,%Y0"
-  [(set_attr "length" "4")])
-
-(define_insn "*insv_si_1_n_lshiftrt"
-  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
-			 (const_int 1)
-			 (match_operand:SI 1 "const_int_operand" "n"))
-	(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
-		     (match_operand:SI 3 "const_int_operand" "n")))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && INTVAL (operands[1]) < 16
-    && INTVAL (operands[3]) < 16"
-  "bld\\t%Z3,%Y2\;bst\\t%Z1,%Y0"
-  [(set_attr "length" "4")])
-
-(define_insn "*insv_si_1_n_lshiftrt_16"
-  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
-			 (const_int 1)
-			 (match_operand:SI 1 "const_int_operand" "n"))
-	(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
-		     (const_int 16)))]
-  "(TARGET_H8300H || TARGET_H8300S) && INTVAL (operands[1]) < 16"
-  "rotr.w\\t%e2\;rotl.w\\t%e2\;bst\\t%Z1,%Y0"
-  [(set_attr "length" "6")])
-
-(define_insn "*insv_si_8_8"
-  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
-			 (const_int 8)
-			 (const_int 8))
-	(match_operand:SI 1 "register_operand" "r"))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mov.b\\t%w1,%x0"
-  [(set_attr "length" "2")])
-
-(define_insn "*insv_si_8_8_lshiftrt_8"
-  [(set (zero_extract:SI (match_operand:SI 0 "register_operand" "+r")
-			 (const_int 8)
-			 (const_int 8))
-	(lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
-		     (const_int 8)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mov.b\\t%x1,%x0"
-  [(set_attr "length" "2")])
-
-;; extzv:SI
-
-(define_insn "*extzv_8_8"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(zero_extract:SI (match_operand:SI 1 "register_operand" "?0,r")
-			 (const_int 8)
-			 (const_int 8)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "@
-   mov.b\\t%x1,%w0\;extu.w\\t%f0\;extu.l\\t%S0
-   sub.l\\t%S0,%S0\;mov.b\\t%x1,%w0"
-  [(set_attr "cc" "set_znv,clobber")
-   (set_attr "length" "6,4")])
-
-(define_insn "*extzv_8_16"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(zero_extract:SI (match_operand:SI 1 "register_operand" "r")
-			 (const_int 8)
-			 (const_int 16)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mov.w\\t%e1,%f0\;extu.w\\t%f0\;extu.l\\t%S0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length" "6")])
-
-(define_insn "*extzv_16_8"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(zero_extract:SI (match_operand:SI 1 "register_operand" "r")
-			 (const_int 16)
-			 (const_int 8)))
-   (clobber (match_scratch:SI 2 "=&r"))]
-  "TARGET_H8300H"
-  "mov.w\\t%e1,%f2\;mov.b\\t%x1,%w0\;mov.b\\t%w2,%x0\;extu.l\\t%S0"
-  [(set_attr "length" "8")
-   (set_attr "cc" "set_znv")])
-
-;; Extract the exponent of a float.
-
-(define_insn_and_split "*extzv_8_23"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(zero_extract:SI (match_operand:SI 1 "register_operand" "0")
-			 (const_int 8)
-			 (const_int 23)))]
-  "(TARGET_H8300H || TARGET_H8300S)"
-  "#"
-  "&& reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (ashift:SI (match_dup 0)
-			      (const_int 1)))
-	      (clobber (scratch:QI))])
-   (parallel [(set (match_dup 0)
-		   (lshiftrt:SI (match_dup 0)
-				(const_int 24)))
-	      (clobber (scratch:QI))])]
-  "")
-
-;; and:SI
-
-;; ((SImode) HImode) << 15
-
-(define_insn_and_split "*twoshifts_l16_r1"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(and:SI (ashift:SI (match_operand:SI 1 "register_operand" "0")
-			   (const_int 15))
-		(const_int 2147450880)))]
-  "(TARGET_H8300H || TARGET_H8300S)"
-  "#"
-  "&& reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (ashift:SI (match_dup 0)
-			      (const_int 16)))
-	      (clobber (scratch:QI))])
-   (parallel [(set (match_dup 0)
-		   (lshiftrt:SI (match_dup 0)
-				(const_int 1)))
-	      (clobber (scratch:QI))])]
-  "")
-
-;; Transform (SImode << B) & 0xffff into (SImode) (HImode << B).
-
-(define_insn_and_split "*andsi3_ashift_n_lower"
-  [(set (match_operand:SI 0 "register_operand" "=r,r")
-	(and:SI (ashift:SI (match_operand:SI 1 "register_operand" "0,0")
-			   (match_operand:QI 2 "const_int_operand" "S,n"))
-		(match_operand:SI 3 "const_int_operand" "n,n")))
-   (clobber (match_scratch:QI 4 "=X,&r"))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && INTVAL (operands[2]) <= 15
-    && UINTVAL (operands[3]) == ((HOST_WIDE_INT_M1U << INTVAL (operands[2]))
-				 & 0xffff)"
-  "#"
-  "&& reload_completed"
-  [(parallel [(set (match_dup 5)
-		   (ashift:HI (match_dup 5)
-			      (match_dup 2)))
-	      (clobber (match_dup 4))])
-   (set (match_dup 0)
-	(zero_extend:SI (match_dup 5)))]
-  {
-    operands[5] = gen_rtx_REG (HImode, REGNO (operands[0]));
-  })
-
-;; Accept (A >> 30) & 2 and the like.
-
-(define_insn "*andsi3_lshiftrt_n_sb"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
-			     (match_operand:SI 2 "const_int_operand" "n"))
-		(match_operand:SI 3 "single_one_operand" "n")))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && exact_log2 (INTVAL (operands[3])) < 16
-    && INTVAL (operands[2]) + exact_log2 (INTVAL (operands[3])) == 31"
-{
-  operands[3] = GEN_INT (exact_log2 (INTVAL (operands[3])));
-  return "shll.l\\t%S0\;xor.l\\t%S0,%S0\;bst\\t%Z3,%Y0";
-}
-  [(set_attr "length" "8")])
-
-(define_insn_and_split "*andsi3_lshiftrt_9_sb"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "0")
-			     (const_int 9))
-		(const_int 4194304)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "#"
-  "&& reload_completed"
-  [(set (match_dup 0)
-	(and:SI (lshiftrt:SI (match_dup 0)
-			     (const_int 25))
-		(const_int 64)))
-   (parallel [(set (match_dup 0)
-		   (ashift:SI (match_dup 0)
-			      (const_int 16)))
-	      (clobber (scratch:QI))])]
-  "")
-
-;; plus:SI
-
-(define_insn "*addsi3_upper"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "r")
-			  (const_int 65536))
-		 (match_operand:SI 2 "register_operand" "0")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "add.w\\t%f1,%e0"
-  [(set_attr "length" "2")])
-
-(define_insn "*addsi3_lshiftrt_16_zexthi"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
-			      (const_int 16))
-		 (zero_extend:SI (match_operand:HI 2 "register_operand" "0"))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "add.w\\t%e1,%f0\;xor.w\\t%e0,%e0\;rotxl.w\\t%e0"
-  [(set_attr "length" "6")])
-
-(define_insn_and_split "*addsi3_and_r_1"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (and:SI (match_operand:SI 1 "register_operand" "r")
-			 (const_int 1))
-		 (match_operand:SI 2 "register_operand" "0")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "#"
-  "&& reload_completed"
-  [(set (cc0) (compare (zero_extract:SI (match_dup 1)
-					(const_int 1)
-					(const_int 0))
-		       (const_int 0)))
-   (set (pc)
-        (if_then_else (eq (cc0)
-			  (const_int 0))
-		      (label_ref (match_dup 3))
-		      (pc)))
-   (set (match_dup 2)
-        (plus:SI (match_dup 2)
-		 (const_int 1)))
-   (match_dup 3)]
-  {
-    operands[3] = gen_label_rtx ();
-  })
-
-(define_insn_and_split "*addsi3_and_not_r_1"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (and:SI (not:SI (match_operand:SI 1 "register_operand" "r"))
-			 (const_int 1))
-		 (match_operand:SI 2 "register_operand" "0")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "#"
-  "&& reload_completed"
-  [(set (cc0) (compare (zero_extract:SI (match_dup 1)
-					(const_int 1)
-					(const_int 0))
-		       (const_int 0)))
-   (set (pc)
-        (if_then_else (ne (cc0)
-			  (const_int 0))
-		      (label_ref (match_dup 3))
-		      (pc)))
-   (set (match_dup 2)
-        (plus:SI (match_dup 2)
-		 (const_int 1)))
-   (match_dup 3)]
-  {
-    operands[3] = gen_label_rtx ();
-  })
-
-;; [ix]or:HI
-
-(define_insn "*ixorhi3_zext"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(match_operator:HI 1 "iorxor_operator"
-	 [(zero_extend:HI (match_operand:QI 2 "register_operand" "r"))
-	  (match_operand:HI 3 "register_operand" "0")]))]
-  ""
-  "%c1.b\\t%X2,%s0"
-  [(set_attr "length" "2")])
-
-;; [ix]or:SI
-
-(define_insn "*ixorsi3_zext_qi"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(match_operator:SI 1 "iorxor_operator"
-	 [(zero_extend:SI (match_operand:QI 2 "register_operand" "r"))
-	  (match_operand:SI 3 "register_operand" "0")]))]
-  ""
-  "%c1.b\\t%X2,%w0"
-  [(set_attr "length" "2")])
-
-(define_insn "*ixorsi3_zext_hi"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(match_operator:SI 1 "iorxor_operator"
-	 [(zero_extend:SI (match_operand:HI 2 "register_operand" "r"))
-	  (match_operand:SI 3 "register_operand" "0")]))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "%c1.w\\t%T2,%f0"
-  [(set_attr "length" "2")])
-
-(define_insn "*ixorsi3_ashift_16"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(match_operator:SI 1 "iorxor_operator"
-	 [(ashift:SI (match_operand:SI 2 "register_operand" "r")
-		     (const_int 16))
-	  (match_operand:SI 3 "register_operand" "0")]))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "%c1.w\\t%f2,%e0"
-  [(set_attr "length" "2")])
-
-(define_insn "*ixorsi3_lshiftrt_16"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(match_operator:SI 1 "iorxor_operator"
-	 [(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
-		       (const_int 16))
-	  (match_operand:SI 3 "register_operand" "0")]))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "%c1.w\\t%e2,%f0"
-  [(set_attr "length" "2")])
-
-;; ior:HI
-
-(define_insn "*iorhi3_ashift_8"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(ior:HI (ashift:HI (match_operand:HI 1 "register_operand" "r")
-			   (const_int 8))
-		(match_operand:HI 2 "register_operand" "0")))]
-  ""
-  "or.b\\t%s1,%t0"
-  [(set_attr "length" "2")])
-
-(define_insn "*iorhi3_lshiftrt_8"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(ior:HI (lshiftrt:HI (match_operand:HI 1 "register_operand" "r")
-			     (const_int 8))
-		(match_operand:HI 2 "register_operand" "0")))]
-  ""
-  "or.b\\t%t1,%s0"
-  [(set_attr "length" "2")])
-
-(define_insn "*iorhi3_two_qi"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(ior:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "0"))
-		(ashift:HI (match_operand:HI 2 "register_operand" "r")
-			   (const_int 8))))]
-  ""
-  "mov.b\\t%s2,%t0"
-  [(set_attr "length" "2")])
-
-(define_insn "*iorhi3_two_qi_mem"
-  [(set (match_operand:HI 0 "register_operand" "=&r")
-	(ior:HI (zero_extend:HI (match_operand:QI 1 "memory_operand" "m"))
-		(ashift:HI (subreg:HI (match_operand:QI 2 "memory_operand" "m") 0)
-			   (const_int 8))))]
-  ""
-  "mov.b\\t%X2,%t0\;mov.b\\t%X1,%s0"
-  [(set_attr "length" "16")])
-
-(define_split
-  [(set (match_operand:HI 0 "register_operand" "")
-	(ior:HI (zero_extend:HI (match_operand:QI 1 "memory_operand" ""))
-		(ashift:HI (subreg:HI (match_operand:QI 2 "memory_operand" "") 0)
-			   (const_int 8))))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && reload_completed
-    && byte_accesses_mergeable_p (XEXP (operands[2], 0), XEXP (operands[1], 0))"
-  [(set (match_dup 0)
-	(match_dup 3))]
-  {
-    operands[3] = gen_rtx_MEM (HImode, XEXP (operands[2], 0));
-  })
-
-;; ior:SI
-
-(define_insn "*iorsi3_two_hi"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (zero_extend:SI (match_operand:HI 1 "register_operand" "0"))
-		(ashift:SI (match_operand:SI 2 "register_operand" "r")
-			   (const_int 16))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mov.w\\t%f2,%e0"
-  [(set_attr "length" "2")])
-
-(define_insn_and_split "*iorsi3_two_qi_zext"
-  [(set (match_operand:SI 0 "register_operand" "=&r")
-	(ior:SI (zero_extend:SI (match_operand:QI 1 "memory_operand" "m"))
-		(and:SI (ashift:SI (subreg:SI (match_operand:QI 2 "memory_operand" "m") 0)
-				   (const_int 8))
-			(const_int 65280))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "#"
-  "&& reload_completed"
-  [(set (match_dup 3)
-	(ior:HI (zero_extend:HI (match_dup 1))
-		(ashift:HI (subreg:HI (match_dup 2) 0)
-			   (const_int 8))))
-   (set (match_dup 0)
-	(zero_extend:SI (match_dup 3)))]
-  {
-    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));
-  })
-
-(define_insn "*iorsi3_e2f"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (and:SI (match_operand:SI 1 "register_operand" "0")
-			(const_int -65536))
-		(lshiftrt:SI (match_operand:SI 2 "register_operand" "r")
-			     (const_int 16))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mov.w\\t%e2,%f0"
-  [(set_attr "length" "2")])
-
-(define_insn_and_split "*iorsi3_two_qi_sext"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (zero_extend:SI (match_operand:QI 1 "register_operand" "0"))
-		(ashift:SI (sign_extend:SI (match_operand:QI 2 "register_operand" "r"))
-			   (const_int 8))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "#"
-  "&& reload_completed"
-  [(set (match_dup 3)
-	(ior:HI (zero_extend:HI (match_dup 1))
-		(ashift:HI (match_dup 4)
-			   (const_int 8))))
-   (set (match_dup 0)
-	(sign_extend:SI (match_dup 3)))]
-  {
-    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));
-    operands[4] = gen_rtx_REG (HImode, REGNO (operands[2]));
-  })
-
-(define_insn "*iorsi3_w"
-  [(set (match_operand:SI 0 "register_operand" "=r,&r")
-	(ior:SI (and:SI (match_operand:SI 1 "register_operand" "0,0")
-			(const_int -256))
-		(zero_extend:SI (match_operand:QI 2 "general_operand_src" "r,g>"))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mov.b\\t%X2,%w0"
-  [(set_attr "length" "2,8")])
-
-(define_insn "*iorsi3_ashift_31"
-  [(set (match_operand:SI 0 "register_operand" "=&r")
-	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "r")
-			   (const_int 31))
-		(match_operand:SI 2 "register_operand" "0")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "rotxl.l\\t%S0\;bor\\t#0,%w1\;rotxr.l\\t%S0"
-  [(set_attr "length" "6")
-   (set_attr "cc" "set_znv")])
-
-(define_insn "*iorsi3_and_ashift"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (and:SI (ashift:SI (match_operand:SI 1 "register_operand" "r")
-				   (match_operand:SI 2 "const_int_operand" "n"))
-			(match_operand:SI 3 "single_one_operand" "n"))
-		(match_operand:SI 4 "register_operand" "0")))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && (INTVAL (operands[3]) & ~0xffff) == 0"
-{
-  rtx srcpos = GEN_INT (exact_log2 (INTVAL (operands[3]))
-			- INTVAL (operands[2]));
-  rtx dstpos = GEN_INT (exact_log2 (INTVAL (operands[3])));
-  operands[2] = srcpos;
-  operands[3] = dstpos;
-  return "bld\\t%Z2,%Y1\;bor\\t%Z3,%Y0\;bst\\t%Z3,%Y0";
-}
-  [(set_attr "length" "6")])
-
-(define_insn "*iorsi3_and_lshiftrt"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
-				     (match_operand:SI 2 "const_int_operand" "n"))
-			(match_operand:SI 3 "single_one_operand" "n"))
-		(match_operand:SI 4 "register_operand" "0")))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && ((INTVAL (operands[3]) << INTVAL (operands[2])) & ~0xffff) == 0"
-{
-  rtx srcpos = GEN_INT (exact_log2 (INTVAL (operands[3]))
-			+ INTVAL (operands[2]));
-  rtx dstpos = GEN_INT (exact_log2 (INTVAL (operands[3])));
-  operands[2] = srcpos;
-  operands[3] = dstpos;
-  return "bld\\t%Z2,%Y1\;bor\\t%Z3,%Y0\;bst\\t%Z3,%Y0";
-}
-  [(set_attr "length" "6")])
-
-(define_insn "*iorsi3_zero_extract"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (zero_extract:SI (match_operand:SI 1 "register_operand" "r")
-				 (const_int 1)
-				 (match_operand:SI 2 "const_int_operand" "n"))
-		(match_operand:SI 3 "register_operand" "0")))]
-  "(TARGET_H8300H || TARGET_H8300S) && INTVAL (operands[2]) < 16"
-  "bld\\t%Z2,%Y1\;bor\\t#0,%w0\;bst\\t#0,%w0"
-  [(set_attr "length" "6")])
-
-(define_insn "*iorsi3_and_lshiftrt_n_sb"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
-				     (const_int 30))
-			(const_int 2))
-		(match_operand:SI 2 "register_operand" "0")))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "rotl.l\\t%S1\;rotr.l\\t%S1\;bor\\t#1,%w0\;bst\\t#1,%w0"
-  [(set_attr "length" "8")])
-
-(define_insn "*iorsi3_and_lshiftrt_9_sb"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (and:SI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
-				     (const_int 9))
-			(const_int 4194304))
-		(match_operand:SI 2 "register_operand" "0")))
-   (clobber (match_scratch:HI 3 "=&r"))]
-  "TARGET_H8300H || TARGET_H8300S"
-{
-  if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))
-    return "shll.l\\t%S1\;xor.w\\t%T3,%T3\;bst\\t#6,%s3\;or.w\\t%T3,%e0";
-  else
-    return "rotl.l\\t%S1\;rotr.l\\t%S1\;xor.w\\t%T3,%T3\;bst\\t#6,%s3\;or.w\\t%T3,%e0";
-}
-  [(set_attr "length" "10")])
-
-;; Used to OR the exponent of a float.
-
-(define_insn "*iorsi3_shift"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "r")
-			   (const_int 23))
-		(match_operand:SI 2 "register_operand" "0")))
-   (clobber (match_scratch:SI 3 "=&r"))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "#")
-
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "")
-			   (const_int 23))
-		(match_dup 0)))
-   (clobber (match_operand:SI 2 "register_operand" ""))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && epilogue_completed
-    && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))
-    && REGNO (operands[0]) != REGNO (operands[1])"
-  [(parallel [(set (match_dup 3)
-		   (ashift:HI (match_dup 3)
-			      (const_int 7)))
-	      (clobber (scratch:QI))])
-   (set (match_dup 0)
-	(ior:SI (ashift:SI (match_dup 1)
-			   (const_int 16))
-		(match_dup 0)))]
-  {
-    operands[3] = gen_rtx_REG (HImode, REGNO (operands[1]));
-  })
-
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "")
-			   (const_int 23))
-		(match_dup 0)))
-   (clobber (match_operand:SI 2 "register_operand" ""))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && epilogue_completed
-    && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))
-	 && REGNO (operands[0]) != REGNO (operands[1]))"
-  [(set (match_dup 2)
-	(match_dup 1))
-   (parallel [(set (match_dup 3)
-		   (ashift:HI (match_dup 3)
-			      (const_int 7)))
-	      (clobber (scratch:QI))])
-   (set (match_dup 0)
-	(ior:SI (ashift:SI (match_dup 2)
-			   (const_int 16))
-		(match_dup 0)))]
-  {
-    operands[3] = gen_rtx_REG (HImode, REGNO (operands[2]));
-  })
-
-(define_insn "*iorsi2_and_1_lshiftrt_1"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (and:SI (match_operand:SI 1 "register_operand" "0")
-			(const_int 1))
-		(lshiftrt:SI (match_dup 1)
-			     (const_int 1))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "shlr.l\\t%S0\;bor\\t#0,%w0\;bst\\t#0,%w0"
-  [(set_attr "length" "6")])
-
-(define_insn_and_split "*iorsi3_ashift_16_ashift_24"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "0")
-			   (const_int 16))
-		(ashift:SI (match_operand:SI 2 "register_operand" "r")
-			   (const_int 24))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "#"
-  "&& reload_completed"
-  [(set (match_dup 3)
-        (ior:HI (ashift:HI (match_dup 4)
-			   (const_int 8))
-		(match_dup 3)))
-   (parallel [(set (match_dup 0)
-		   (ashift:SI (match_dup 0)
-			      (const_int 16)))
-	      (clobber (scratch:QI))])]
-  {
-    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));
-    operands[4] = gen_rtx_REG (HImode, REGNO (operands[2]));
-  })
-
-(define_insn_and_split "*iorsi3_ashift_16_ashift_24_mem"
-  [(set (match_operand:SI 0 "register_operand" "=&r")
-	(ior:SI (and:SI (ashift:SI (subreg:SI (match_operand:QI 1 "memory_operand" "m") 0)
-				   (const_int 16))
-			(const_int 16711680))
-		(ashift:SI (subreg:SI (match_operand:QI 2 "memory_operand" "m") 0)
-			   (const_int 24))))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "#"
-  "&& reload_completed"
-  [(set (match_dup 3)
-        (ior:HI (zero_extend:HI (match_dup 1))
-		(ashift:HI (subreg:HI (match_dup 2) 0)
-			   (const_int 8))))
-   (parallel [(set (match_dup 0)
-		   (ashift:SI (match_dup 0)
-			      (const_int 16)))
-	      (clobber (scratch:QI))])]
-  {
-    operands[3] = gen_rtx_REG (HImode, REGNO (operands[0]));
-  })
-
-;; Used to add the exponent of a float.
-
-(define_insn "*addsi3_shift"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "r")
-			  (const_int 8388608))
-		 (match_operand:SI 2 "register_operand" "0")))
-   (clobber (match_scratch:SI 3 "=&r"))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "#")
-
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "")
-			  (const_int 8388608))
-		 (match_dup 0)))
-   (clobber (match_operand:SI 2 "register_operand" ""))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && epilogue_completed
-    && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))
-    && REGNO (operands[0]) != REGNO (operands[1])"
-  [(parallel [(set (match_dup 3)
-		   (ashift:HI (match_dup 3)
-			      (const_int 7)))
-	      (clobber (scratch:QI))])
-   (set (match_dup 0)
-	(plus:SI (mult:SI (match_dup 1)
-			  (const_int 65536))
-		 (match_dup 0)))]
-  {
-    operands[3] = gen_rtx_REG (HImode, REGNO (operands[1]));
-  })
-
-(define_split
-  [(set (match_operand:SI 0 "register_operand" "")
-	(plus:SI (mult:SI (match_operand:SI 1 "register_operand" "")
-			  (const_int 8388608))
-		 (match_dup 0)))
-   (clobber (match_operand:SI 2 "register_operand" ""))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && epilogue_completed
-    && !(find_regno_note (insn, REG_DEAD, REGNO (operands[1]))
-	 && REGNO (operands[0]) != REGNO (operands[1]))"
-  [(set (match_dup 2)
-	(match_dup 1))
-   (parallel [(set (match_dup 3)
-		   (ashift:HI (match_dup 3)
-			      (const_int 7)))
-	      (clobber (scratch:QI))])
-   (set (match_dup 0)
-	(plus:SI (mult:SI (match_dup 2)
-			  (const_int 65536))
-		 (match_dup 0)))]
-  {
-    operands[3] = gen_rtx_REG (HImode, REGNO (operands[2]));
-  })
-
-;; ashift:SI
-
-(define_insn_and_split "*ashiftsi_sextqi_7"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(ashift:SI (sign_extend:SI (match_operand:QI 1 "register_operand" "0"))
-		   (const_int 7)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "#"
-  "&& reload_completed"
-  [(parallel [(set (match_dup 2)
-		   (ashift:HI (match_dup 2)
-			      (const_int 8)))
-	      (clobber (scratch:QI))])
-   (set (match_dup 0)
-	(sign_extend:SI (match_dup 2)))
-   (parallel [(set (match_dup 0)
-		   (ashiftrt:SI (match_dup 0)
-				(const_int 1)))
-	      (clobber (scratch:QI))])]
-  {
-    operands[2] = gen_rtx_REG (HImode, REGNO (operands[0]));
-  })
-
-;; Storing a part of HImode to QImode.
-
-(define_insn ""
-  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
-	(subreg:QI (lshiftrt:HI (match_operand:HI 1 "register_operand" "r")
-				(const_int 8)) 1))]
-  ""
-  "mov.b\\t%t1,%R0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length" "8")])
-
-;; Storing a part of SImode to QImode.
-
-(define_insn ""
-  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
-	(subreg:QI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
-				(const_int 8)) 3))]
-  ""
-  "mov.b\\t%x1,%R0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length" "8")])
-
-(define_insn ""
-  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
-	(subreg:QI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
-				(const_int 16)) 3))
-   (clobber (match_scratch:SI 2 "=&r"))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mov.w\\t%e1,%f2\;mov.b\\t%w2,%R0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length" "10")])
-
-(define_insn ""
-  [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
-	(subreg:QI (lshiftrt:SI (match_operand:SI 1 "register_operand" "r")
-				(const_int 24)) 3))
-   (clobber (match_scratch:SI 2 "=&r"))]
-  "TARGET_H8300H || TARGET_H8300S"
-  "mov.w\\t%e1,%f2\;mov.b\\t%x2,%R0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length" "10")])
-
-(define_insn_and_split ""
-  [(set (pc)
-	(if_then_else (eq (zero_extract:SI (subreg:SI (match_operand:QI 0 "register_operand" "") 0)
-					   (const_int 1)
-					   (const_int 7))
-			  (const_int 0))
-		      (label_ref (match_operand 1 "" ""))
-		      (pc)))]
-  ""
-  "#"
-  ""
-  [(set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (ge (cc0)
-			  (const_int 0))
-		      (label_ref (match_dup 1))
-		      (pc)))]
-  "")
-
-(define_insn_and_split ""
-  [(set (pc)
-	(if_then_else (ne (zero_extract:SI (subreg:SI (match_operand:QI 0 "register_operand" "") 0)
-					   (const_int 1)
-					   (const_int 7))
-			  (const_int 0))
-		      (label_ref (match_operand 1 "" ""))
-		      (pc)))]
-  ""
-  "#"
-  ""
-  [(set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (lt (cc0)
-			  (const_int 0))
-		      (label_ref (match_dup 1))
-		      (pc)))]
-  "")
-
-;; -----------------------------------------------------------------
-;; PEEPHOLE PATTERNS
-;; -----------------------------------------------------------------
-
-;; Convert (A >> B) & C to (A & 255) >> B if C == 255 >> B.
-
-(define_peephole2
-  [(parallel [(set (match_operand:HI 0 "register_operand" "")
-		   (lshiftrt:HI (match_dup 0)
-				(match_operand:HI 1 "const_int_operand" "")))
-	      (clobber (match_operand:HI 2 "" ""))])
-   (set (match_dup 0)
-	(and:HI (match_dup 0)
-		(match_operand:HI 3 "const_int_operand" "")))]
-  "INTVAL (operands[3]) == (255 >> INTVAL (operands[1]))"
-  [(set (match_dup 0)
-	(and:HI (match_dup 0)
-		(const_int 255)))
-   (parallel [(set (match_dup 0)
-		   (lshiftrt:HI (match_dup 0) (match_dup 1)))
-	      (clobber (match_dup 2))])]
-  "")
-
-;; Convert (A << B) & C to (A & 255) << B if C == 255 << B.
-
-(define_peephole2
-  [(parallel [(set (match_operand:HI 0 "register_operand" "")
-		   (ashift:HI (match_dup 0)
-			      (match_operand:HI 1 "const_int_operand" "")))
-	      (clobber (match_operand:HI 2 "" ""))])
-   (set (match_dup 0)
-	(and:HI (match_dup 0)
-		(match_operand:HI 3 "const_int_operand" "")))]
-  "INTVAL (operands[3]) == (255 << INTVAL (operands[1]))"
-  [(set (match_dup 0)
-	(and:HI (match_dup 0)
-		(const_int 255)))
-   (parallel [(set (match_dup 0)
-		   (ashift:HI (match_dup 0) (match_dup 1)))
-	      (clobber (match_dup 2))])]
-  "")
-
-;; Convert (A >> B) & C to (A & 255) >> B if C == 255 >> B.
-
-(define_peephole2
-  [(parallel [(set (match_operand:SI 0 "register_operand" "")
-		   (lshiftrt:SI (match_dup 0)
-				(match_operand:SI 1 "const_int_operand" "")))
-	      (clobber (match_operand:SI 2 "" ""))])
-   (set (match_dup 0)
-	(and:SI (match_dup 0)
-		(match_operand:SI 3 "const_int_operand" "")))]
-  "INTVAL (operands[3]) == (255 >> INTVAL (operands[1]))"
-  [(set (match_dup 0)
-	(and:SI (match_dup 0)
-		(const_int 255)))
-   (parallel [(set (match_dup 0)
-		   (lshiftrt:SI (match_dup 0) (match_dup 1)))
-	      (clobber (match_dup 2))])]
-  "")
-
-;; Convert (A << B) & C to (A & 255) << B if C == 255 << B.
-
-(define_peephole2
-  [(parallel [(set (match_operand:SI 0 "register_operand" "")
-		   (ashift:SI (match_dup 0)
-			      (match_operand:SI 1 "const_int_operand" "")))
-	      (clobber (match_operand:SI 2 "" ""))])
-   (set (match_dup 0)
-	(and:SI (match_dup 0)
-		(match_operand:SI 3 "const_int_operand" "")))]
-  "INTVAL (operands[3]) == (255 << INTVAL (operands[1]))"
-  [(set (match_dup 0)
-	(and:SI (match_dup 0)
-		(const_int 255)))
-   (parallel [(set (match_dup 0)
-		   (ashift:SI (match_dup 0) (match_dup 1)))
-	      (clobber (match_dup 2))])]
-  "")
-
-;; Convert (A >> B) & C to (A & 65535) >> B if C == 65535 >> B.
-
-(define_peephole2
-  [(parallel [(set (match_operand:SI 0 "register_operand" "")
-		   (lshiftrt:SI (match_dup 0)
-				(match_operand:SI 1 "const_int_operand" "")))
-	      (clobber (match_operand:SI 2 "" ""))])
-   (set (match_dup 0)
-	(and:SI (match_dup 0)
-		(match_operand:SI 3 "const_int_operand" "")))]
-  "INTVAL (operands[3]) == (65535 >> INTVAL (operands[1]))"
-  [(set (match_dup 0)
-	(and:SI (match_dup 0)
-		(const_int 65535)))
-   (parallel [(set (match_dup 0)
-		   (lshiftrt:SI (match_dup 0) (match_dup 1)))
-	      (clobber (match_dup 2))])]
-  "")
-
-;; Convert (A << B) & C to (A & 65535) << B if C == 65535 << B.
-
-(define_peephole2
-  [(parallel [(set (match_operand:SI 0 "register_operand" "")
-		   (ashift:SI (match_dup 0)
-			      (match_operand:SI 1 "const_int_operand" "")))
-	      (clobber (match_operand:SI 2 "" ""))])
-   (set (match_dup 0)
-	(and:SI (match_dup 0)
-		(match_operand:SI 3 "const_int_operand" "")))]
-  "INTVAL (operands[3]) == (65535 << INTVAL (operands[1]))"
-  [(set (match_dup 0)
-	(and:SI (match_dup 0)
-		(const_int 65535)))
-   (parallel [(set (match_dup 0)
-		   (ashift:SI (match_dup 0) (match_dup 1)))
-	      (clobber (match_dup 2))])]
-  "")
-
-;; Cram four pushes into stm.l.
-
-(define_peephole2
-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-	(match_operand:SI 0 "register_operand" ""))
-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-	(match_operand:SI 1 "register_operand" ""))
-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-	(match_operand:SI 2 "register_operand" ""))
-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-	(match_operand:SI 3 "register_operand" ""))]
-  "TARGET_H8300S && !TARGET_NORMAL_MODE
-   && (REGNO_REG_CLASS (REGNO (operands[3])) == GENERAL_REGS
-       && REGNO (operands[1]) == REGNO (operands[0]) + 1
-       && REGNO (operands[2]) == REGNO (operands[0]) + 2
-       && REGNO (operands[3]) == REGNO (operands[0]) + 3
-       && (TARGET_H8300SX || REGNO (operands[0]) == 0))"
-  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))
-		   (match_dup 0))
-	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))
-		   (match_dup 1))
-	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))
-		   (match_dup 2))
-	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -16)))
-		   (match_dup 3))
-	      (set (reg:SI SP_REG)
-		   (plus:SI (reg:SI SP_REG)
-			    (const_int -16)))])]
-  "")
-
-(define_peephole2
-  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
-	(match_operand:SI 0 "register_operand" ""))
-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
-	(match_operand:SI 1 "register_operand" ""))
-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
-	(match_operand:SI 2 "register_operand" ""))
-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
-	(match_operand:SI 3 "register_operand" ""))]
-  "TARGET_H8300S && TARGET_NORMAL_MODE
-   && (REGNO_REG_CLASS (REGNO (operands[3])) == GENERAL_REGS
-       && REGNO (operands[1]) == REGNO (operands[0]) + 1
-       && REGNO (operands[2]) == REGNO (operands[0]) + 2
-       && REGNO (operands[3]) == REGNO (operands[0]) + 3
-       && (TARGET_H8300SX || REGNO (operands[0]) == 0))"
-  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))
-		   (match_dup 0))
-	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))
-		   (match_dup 1))
-	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))
-		   (match_dup 2))
-	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -16)))
-		   (match_dup 3))
-	      (set (reg:HI SP_REG)
-		   (plus:HI (reg:HI SP_REG)
-			    (const_int -16)))])]
-  "")
-
-;; Cram three pushes into stm.l.
-
-(define_peephole2
-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-	(match_operand:SI 0 "register_operand" ""))
-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-	(match_operand:SI 1 "register_operand" ""))
-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-	(match_operand:SI 2 "register_operand" ""))]
-  "TARGET_H8300S && !TARGET_NORMAL_MODE
-   && (REGNO_REG_CLASS (REGNO (operands[2])) == GENERAL_REGS
-       && REGNO (operands[1]) == REGNO (operands[0]) + 1
-       && REGNO (operands[2]) == REGNO (operands[0]) + 2
-       && (TARGET_H8300SX || (REGNO (operands[0]) & 3) == 0))"
-  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))
-		   (match_dup 0))
-	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))
-		   (match_dup 1))
-	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))
-		   (match_dup 2))
-	      (set (reg:SI SP_REG)
-		   (plus:SI (reg:SI SP_REG)
-			    (const_int -12)))])]
-  "")
-
-(define_peephole2
-  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
-	(match_operand:SI 0 "register_operand" ""))
-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
-	(match_operand:SI 1 "register_operand" ""))
-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
-	(match_operand:SI 2 "register_operand" ""))]
-  "TARGET_H8300S && TARGET_NORMAL_MODE
-   && (REGNO_REG_CLASS (REGNO (operands[2])) == GENERAL_REGS
-       && REGNO (operands[1]) == REGNO (operands[0]) + 1
-       && REGNO (operands[2]) == REGNO (operands[0]) + 2
-       && (TARGET_H8300SX || (REGNO (operands[0]) & 3) == 0))"
-  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))
-		   (match_dup 0))
-	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))
-		   (match_dup 1))
-	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))
-		   (match_dup 2))
-	      (set (reg:HI SP_REG)
-		   (plus:HI (reg:HI SP_REG)
-			    (const_int -12)))])]
-  "")
-
-;; Cram two pushes into stm.l.
-
-(define_peephole2
-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-	(match_operand:SI 0 "register_operand" ""))
-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-	(match_operand:SI 1 "register_operand" ""))]
-  "TARGET_H8300S && !TARGET_NORMAL_MODE
-   && (REGNO_REG_CLASS (REGNO (operands[1])) == GENERAL_REGS
-       && REGNO (operands[1]) == REGNO (operands[0]) + 1
-       && (TARGET_H8300SX || (REGNO (operands[0]) & 1) == 0))"
-  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))
-		   (match_dup 0))
-	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))
-		   (match_dup 1))
-	      (set (reg:SI SP_REG)
-		   (plus:SI (reg:SI SP_REG)
-			    (const_int -8)))])]
-  "")
-
-(define_peephole2
-  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
-	(match_operand:SI 0 "register_operand" ""))
-   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
-	(match_operand:SI 1 "register_operand" ""))]
-  "TARGET_H8300S && TARGET_NORMAL_MODE
-   && (REGNO_REG_CLASS (REGNO (operands[1])) == GENERAL_REGS
-       && REGNO (operands[1]) == REGNO (operands[0]) + 1
-       && (TARGET_H8300SX || (REGNO (operands[0]) & 1) == 0))"
-  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))
-		   (match_dup 0))
-	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))
-		   (match_dup 1))
-	      (set (reg:HI SP_REG)
-		   (plus:HI (reg:HI SP_REG)
-			    (const_int -8)))])]
-  "")
-
-;; Turn
-;;
-;;   mov.w #2,r0
-;;   add.w r7,r0  (6 bytes)
-;;
-;; into
-;;
-;;   mov.w r7,r0
-;;   adds  #2,r0  (4 bytes)
-
-(define_peephole2
-  [(set (match_operand:HI 0 "register_operand" "")
-	(match_operand:HI 1 "const_int_operand" ""))
-   (set (match_dup 0)
-	(plus:HI (match_dup 0)
-		 (match_operand:HI 2 "register_operand" "")))]
-  "REG_P (operands[0]) && REG_P (operands[2])
-   && REGNO (operands[0]) != REGNO (operands[2])
-   && (satisfies_constraint_J (operands[1])
-       || satisfies_constraint_L (operands[1])
-       || satisfies_constraint_N (operands[1]))"
-  [(set (match_dup 0)
-	(match_dup 2))
-   (set (match_dup 0)
-	(plus:HI (match_dup 0)
-		 (match_dup 1)))]
-  "")
-
-;; Turn
-;;
-;;   sub.l  er0,er0
-;;   add.b  #4,r0l
-;;   add.l  er7,er0  (6 bytes)
-;;
-;; into
-;;
-;;   mov.l  er7,er0
-;;   adds   #4,er0   (4 bytes)
-
-(define_peephole2
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operand:SI 1 "const_int_operand" ""))
-   (set (match_dup 0)
-	(plus:SI (match_dup 0)
-		 (match_operand:SI 2 "register_operand" "")))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && REG_P (operands[0]) && REG_P (operands[2])
-    && REGNO (operands[0]) != REGNO (operands[2])
-    && (satisfies_constraint_L (operands[1])
-	|| satisfies_constraint_N (operands[1]))"
-  [(set (match_dup 0)
-	(match_dup 2))
-   (set (match_dup 0)
-	(plus:SI (match_dup 0)
-		 (match_dup 1)))]
-  "")
-
-;; Turn
-;;
-;;   mov.l er7,er0
-;;   add.l #10,er0  (takes 8 bytes)
-;;
-;; into
-;;
-;;   sub.l er0,er0
-;;   add.b #10,r0l
-;;   add.l er7,er0  (takes 6 bytes)
-
-(define_peephole2
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operand:SI 1 "register_operand" ""))
-   (set (match_dup 0)
-	(plus:SI (match_dup 0)
-		 (match_operand:SI 2 "const_int_operand" "")))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && operands[0] != stack_pointer_rtx
-    && REG_P (operands[0]) && REG_P (operands[1])
-    && REGNO (operands[0]) != REGNO (operands[1])
-    && !satisfies_constraint_L (operands[2])
-    && !satisfies_constraint_N (operands[2])
-    && ((INTVAL (operands[2]) & 0xff) == INTVAL (operands[2])
-	|| (INTVAL (operands[2]) & 0xff00) == INTVAL (operands[2])
-	|| INTVAL (operands[2]) == 0xffff
-	|| INTVAL (operands[2]) == 0xfffe)"
-  [(set (match_dup 0)
-	(match_dup 2))
-   (set (match_dup 0)
-	(plus:SI (match_dup 0)
-		 (match_dup 1)))]
-  "")
-
-;; Turn
-;;
-;;   subs   #1,er4
-;;   mov.w  r4,r4
-;;   bne    .L2028
-;;
-;; into
-;;
-;;   dec.w  #1,r4
-;;   bne    .L2028
-
-(define_peephole2
-  [(set (match_operand:HI 0 "register_operand" "")
-	(plus:HI (match_dup 0)
-		 (match_operand 1 "incdec_operand" "")))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_operator 3 "eqne_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  [(set (match_operand:HI 0 "register_operand" "")
-	(unspec:HI [(match_dup 0)
-		    (match_dup 1)]
-		   UNSPEC_INCDEC))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  "")
-
-;; The SImode version of the previous pattern.
-
-(define_peephole2
-  [(set (match_operand:SI 0 "register_operand" "")
-	(plus:SI (match_dup 0)
-		 (match_operand 1 "incdec_operand" "")))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_operator 3 "eqne_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(unspec:SI [(match_dup 0)
-		    (match_dup 1)]
-		   UNSPEC_INCDEC))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  "")
-
-(define_peephole2
-  [(parallel [(set (cc0)
-		   (compare (zero_extract:SI (match_operand:QI 0 "register_operand" "")
-					     (const_int 1)
-					     (const_int 7))
-			    (const_int 0)))
-	      (clobber (scratch:QI))])
-   (set (pc)
-	(if_then_else (match_operator 1 "eqne_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  [(set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  {
-    operands[3] = ((GET_CODE (operands[1]) == EQ)
-		   ? gen_rtx_GE (VOIDmode, cc0_rtx, const0_rtx)
-		   : gen_rtx_LT (VOIDmode, cc0_rtx, const0_rtx));
-  })
-
-;; The next three peephole2's will try to transform
-;;
-;;   mov.b A,r0l    (or mov.l A,er0)
-;;   and.l #CST,er0
-;;
-;; into
-;;
-;;   sub.l er0
-;;   mov.b A,r0l
-;;   and.b #CST,r0l (if CST is not 255)
-
-(define_peephole2
-  [(set (match_operand:QI 0 "register_operand" "")
-	(match_operand:QI 1 "general_operand" ""))
-   (set (match_operand:SI 2 "register_operand" "")
-	(and:SI (match_dup 2)
-		(const_int 255)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && !reg_overlap_mentioned_p (operands[2], operands[1])
-    && REGNO (operands[0]) == REGNO (operands[2])"
-  [(set (match_dup 2)
-	(const_int 0))
-   (set (strict_low_part (match_dup 0))
-	(match_dup 1))]
-  "")
-
-(define_peephole2
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operand:SI 1 "nonimmediate_operand" ""))
-   (set (match_dup 0)
-	(and:SI (match_dup 0)
-		(const_int 255)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && !reg_overlap_mentioned_p (operands[0], operands[1])
-    && !(GET_CODE (operands[1]) == MEM && !offsettable_memref_p (operands[1]))
-    && !(GET_CODE (operands[1]) == MEM && MEM_VOLATILE_P (operands[1]))"
-  [(set (match_dup 0)
-	(const_int 0))
-   (set (strict_low_part (match_dup 2))
-	(match_dup 3))]
-  {
-    operands[2] = gen_lowpart (QImode, operands[0]);
-    operands[3] = gen_lowpart (QImode, operands[1]);
-  })
-
-(define_peephole2
-  [(set (match_operand 0 "register_operand" "")
-	(match_operand 1 "nonimmediate_operand" ""))
-   (set (match_operand:SI 2 "register_operand" "")
-	(and:SI (match_dup 2)
-		(match_operand:SI 3 "const_int_qi_operand" "")))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && (GET_MODE (operands[0]) == QImode
-	|| GET_MODE (operands[0]) == HImode
-	|| GET_MODE (operands[0]) == SImode)
-    && GET_MODE (operands[0]) == GET_MODE (operands[1])
-    && REGNO (operands[0]) == REGNO (operands[2])
-    && !reg_overlap_mentioned_p (operands[2], operands[1])
-    && !(GET_MODE (operands[1]) != QImode
-	 && GET_CODE (operands[1]) == MEM
-	 && !offsettable_memref_p (operands[1]))
-    && !(GET_MODE (operands[1]) != QImode
-	 && GET_CODE (operands[1]) == MEM
-	 && MEM_VOLATILE_P (operands[1]))"
-  [(set (match_dup 2)
-	(const_int 0))
-   (set (strict_low_part (match_dup 4))
-	(match_dup 5))
-   (set (match_dup 2)
-	(and:SI (match_dup 2)
-		(match_dup 6)))]
-  {
-    operands[4] = gen_lowpart (QImode, operands[0]);
-    operands[5] = gen_lowpart (QImode, operands[1]);
-    operands[6] = GEN_INT (~0xff | INTVAL (operands[3]));
-  })
-
-(define_peephole2
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operand:SI 1 "register_operand" ""))
-   (set (match_dup 0)
-	(and:SI (match_dup 0)
-		(const_int 65280)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-   && !reg_overlap_mentioned_p (operands[0], operands[1])"
-  [(set (match_dup 0)
-	(const_int 0))
-   (set (zero_extract:SI (match_dup 0)
-			 (const_int 8)
-			 (const_int 8))
-	(lshiftrt:SI (match_dup 1)
-		     (const_int 8)))]
-  "")
-
-;; If a load of mem:SI is followed by an AND that turns off the upper
-;; half, then we can load mem:HI instead.
-
-(define_peephole2
-  [(set (match_operand:SI 0 "register_operand" "")
-	(match_operand:SI 1 "memory_operand" ""))
-   (set (match_dup 0)
-	(and:SI (match_dup 0)
-		(match_operand:SI 2 "const_int_operand" "")))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && !MEM_VOLATILE_P (operands[1])
-    && offsettable_memref_p (operands[1])
-    && (INTVAL (operands[2]) & ~0xffff) == 0
-    && INTVAL (operands[2]) != 255"
-  [(set (match_dup 3)
-	(match_dup 4))
-   (set (match_dup 0)
-	(and:SI (match_dup 0)
-		(match_dup 2)))]
-  {
-    operands[3] = gen_lowpart (HImode, operands[0]);
-    operands[4] = gen_lowpart (HImode, operands[1]);
-  })
-
-;; Convert a memory comparison to a move if there is a scratch register.
-
-(define_peephole2
-  [(match_scratch:QI 1 "r")
-   (set (cc0)
-	(compare (match_operand:QI 0 "memory_operand" "")
-		 (const_int 0)))]
-  ""
-  [(set (match_dup 1)
-	(match_dup 0))
-   (set (cc0) (compare (match_dup 1)
-		       (const_int 0)))]
-  "")
-
-(define_peephole2
-  [(match_scratch:HI 1 "r")
-   (set (cc0)
-	(compare (match_operand:HI 0 "memory_operand" "")
-		 (const_int 0)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  [(set (match_dup 1)
-	(match_dup 0))
-   (set (cc0) (compare (match_dup 1)
-		       (const_int 0)))]
-  "")
-
-(define_peephole2
-  [(match_scratch:SI 1 "r")
-   (set (cc0)
-	(compare (match_operand:SI 0 "memory_operand" "")
-		 (const_int 0)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  [(set (match_dup 1)
-	(match_dup 0))
-   (set (cc0) (compare (match_dup 1)
-		       (const_int 0)))]
-  "")
-
-
-;; (compare (reg:HI) (const_int)) takes 4 bytes, so we try to achieve
-;; the equivalent with shorter sequences.  Here is the summary.  Cases
-;; are grouped for each define_peephole2.
-;;
-;; reg  const_int                   use     insn
-;; --------------------------------------------------------
-;; dead    -2                       eq/ne   inc.l
-;; dead    -1                       eq/ne   inc.l
-;; dead     1                       eq/ne   dec.l
-;; dead     2                       eq/ne   dec.l
-;;
-;; dead     1                       ge/lt shar.l
-;; dead     3 (H8S)                 ge/lt shar.l
-;;
-;; dead     1                       geu/ltu shar.l
-;; dead     3 (H8S)                 geu/ltu shar.l
-;;
-;; ----   255                       ge/lt mov.b
-;;
-;; ----   255                       geu/ltu mov.b
-
-;; Transform
-;;
-;;	cmp.w	#1,r0
-;;	bne	.L1
-;;
-;; into
-;;
-;;	dec.w	#1,r0
-;;	bne	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:HI 0 "register_operand" "")
-		 (match_operand:HI 1 "incdec_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 3 "eqne_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && INTVAL (operands[1]) != 0
-    && peep2_reg_dead_p (1, operands[0])"
-  [(set (match_dup 0)
-	(unspec:HI [(match_dup 0)
-		    (match_dup 4)]
-		   UNSPEC_INCDEC))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  {
-    operands[4] = GEN_INT (- INTVAL (operands[1]));
-  })
-
-;; Transform
-;;
-;;	cmp.w	#1,r0
-;;	bgt	.L1
-;;
-;; into
-;;
-;;	shar.w	r0
-;;	bgt	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:HI 0 "register_operand" "")
-		 (match_operand:HI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 2 "gtle_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 3 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && peep2_reg_dead_p (1, operands[0])
-    && (INTVAL (operands[1]) == 1
-	|| (TARGET_H8300S && INTVAL (operands[1]) == 3))"
-  [(parallel [(set (match_dup 0)
-		   (ashiftrt:HI (match_dup 0)
-				(match_dup 4)))
-	      (clobber (scratch:QI))])
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 2)
-		      (label_ref (match_dup 3))
-		      (pc)))]
-  {
-    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
-  })
-
-;; Transform
-;;
-;;	cmp.w	#1,r0
-;;	bhi	.L1
-;;
-;; into
-;;
-;;	shar.w	r0
-;;	bne	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:HI 0 "register_operand" "")
-		 (match_operand:HI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 2 "gtuleu_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 3 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && peep2_reg_dead_p (1, operands[0])
-    && (INTVAL (operands[1]) == 1
-	|| (TARGET_H8300S && INTVAL (operands[1]) == 3))"
-  [(parallel [(set (match_dup 0)
-		   (ashiftrt:HI (match_dup 0)
-				(match_dup 4)))
-	      (clobber (scratch:QI))])
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 5)
-		      (label_ref (match_dup 3))
-		      (pc)))]
-  {
-    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
-    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,
-				  VOIDmode, cc0_rtx, const0_rtx);
-  })
-
-;; Transform
-;;
-;;	cmp.w	#255,r0
-;;	bgt	.L1
-;;
-;; into
-;;
-;;	mov.b	r0h,r0h
-;;	bgt	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:HI 0 "register_operand" "")
-		 (const_int 255)))
-   (set (pc)
-	(if_then_else (match_operator 1 "gtle_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  [(set (cc0) (compare (and:HI (match_dup 0)
-			       (const_int -256))
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 1)
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  "")
-
-;; Transform
-;;
-;;	cmp.w	#255,r0
-;;	bhi	.L1
-;;
-;; into
-;;
-;;	mov.b	r0h,r0h
-;;	bne	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:HI 0 "register_operand" "")
-		 (const_int 255)))
-   (set (pc)
-	(if_then_else (match_operator 1 "gtuleu_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  [(set (cc0) (compare (and:HI (match_dup 0)
-			       (const_int -256))
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 3)
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  {
-    operands[3] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,
-				  VOIDmode, cc0_rtx, const0_rtx);
-  })
-
-;; (compare (reg:SI) (const_int)) takes 6 bytes, so we try to achieve
-;; the equivalent with shorter sequences.  Here is the summary.  Cases
-;; are grouped for each define_peephole2.
-;;
-;; reg  const_int                   use     insn
-;; --------------------------------------------------------
-;; live    -2                       eq/ne   copy and inc.l
-;; live    -1                       eq/ne   copy and inc.l
-;; live     1                       eq/ne   copy and dec.l
-;; live     2                       eq/ne   copy and dec.l
-;;
-;; dead    -2                       eq/ne   inc.l
-;; dead    -1                       eq/ne   inc.l
-;; dead     1                       eq/ne   dec.l
-;; dead     2                       eq/ne   dec.l
-;;
-;; dead -131072                     eq/ne   inc.w and test
-;; dead  -65536                     eq/ne   inc.w and test
-;; dead   65536                     eq/ne   dec.w and test
-;; dead  131072                     eq/ne   dec.w and test
-;;
-;; dead 0x000000?? except 1 and 2   eq/ne   xor.b and test
-;; dead 0x0000??00                  eq/ne   xor.b and test
-;; dead 0x0000ffff                  eq/ne   not.w and test
-;;
-;; dead 0xffffff?? except -1 and -2 eq/ne   xor.b and not.l
-;; dead 0xffff??ff                  eq/ne   xor.b and not.l
-;; dead 0x40000000 (H8S)            eq/ne   rotl.l and dec.l
-;; dead 0x80000000                  eq/ne   rotl.l and dec.l
-;;
-;; live     1                       ge/lt copy and shar.l
-;; live     3 (H8S)                 ge/lt copy and shar.l
-;;
-;; live     1                       geu/ltu copy and shar.l
-;; live     3 (H8S)                 geu/ltu copy and shar.l
-;;
-;; dead     1                       ge/lt shar.l
-;; dead     3 (H8S)                 ge/lt shar.l
-;;
-;; dead     1                       geu/ltu shar.l
-;; dead     3 (H8S)                 geu/ltu shar.l
-;;
-;; dead     3 (H8/300H)             ge/lt and.b and test
-;; dead     7                       ge/lt and.b and test
-;; dead    15                       ge/lt and.b and test
-;; dead    31                       ge/lt and.b and test
-;; dead    63                       ge/lt and.b and test
-;; dead   127                       ge/lt and.b and test
-;; dead   255                       ge/lt and.b and test
-;;
-;; dead     3 (H8/300H)             geu/ltu and.b and test
-;; dead     7                       geu/ltu and.b and test
-;; dead    15                       geu/ltu and.b and test
-;; dead    31                       geu/ltu and.b and test
-;; dead    63                       geu/ltu and.b and test
-;; dead   127                       geu/ltu and.b and test
-;; dead   255                       geu/ltu and.b and test
-;;
-;; ---- 65535                       ge/lt mov.w
-;;
-;; ---- 65535                       geu/ltu mov.w
-
-;; Transform
-;;
-;;	cmp.l	#1,er0
-;;	beq	.L1
-;;
-;; into
-;;
-;;	dec.l	#1,er0
-;;	beq	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "incdec_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 3 "eqne_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && INTVAL (operands[1]) != 0
-    && peep2_reg_dead_p (1, operands[0])"
-  [(set (match_dup 0)
-	(unspec:SI [(match_dup 0)
-		    (match_dup 4)]
-		   UNSPEC_INCDEC))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  {
-    operands[4] = GEN_INT (- INTVAL (operands[1]));
-  })
-
-;; Transform
-;;
-;;	cmp.l	#65536,er0
-;;	beq	.L1
-;;
-;; into
-;;
-;;	dec.l	#1,e0
-;;	beq	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 3 "eqne_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && peep2_reg_dead_p (1, operands[0])
-    && (INTVAL (operands[1]) == -131072
-	|| INTVAL (operands[1]) == -65536
-	|| INTVAL (operands[1]) == 65536
-	|| INTVAL (operands[1]) == 131072)"
-  [(set (match_dup 0)
-	(plus:SI (match_dup 0)
-		 (match_dup 4)))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  {
-    operands[4] = GEN_INT (- INTVAL (operands[1]));
-  })
-
-;; Transform
-;;
-;;	cmp.l	#100,er0
-;;	beq	.L1
-;;
-;; into
-;;
-;;	xor.b	#100,er0
-;;	mov.l	er0,er0
-;;	beq	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 3 "eqne_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && peep2_reg_dead_p (1, operands[0])
-    && ((INTVAL (operands[1]) & 0x00ff) == INTVAL (operands[1])
-	|| (INTVAL (operands[1]) & 0xff00) == INTVAL (operands[1])
-	|| INTVAL (operands[1]) == 0x0000ffff)
-    && INTVAL (operands[1]) != 0
-    && INTVAL (operands[1]) != 1
-    && INTVAL (operands[1]) != 2"
-  [(set (match_dup 0)
-	(xor:SI (match_dup 0)
-		(match_dup 1)))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  "")
-
-;; Transform
-;;
-;;	cmp.l	#-100,er0
-;;	beq	.L1
-;;
-;; into
-;;
-;;	xor.b	#99,er0
-;;	not.l	er0
-;;	beq	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 3 "eqne_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && peep2_reg_dead_p (1, operands[0])
-    && ((INTVAL (operands[1]) | 0x00ff) == -1
-	|| (INTVAL (operands[1]) | 0xff00) == -1)
-    && INTVAL (operands[1]) != -1
-    && INTVAL (operands[1]) != -2"
-  [(set (match_dup 0)
-	(xor:SI (match_dup 0)
-		(match_dup 4)))
-   (set (match_dup 0)
-	(not:SI (match_dup 0)))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  {
-    operands[4] = GEN_INT (INTVAL (operands[1]) ^ -1);
-  })
-
-;; Transform
-;;
-;;	cmp.l	#-2147483648,er0
-;;	beq	.L1
-;;
-;; into
-;;
-;;	rotl.l	er0
-;;	dec.l	#1,er0
-;;	beq	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 3 "eqne_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && peep2_reg_dead_p (1, operands[0])
-    && (INTVAL (operands[1]) == -2147483647 - 1
-	|| (TARGET_H8300S && INTVAL (operands[1]) == 1073741824))"
-  [(set (match_dup 0)
-	(rotate:SI (match_dup 0)
-		   (match_dup 4)))
-   (set (match_dup 0)
-	(unspec:SI [(match_dup 0)
-		    (const_int -1)]
-		   UNSPEC_INCDEC))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  {
-    operands[4] = GEN_INT (INTVAL (operands[1]) == -2147483647 - 1 ? 1 : 2);
-  })
-
-;; Transform
-;;
-;;	cmp.l	#1,er0
-;;	bgt	.L1
-;;
-;; into
-;;
-;;	mov.l	er0,er1
-;;	shar.l	er1
-;;	bgt	.L1
-
-;; We avoid this transformation if we see more than one copy of the
-;; same compare insn immediately before this one.
-
-(define_peephole2
-  [(match_scratch:SI 4 "r")
-   (set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 2 "gtle_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 3 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && !peep2_reg_dead_p (1, operands[0])
-    && (INTVAL (operands[1]) == 1
-	|| (TARGET_H8300S && INTVAL (operands[1]) == 3))
-    && !same_cmp_preceding_p (insn)"
-  [(set (match_dup 4)
-	(match_dup 0))
-   (parallel [(set (match_dup 4)
-		   (ashiftrt:SI (match_dup 4)
-				(match_dup 5)))
-	      (clobber (scratch:QI))])
-   (set (cc0) (compare (match_dup 4)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 2)
-		      (label_ref (match_dup 3))
-		      (pc)))]
-  {
-    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
-  })
-
-;; Transform
-;;
-;;	cmp.l	#1,er0
-;;	bhi	.L1
-;;
-;; into
-;;
-;;	mov.l	er0,er1
-;;	shar.l	er1
-;;	bne	.L1
-
-;; We avoid this transformation if we see more than one copy of the
-;; same compare insn immediately before this one.
-
-(define_peephole2
-  [(match_scratch:SI 4 "r")
-   (set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 2 "gtuleu_operator"
-		         [(cc0) (const_int 0)])
-		      (label_ref (match_operand 3 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && !peep2_reg_dead_p (1, operands[0])
-    && (INTVAL (operands[1]) == 1
-	|| (TARGET_H8300S && INTVAL (operands[1]) == 3))
-    && !same_cmp_preceding_p (insn)"
-  [(set (match_dup 4)
-	(match_dup 0))
-   (parallel [(set (match_dup 4)
-		   (ashiftrt:SI (match_dup 4)
-				(match_dup 5)))
-	      (clobber (scratch:QI))])
-   (set (cc0) (compare (match_dup 4)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 6)
-		      (label_ref (match_dup 3))
-		      (pc)))]
-  {
-    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
-    operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,
-				  VOIDmode, cc0_rtx, const0_rtx);
-  })
-
-;; Transform
-;;
-;;	cmp.l	#1,er0
-;;	bgt	.L1
-;;
-;; into
-;;
-;;	shar.l	er0
-;;	bgt	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 2 "gtle_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 3 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && peep2_reg_dead_p (1, operands[0])
-    && (INTVAL (operands[1]) == 1
-        || (TARGET_H8300S && INTVAL (operands[1]) == 3))"
-  [(parallel [(set (match_dup 0)
-		   (ashiftrt:SI (match_dup 0)
-				(match_dup 4)))
-	      (clobber (scratch:QI))])
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 2)
-		      (label_ref (match_dup 3))
-		      (pc)))]
-  {
-    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
-  })
-
-;; Transform
-;;
-;;	cmp.l	#1,er0
-;;	bhi	.L1
-;;
-;; into
-;;
-;;	shar.l	er0
-;;	bne	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 2 "gtuleu_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 3 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && peep2_reg_dead_p (1, operands[0])
-    && (INTVAL (operands[1]) == 1
-	|| (TARGET_H8300S && INTVAL (operands[1]) == 3))"
-  [(parallel [(set (match_dup 0)
-		   (ashiftrt:SI (match_dup 0)
-				(match_dup 4)))
-	      (clobber (scratch:QI))])
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 5)
-		      (label_ref (match_dup 3))
-		      (pc)))]
-  {
-    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
-    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,
-				  VOIDmode, cc0_rtx, const0_rtx);
-  })
-
-;; Transform
-;;
-;;	cmp.l	#15,er0
-;;	bgt	.L1
-;;
-;; into
-;;
-;;	and	#240,r0l
-;;	mov.l	er0,er0
-;;	bgt	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 2 "gtle_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 3 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && peep2_reg_dead_p (1, operands[0])
-    && (INTVAL (operands[1]) == 3
-	 || INTVAL (operands[1]) == 7
-	 || INTVAL (operands[1]) == 15
-	 || INTVAL (operands[1]) == 31
-	 || INTVAL (operands[1]) == 63
-	 || INTVAL (operands[1]) == 127
-	 || INTVAL (operands[1]) == 255)"
-  [(set (match_dup 0)
-	(and:SI (match_dup 0)
-		(match_dup 4)))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 2)
-		      (label_ref (match_dup 3))
-		      (pc)))]
-  {
-    operands[4] = GEN_INT (~INTVAL (operands[1]));
-  })
-
-;; Transform
-;;
-;;	cmp.l	#15,er0
-;;	bhi	.L1
-;;
-;; into
-;;
-;;	and	#240,r0l
-;;	mov.l	er0,er0
-;;	bne	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "const_int_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 2 "gtuleu_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 3 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && peep2_reg_dead_p (1, operands[0])
-    && ((TARGET_H8300H && INTVAL (operands[1]) == 3)
-	 || INTVAL (operands[1]) == 7
-	 || INTVAL (operands[1]) == 15
-	 || INTVAL (operands[1]) == 31
-	 || INTVAL (operands[1]) == 63
-	 || INTVAL (operands[1]) == 127
-	 || INTVAL (operands[1]) == 255)"
-  [(set (match_dup 0)
-	(and:SI (match_dup 0)
-		(match_dup 4)))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 5)
-		      (label_ref (match_dup 3))
-		      (pc)))]
-  {
-    operands[4] = GEN_INT (~INTVAL (operands[1]));
-    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,
-				  VOIDmode, cc0_rtx, const0_rtx);
-  })
-
-;; Transform
-;;
-;;	cmp.l	#65535,er0
-;;	bgt	.L1
-;;
-;; into
-;;
-;;	mov.l	e0,e0
-;;	bgt	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (const_int 65535)))
-   (set (pc)
-	(if_then_else (match_operator 1 "gtle_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  [(set (cc0) (compare (and:SI (match_dup 0)
-			       (const_int -65536))
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 1)
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  "")
-
-;; Transform
-;;
-;;	cmp.l	#65535,er0
-;;	bhi	.L1
-;;
-;; into
-;;
-;;	mov.l	e0,e0
-;;	bne	.L1
-
-(define_peephole2
-  [(set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (const_int 65535)))
-   (set (pc)
-	(if_then_else (match_operator 1 "gtuleu_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "TARGET_H8300H || TARGET_H8300S"
-  [(set (cc0) (compare (and:SI (match_dup 0)
-			       (const_int -65536))
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_dup 3)
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  {
-    operands[3] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,
-				  VOIDmode, cc0_rtx, const0_rtx);
-  })
-
-;; Transform
-;;
-;;	cmp.l	#1,er0
-;;	beq	.L1
-;;
-;; into
-;;
-;;	mov.l	er0,er1
-;;	dec.l	#1,er1
-;;	beq	.L1
-
-;; We avoid this transformation if we see more than one copy of the
-;; same compare insn.
-
-(define_peephole2
-  [(match_scratch:SI 4 "r")
-   (set (cc0)
-	(compare (match_operand:SI 0 "register_operand" "")
-		 (match_operand:SI 1 "incdec_operand" "")))
-   (set (pc)
-	(if_then_else (match_operator 3 "eqne_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "(TARGET_H8300H || TARGET_H8300S)
-    && INTVAL (operands[1]) != 0
-    && !peep2_reg_dead_p (1, operands[0])
-    && !same_cmp_following_p (insn)"
-  [(set (match_dup 4)
-	(match_dup 0))
-   (set (match_dup 4)
-	(unspec:SI [(match_dup 4)
-		    (match_dup 5)]
-		   UNSPEC_INCDEC))
-   (set (cc0) (compare (match_dup 4)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  {
-    operands[5] = GEN_INT (- INTVAL (operands[1]));
-  })
-
-;; Narrow the mode of testing if possible.
-
-(define_peephole2
-  [(set (match_operand:HSI 0 "register_operand" "")
-	(and:HSI (match_dup 0)
-		 (match_operand:HSI 1 "const_int_operand" "")))
-   (set (cc0) (compare (match_dup 0)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_operator 3 "eqne_operator"
-		       [(cc0) (const_int 0)])
-		      (label_ref (match_operand 2 "" ""))
-		      (pc)))]
-  "((const_int_qi_operand (operands[1], QImode)
-     || (GET_MODE (operands[0]) == SImode
-	 && const_int_hi_operand (operands[1], HImode)))
-    && peep2_reg_dead_p (2, operands[0]))"
-  [(set (match_dup 4) (match_dup 6))
-   (set (cc0) (compare (match_dup 4)
-		       (const_int 0)))
-   (set (pc)
-	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
-		      (label_ref (match_dup 2))
-		      (pc)))]
-  {
-    enum machine_mode mode;
-
-    mode = const_int_qi_operand (operands[1], QImode) ? QImode : HImode;
-    operands[4] = gen_rtx_REG (mode, REGNO (operands[0]));
-    operands[5] = gen_int_mode (INTVAL (operands[1]), mode);
-    operands[6] = gen_rtx_AND (mode, operands[4], operands[5]);
-  })
-
-;; These triggers right at the end of allocation of locals in the
-;; prologue (and possibly at other places).
-
-;; stack adjustment of -4, generate one push
-;;
-;; before : 6 bytes, 10 clocks
-;; after  : 4 bytes, 10 clocks
-
-(define_peephole2
-  [(set (reg:SI SP_REG)
-	(plus:SI (reg:SI SP_REG)
-		 (const_int -4)))
-   (set (mem:SI (reg:SI SP_REG))
-	(match_operand:SI 0 "register_operand" ""))]
-  "(TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE
-    && REGNO (operands[0]) != SP_REG"
-  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-	(match_dup 0))]
-  "")
-
-;; stack adjustment of -12, generate one push
-;;
-;; before : 10 bytes, 14 clocks
-;; after  :  8 bytes, 14 clocks
-
-(define_peephole2
-  [(set (reg:SI SP_REG)
-	(plus:SI (reg:SI SP_REG)
-		 (const_int -12)))
-   (set (mem:SI (reg:SI SP_REG))
-	(match_operand:SI 0 "register_operand" ""))]
-  "(TARGET_H8300H || TARGET_H8300S) && !TARGET_NORMAL_MODE
-    && REGNO (operands[0]) != SP_REG"
-  [(set (reg:SI SP_REG)
-	(plus:SI (reg:SI SP_REG)
-		 (const_int -4)))
-   (set (reg:SI SP_REG)
-	(plus:SI (reg:SI SP_REG)
-		 (const_int -4)))
-   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
-	(match_dup 0))]
-  "")
-
-;; Transform
-;;
-;;	mov	dst,reg
-;;	op	reg
-;;	mov	reg,dst
-;;
-;; into
-;;
-;;	op	dst
-;;
-;; if "reg" dies at the end of the sequence.
-
-(define_peephole2
-  [(set (match_operand 0 "register_operand" "")
-	(match_operand 1 "memory_operand" ""))
-   (set (match_dup 0)
-	(match_operator 2 "h8sx_unary_memory_operator"
-	 [(match_dup 0)]))
-   (set (match_operand 3 "memory_operand" "")
-	(match_dup 0))]
-  "TARGET_H8300SX
-   && peep2_reg_dead_p (3, operands[0])
-   && !reg_overlap_mentioned_p (operands[0], operands[3])
-   && h8sx_mergeable_memrefs_p (operands[3], operands[1])"
-  [(set (match_dup 3)
-	(match_dup 4))]
-  {
-    operands[4] = shallow_copy_rtx (operands[2]);
-    XEXP (operands[4], 0) = operands[1];
-  })
-
-;; Transform
-;;
-;;	mov	src1,reg
-;;	cmp	reg,src2
-;;
-;; into
-;;
-;;	cmp	src1,src2
-;;
-;; if "reg" dies in the comparison.
-
-(define_peephole2
-  [(set (match_operand 0 "register_operand" "")
-	(match_operand 1 "h8300_dst_operand" ""))
-   (set (cc0)
-	(compare (match_dup 0)
-		 (match_operand 2 "h8300_src_operand" "")))]
-  "TARGET_H8300SX
-   && peep2_reg_dead_p (2, operands[0])
-   && !reg_overlap_mentioned_p (operands[0], operands[2])
-   && operands[2] != const0_rtx"
-  [(set (cc0)
-	(compare (match_dup 1)
-		 (match_dup 2)))])
-
-;; Likewise for the second operand.
-
-(define_peephole2
-  [(set (match_operand 0 "register_operand" "")
-	(match_operand 1 "h8300_src_operand" ""))
-   (set (cc0)
-	(compare (match_operand 2 "h8300_dst_operand" "")
-		 (match_dup 0)))]
-  "TARGET_H8300SX
-   && peep2_reg_dead_p (2, operands[0])
-   && !reg_overlap_mentioned_p (operands[0], operands[2])"
-  [(set (cc0)
-	(compare (match_dup 2)
-		 (match_dup 1)))])
-
-;; Combine two moves.
-
-(define_peephole2
-  [(set (match_operand 0 "register_operand" "")
-	(match_operand 1 "h8300_src_operand" ""))
-   (set (match_operand 2 "h8300_dst_operand" "")
-	(match_dup 0))]
-  "TARGET_H8300SX
-   && peep2_reg_dead_p (2, operands[0])
-   && !reg_overlap_mentioned_p (operands[0], operands[2])"
-  [(set (match_dup 2)
-	(match_dup 1))])
-
-
+(include "testcompare.md")
+(include "addsub.md")
+(include "multiply.md")
+(include "divmod.md")
+(include "logical.md")
+(include "other.md")
+(include "jumpcall.md")
+(include "proepi.md")
+(include "extensions.md")
+(include "shiftrotate.md")
+(include "bitfield.md")
+(include "combiner.md")
+;;(include "peepholes.md")
diff --git a/gcc/config/h8300/jumpcall.md b/gcc/config/h8300/jumpcall.md
new file mode 100644
index 00000000000..5e206d30118
--- /dev/null
+++ b/gcc/config/h8300/jumpcall.md
@@ -0,0 +1,298 @@
+;; ----------------------------------------------------------------------
+;; JUMP INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+;; Conditional jump instructions
+
+(define_expand "cbranch<mode>4"
+  [(set (pc)
+	(if_then_else (match_operator 0 "ordered_comparison_operator"
+		        [(match_operand:QHSI 1 "h8300_dst_operand")
+			 (match_operand:QHSI 2 "h8300_src_operand")])
+		      (label_ref (match_operand 3 ""))
+		      (pc)))]
+  "")
+
+(define_insn_and_split "*branch_true"
+  [(set (pc)
+	(if_then_else (match_operator 0 "comparison_operator"
+		       [(match_operand:QHSI 1 "h8300_dst_operand" "rQ")
+			(match_operand:QHSI 2 "h8300_src_operand" "rQi")])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))]
+  ""
+  "#"
+  "reload_completed"
+  [(set (reg:CC CC_REG)
+	(compare:CC (match_dup 1) (match_dup 2)))
+   (set (pc)
+	(if_then_else (match_op_dup 0
+		       [(reg:CC CC_REG) (const_int 0)])
+		      (label_ref (match_dup 3))
+		      (pc)))]
+  "")
+
+(define_insn "*branch_true_1"
+  [(set (pc)
+	(if_then_else (match_operator 1 "comparison_operator"
+		       [(reg CC_REG) (const_int 0)])
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  "reload_completed"
+  {
+  if (get_attr_length (insn) == 2)
+    return "b%j1	%l0";
+  else if (get_attr_length (insn) == 4)
+    return "b%j1	%l0:16";
+  else
+    return "b%k1	.Lh8BR%=\;jmp	@%l0\\n.Lh8BR%=:";
+}
+ [(set_attr "type" "branch")
+   (set_attr "cc" "none")])
+
+(define_insn_and_split "*branch_false"
+  [(set (pc)
+	(if_then_else (match_operator 0 "comparison_operator"
+		       [(match_operand:QHSI 1 "h8300_dst_operand" "rQ")
+			(match_operand:QHSI 2 "h8300_src_operand" "rQi")])
+		      (pc)
+		      (label_ref (match_operand 3 "" ""))))]
+  ""
+  "#"
+  "reload_completed"
+  [(set (reg:CC CC_REG)
+	(compare:CC (match_dup 1) (match_dup 2)))
+   (set (pc)
+	(if_then_else (match_op_dup 0
+		       [(reg:CC CC_REG) (const_int 0)])
+		      (pc)
+		      (label_ref (match_dup 3))))]
+  "")
+
+(define_insn "branch_false_1"
+  [(set (pc)
+	(if_then_else (match_operator 1 "comparison_operator"
+		       [(reg CC_REG) (const_int 0)])
+		      (pc)
+		      (label_ref (match_operand 0 "" ""))))]
+  ""
+{
+  if (get_attr_length (insn) == 2)
+    return "b%k1	%l0";
+  else if (get_attr_length (insn) == 4)
+    return "b%k1	%l0:16";
+  else
+    return "b%j1	.Lh8BR%=\;jmp	@%l0\\n.Lh8BR%=:";
+}
+  [(set_attr "type" "branch")
+   (set_attr "cc" "none")])
+
+(define_insn "*brabc"
+  [(set (pc)
+	(if_then_else (eq (zero_extract (match_operand:QI 1 "bit_memory_operand" "WU")
+					(const_int 1)
+					(match_operand:QI 2 "immediate_operand" "n"))
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  "TARGET_H8300SX"
+{
+  switch (get_attr_length (insn)
+	  - h8300_insn_length_from_table (insn, operands))
+    {
+    case 2:
+      return "bra/bc	%2,%R1,%l0";
+    case 4:
+      return "bra/bc	%2,%R1,%l0:16";
+    default:
+      return "bra/bs	%2,%R1,.Lh8BR%=\;jmp	@%l0\\n.Lh8BR%=:";
+    }
+}
+  [(set_attr "type" "bitbranch")
+   (set_attr "length_table" "bitbranch")])
+
+(define_insn "*brabs"
+  [(set (pc)
+	(if_then_else (ne (zero_extract (match_operand:QI 1 "bit_memory_operand" "WU")
+					(const_int 1)
+					(match_operand:QI 2 "immediate_operand" "n"))
+			  (const_int 0))
+		      (label_ref (match_operand 0 "" ""))
+		      (pc)))]
+  "TARGET_H8300SX"
+{
+  switch (get_attr_length (insn)
+	  - h8300_insn_length_from_table (insn, operands))
+    {
+    case 2:
+      return "bra/bs	%2,%R1,%l0";
+    case 4:
+      return "bra/bs	%2,%R1,%l0:16";
+    default:
+      return "bra/bc	%2,%R1,.Lh8BR%=\;jmp	@%l0\\n.Lh8BR%=:";
+    }
+}
+  [(set_attr "type" "bitbranch")
+   (set_attr "length_table" "bitbranch")])
+
+;; Unconditional and other jump instructions.
+
+(define_insn "jump"
+  [(set (pc)
+	(label_ref (match_operand 0 "" "")))]
+  ""
+{
+  if (final_sequence != 0)
+    {
+      if (get_attr_length (insn) == 2)
+	return "bra/s	%l0";
+      else
+	{
+	  /* The branch isn't short enough to use bra/s.  Output the
+	     branch and delay slot in their normal order.
+
+	     If this is a backward branch, it will now be branching two
+	     bytes further than previously thought.  The length-based
+	     test for bra vs. jump is very conservative though, so the
+	     branch will still be within range.  */
+	  rtx_sequence *seq;
+	  int seen;
+
+	  seq = final_sequence;
+	  final_sequence = 0;
+	  final_scan_insn (seq->insn (1), asm_out_file, optimize, 1, & seen);
+	  final_scan_insn (seq->insn (0), asm_out_file, optimize, 1, & seen);
+	  seq->insn (1)->set_deleted ();
+	  return "";
+	}
+    }
+  else if (get_attr_length (insn) == 2)
+    return "bra	%l0";
+  else if (get_attr_length (insn) == 4)
+    return "bra	%l0:16";
+  else
+    return "jmp	@%l0";
+}
+  [(set_attr "type" "branch")
+   (set (attr "delay_slot")
+	(if_then_else (match_test "TARGET_H8300SX")
+		      (const_string "jump")
+		      (const_string "none")))
+   (set_attr "cc" "none")])
+
+;; This is a define expand, because pointers may be either 16 or 32 bits.
+
+(define_expand "tablejump"
+  [(parallel [(set (pc) (match_operand 0 "register_operand" ""))
+	      (use (label_ref (match_operand 1 "" "")))])]
+  ""
+  "")
+
+(define_insn "tablejump<mode>"
+  [(set (pc) (match_operand:P 0 "register_operand" "r"))
+   (use (label_ref (match_operand 1 "" "")))]
+  ""
+  {
+    if (<MODE>mode == E_HImode)
+      return "jmp	@%0";
+    if (<MODE>mode == E_SImode)
+      return "jmp	@%S0";
+    abort ();
+  }
+  [(set_attr "cc" "none")
+   (set_attr "length" "2")])
+
+;; This is a define expand, because pointers may be either 16 or 32 bits.
+
+(define_expand "indirect_jump"
+  [(set (pc) (match_operand 0 "jump_address_operand" ""))]
+  ""
+  "")
+
+(define_insn "*indirect_jump_<mode>"
+  [(set (pc) (match_operand:P 0 "jump_address_operand" "Vr"))]
+  ""
+  {
+    if (<MODE>mode == E_HImode)
+      return "jmp	@%0";
+    if (<MODE>mode == E_SImode)
+      return "jmp	@%S0";
+    abort ();
+  }
+  [(set_attr "cc" "none")
+   (set_attr "length" "2")])
+
+;; Call subroutine with no return value.
+
+;; ??? Even though we use HImode here, this works on the H8/300H and H8S.
+
+(define_expand "call"
+  [(call (match_operand:QI 0 "call_expander_operand" "")
+	 (match_operand 1 "general_operand" ""))]
+  ""
+  {
+    if (!register_operand (XEXP (operands[0], 0), Pmode)
+	&& GET_CODE (XEXP (operands[0], 0)) != SYMBOL_REF)
+      XEXP (operands[0], 0) = force_reg (Pmode, XEXP (operands[0], 0));
+  })
+
+(define_insn "call_insn_<mode>"
+  [(call (mem:QI (match_operand 0 "call_insn_operand" "Cr"))
+	         (match_operand:P 1 "general_operand" "g"))]
+  ""
+{
+  rtx xoperands[1];
+  xoperands[0] = gen_rtx_MEM (QImode, operands[0]);
+  gcc_assert (GET_MODE (operands[0]) == Pmode);
+  if (GET_CODE (XEXP (xoperands[0], 0)) == SYMBOL_REF
+      && (SYMBOL_REF_FLAGS (XEXP (xoperands[0], 0)) & SYMBOL_FLAG_FUNCVEC_FUNCTION))
+    output_asm_insn ("jsr\\t@%0:8", xoperands);
+  else
+    output_asm_insn ("jsr\\t%0", xoperands);
+  return "";
+}
+  [(set_attr "type" "call")
+   (set (attr "length")
+	(if_then_else (match_operand:QI 0 "small_call_insn_operand" "")
+		      (const_int 2)
+		      (const_int 4)))])
+
+;; Call subroutine, returning value in operand 0
+;; (which must be a hard register).
+
+;; ??? Even though we use HImode here, this works on the H8/300H and H8S.
+
+(define_expand "call_value"
+  [(set (match_operand 0 "" "")
+	(call (match_operand:QI 1 "call_expander_operand" "")
+	      (match_operand 2 "general_operand" "")))]
+  ""
+  {
+    if (!register_operand (XEXP (operands[1], 0), Pmode)
+	&& GET_CODE (XEXP (operands[1], 0)) != SYMBOL_REF)
+      XEXP (operands[1], 0) = force_reg (Pmode, XEXP (operands[1], 0));
+  })
+
+(define_insn "call_value_insn_<mode>"
+  [(set (match_operand 0 "" "=r")
+	(call (mem:QI (match_operand 1 "call_insn_operand" "Cr"))
+		      (match_operand:P 2 "general_operand" "g")))]
+  ""
+{
+  rtx xoperands[2];
+  gcc_assert (GET_MODE (operands[1]) == Pmode);
+  xoperands[0] = operands[0];
+  xoperands[1] = gen_rtx_MEM (QImode, operands[1]);
+  if (GET_CODE (XEXP (xoperands[1], 0)) == SYMBOL_REF
+      && (SYMBOL_REF_FLAGS (XEXP (xoperands[1], 0)) & SYMBOL_FLAG_FUNCVEC_FUNCTION))
+    output_asm_insn ("jsr\\t@%1:8", xoperands);
+  else
+    output_asm_insn ("jsr\\t%1", xoperands);
+  return "";
+}
+  [(set_attr "type" "call")
+   (set (attr "length")
+	(if_then_else (match_operand:QI 0 "small_call_insn_operand" "")
+		      (const_int 2)
+		      (const_int 4)))])
+
diff --git a/gcc/config/h8300/logical.md b/gcc/config/h8300/logical.md
new file mode 100644
index 00000000000..ab06ae6d921
--- /dev/null
+++ b/gcc/config/h8300/logical.md
@@ -0,0 +1,363 @@
+;; ----------------------------------------------------------------------
+;; AND INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "bclrqi_msx"
+  [(set (match_operand:QI 0 "bit_register_indirect_operand" "=WU")
+	(and:QI (match_operand:QI 1 "bit_register_indirect_operand" "%0")
+		(match_operand:QI 2 "single_zero_operand" "Y0")))]
+  "TARGET_H8300SX && rtx_equal_p (operands[0], operands[1])"
+  "bclr\\t%W2,%0"
+  [(set_attr "length" "8")])
+
+(define_split
+  [(set (match_operand:HI 0 "bit_register_indirect_operand")
+	(and:HI (match_operand:HI 1 "bit_register_indirect_operand")
+		(match_operand:HI 2 "single_zero_operand")))]
+  "TARGET_H8300SX"
+  [(set (match_dup 0)
+	(and:QI (match_dup 1)
+		(match_dup 2)))]
+  {
+    if (abs (INTVAL (operands[2])) > 0xFF)
+      {
+	operands[0] = adjust_address (operands[0], QImode, 0);
+	operands[1] = adjust_address (operands[1], QImode, 0);
+	operands[2] = GEN_INT ((INTVAL (operands[2])) >> 8);
+      }
+    else
+      {
+	operands[0] = adjust_address (operands[0], QImode, 1);
+	operands[1] = adjust_address (operands[1], QImode, 1);
+      }
+  })
+
+(define_insn "bclrhi_msx"
+  [(set (match_operand:HI 0 "bit_register_indirect_operand" "=m")
+	(and:HI (match_operand:HI 1 "bit_register_indirect_operand" "%0")
+		(match_operand:HI 2 "single_zero_operand" "Y0")))]
+  "TARGET_H8300SX"
+  "bclr\\t%W2,%0"
+  [(set_attr "length" "8")])
+
+(define_insn_and_split "*andqi3_2"
+  [(set (match_operand:QI 0 "bit_operand" "=U,rQ,r")
+	(and:QI (match_operand:QI 1 "bit_operand" "%0,0,WU")
+		(match_operand:QI 2 "h8300_src_operand" "Y0,rQi,IP1>X")))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (and:QI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*andqi3_2_clobber_flags"
+  [(set (match_operand:QI 0 "bit_operand" "=U,rQ,r")
+	(and:QI (match_operand:QI 1 "bit_operand" "%0,0,WU")
+		(match_operand:QI 2 "h8300_src_operand" "Y0,rQi,IP1>X")))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  "@
+   bclr\\t %W2,%R0
+   and  %X2,%X0
+   bfld %2,%1,%R0"
+  [(set_attr "length" "8,*,8")
+   (set_attr "length_table" "*,logicb,*")])
+
+(define_insn "*andqi3_2_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (and:QI (match_operand:QI 1 "bit_operand" "%0")
+		  (match_operand:QI 2 "h8300_src_operand" "rQ"))
+	  (const_int 0)))
+   (set (match_operand:QI 0 "bit_operand" "=rQ")
+	(and:QI (match_dup 1) (match_dup 2)))]
+  "TARGET_H8300SX && !CONSTANT_P (operands[2])"
+  "and  %X2,%X0"
+  [(set_attr "length" "*")
+   (set_attr "length_table" "logicb")])
+
+(define_insn_and_split "andqi3_1"
+  [(set (match_operand:QI 0 "bit_operand" "=U,r")
+	(and:QI (match_operand:QI 1 "bit_operand" "%0,0")
+		(match_operand:QI 2 "h8300_src_operand" "Y0,rn")))]
+  "register_operand (operands[0], QImode)
+   || single_zero_operand (operands[2], QImode)"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (and:QI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "andqi3_1_clobber_flags"
+  [(set (match_operand:QI 0 "bit_operand" "=U,r")
+	(and:QI (match_operand:QI 1 "bit_operand" "%0,0")
+		(match_operand:QI 2 "h8300_src_operand" "Y0,rn")))
+   (clobber (reg:CC CC_REG))]
+  "register_operand (operands[0], QImode)
+   || single_zero_operand (operands[2], QImode)"
+  "@
+   bclr %W2,%R0
+   and  %X2,%X0"
+  [(set_attr "length" "2,8")])
+
+(define_insn "andqi3_1_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN (and:QI (match_operand:QI 1 "bit_operand" "%0")
+			      (match_operand:QI 2 "h8300_src_operand" "rn"))
+		      (const_int 0)))
+   (set (match_operand:QI 0 "bit_operand" "=r")
+	(and:QI (match_dup 1) (match_dup 2)))]
+  "(register_operand (operands[0], QImode)
+    && !single_zero_operand (operands[2], QImode))"
+  "and  %X2,%X0"
+  [(set_attr "length" "8")])
+
+(define_expand "and<mode>3"
+  [(set (match_operand:QHSI 0 "register_operand" "")
+	(and:QHSI (match_operand:QHSI 1 "register_operand" "")
+		  (match_operand:QHSI 2 "h8300_src_operand" "")))]
+  ""
+  "")
+
+(define_insn_and_split "*andor<mode>3"
+  [(set (match_operand:QHSI 0 "register_operand" "=r")
+	(ior:QHSI (and:QHSI (match_operand:QHSI 2 "register_operand" "r")
+			    (match_operand:QHSI 3 "single_one_operand" "n"))
+		  (match_operand:QHSI 1 "register_operand" "0")))]
+  "(<MODE>mode == QImode
+    || <MODE>mode == HImode
+    || (<MODE>mode == SImode
+	&& (INTVAL (operands[3]) & 0xffff) != 0))"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (ior:QHSI (and:QHSI (match_dup 2)
+						     (match_dup 3))
+					   (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*andor<mode>3_clobber_flags"
+  [(set (match_operand:QHSI 0 "register_operand" "=r")
+	(ior:QHSI (and:QHSI (match_operand:QHSI 2 "register_operand" "r")
+			    (match_operand:QHSI 3 "single_one_operand" "n"))
+		  (match_operand:QHSI 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  "(<MODE>mode == QImode
+    || <MODE>mode == HImode
+    || (<MODE>mode == SImode
+	&& (INTVAL (operands[3]) & 0xffff) != 0))"
+  {
+    if (<MODE>mode == QImode)
+      return "bld\\t%V3,%X2\;bor\\t%V3,%X0\;bst\\t%V3,%X0";
+
+    if (<MODE>mode == HImode)
+      {
+	operands[3] = GEN_INT (INTVAL (operands[3]) & 0xffff);
+	if (INTVAL (operands[3]) > 128)
+	  {
+	    operands[3] = GEN_INT (INTVAL (operands[3]) >> 8);
+	    return "bld\\t%V3,%t2\;bor\\t%V3,%t0\;bst\\t%V3,%t0";
+	  }
+	return "bld\\t%V3,%s2\;bor\\t%V3,%s0\;bst\\t%V3,%s0";
+      }
+
+    if (<MODE>mode == SImode)
+      {
+	operands[3] = GEN_INT (INTVAL (operands[3]) & 0xffff);
+	if (INTVAL (operands[3]) > 128)
+	  {
+	    operands[3] = GEN_INT (INTVAL (operands[3]) >> 8);
+	    return "bld\\t%V3,%x2\;bor\\t%V3,%x0\;bst\\t%V3,%x0";
+	  }
+	return "bld\\t%V3,%w2\;bor\\t%V3,%w0\;bst\\t%V3,%w0";
+      }
+
+    gcc_unreachable ();
+	
+  }
+  [(set_attr "length" "6")])
+
+(define_insn_and_split "*andorsi3_shift_8"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (ashift:SI (match_operand:SI 2 "register_operand" "r")
+				   (const_int 8))
+			(const_int 65280))
+		(match_operand:SI 1 "register_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (ior:SI (and:SI (ashift:SI (match_dup 2)
+							    (const_int 8))
+						 (const_int 65280))
+					 (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*andorsi3_shift_8_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(ior:SI (and:SI (ashift:SI (match_operand:SI 2 "register_operand" "r")
+				   (const_int 8))
+			(const_int 65280))
+		(match_operand:SI 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "or.b\\t%w2,%x0"
+  [(set_attr "length" "2")])
+
+;; ----------------------------------------------------------------------
+;; OR/XOR INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn "b<code>qi_msx"
+  [(set (match_operand:QI 0 "bit_register_indirect_operand" "=WU")
+	(ors:QI (match_operand:QI 1 "bit_register_indirect_operand" "%0")
+		(match_operand:QI 2 "single_one_operand" "Y2")))]
+  "TARGET_H8300SX && rtx_equal_p (operands[0], operands[1])"
+  { return <CODE> == IOR ? "bset\\t%V2,%0" : "bnot\\t%V2,%0"; }
+  [(set_attr "length" "8")])
+
+(define_insn "b<code>hi_msx"
+  [(set (match_operand:HI 0 "bit_register_indirect_operand" "=m")
+	(ors:HI (match_operand:HI 1 "bit_register_indirect_operand" "%0")
+		(match_operand:HI 2 "single_one_operand" "Y2")))]
+  "TARGET_H8300SX"
+  { return <CODE> == IOR ? "bset\\t%V2,%0" : "bnot\\t%V2,%0"; }
+  [(set_attr "length" "8")])
+
+(define_insn_and_split "<code>qi3_1"
+  [(set (match_operand:QI 0 "bit_operand" "=U,rQ")
+	(ors:QI (match_operand:QI 1 "bit_operand" "%0,0")
+		(match_operand:QI 2 "h8300_src_operand" "Y2,rQi")))]
+  "TARGET_H8300SX || register_operand (operands[0], QImode)
+   || single_one_operand (operands[2], QImode)"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (ors:QI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "<code>qi3_1_clobber_flags"
+  [(set (match_operand:QI 0 "bit_operand" "=U,rQ")
+	(ors:QI (match_operand:QI 1 "bit_operand" "%0,0")
+		(match_operand:QI 2 "h8300_src_operand" "Y2,rQi")))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX || register_operand (operands[0], QImode)
+   || single_one_operand (operands[2], QImode)"
+  {
+    if (which_alternative == 0)
+      return <CODE> == IOR ? "bset\\t%V2,%R0" : "bnot\\t%V2,%R0";
+    else if (which_alternative == 1)
+      return <CODE> == IOR ? "or\\t%X2,%X0" : "xor\\t%X2,%X0";
+    gcc_unreachable ();
+  }
+  [(set_attr "length" "8,*")
+   (set_attr "length_table" "*,logicb")])
+
+(define_insn "<code>qi3_1_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (ors:QI (match_operand:QI 1 "bit_operand" "%0")
+		  (match_operand:QI 2 "h8300_src_operand" "rQi"))
+	  (const_int 0)))
+   (set (match_operand:QI 0 "bit_operand" "=rQ")
+	(ors:QI (match_dup 1) (match_dup 2)))]
+  "((TARGET_H8300SX || register_operand (operands[0], QImode))
+    && ! single_one_operand (operands[2], QImode))"
+  {
+    return <CODE> == IOR ? "or\\t%X2,%X0" : "xor\\t%X2,%X0";
+  }
+  [(set_attr "length" "*")
+   (set_attr "length_table" "logicb")])
+
+(define_expand "<code><mode>3"
+  [(set (match_operand:QHSI 0 "register_operand" "")
+	(ors:QHSI (match_operand:QHSI 1 "register_operand" "")
+		  (match_operand:QHSI 2 "h8300_src_operand" "")))]
+  ""
+  "")
+
+;; ----------------------------------------------------------------------
+;; {AND,IOR,XOR}{HI3,SI3} PATTERNS
+;; ----------------------------------------------------------------------
+
+(define_insn_and_split "*logical<mode>3"
+  [(set (match_operand:HSI 0 "h8300_dst_operand" "=rQ")
+	(match_operator:HSI 3 "bit_operator"
+	  [(match_operand:HSI 1 "h8300_dst_operand" "%0")
+	   (match_operand:HSI 2 "h8300_src_operand" "rQi")]))]
+  "h8300_operands_match_p (operands)"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (match_op_dup 3 [(match_dup 1) (match_dup 2)]))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*logical<mode>3_clobber_flags"
+  [(set (match_operand:HSI 0 "h8300_dst_operand" "=rQ")
+	(match_operator:HSI 3 "bit_operator"
+	  [(match_operand:HSI 1 "h8300_dst_operand" "%0")
+	   (match_operand:HSI 2 "h8300_src_operand" "rQi")]))
+   (clobber (reg:CC CC_REG))]
+  "h8300_operands_match_p (operands)"
+  { return output_logical_op (<MODE>mode, operands); }
+  [(set (attr "length")
+	(symbol_ref "compute_logical_op_length (<MODE>mode, operands)"))])
+
+(define_insn "*logical<mode>3_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operator:HSI 3 "bit_operator"
+	    [(match_operand:HSI 1 "h8300_dst_operand" "%0")
+	     (match_operand:HSI 2 "h8300_src_operand" "rQi")])
+	  (const_int 0)))
+   (set (match_operand:HSI 0 "h8300_dst_operand" "=rQ")
+	(match_op_dup 3 [(match_dup 1) (match_dup 2)]))]
+  "compute_logical_op_cc (<MODE>mode, operands) == 2"
+  { return output_logical_op (<MODE>mode, operands); }
+  [(set (attr "length")
+	(symbol_ref "compute_logical_op_length (<MODE>mode, operands)"))])
+
+
+;; ----------------------------------------------------------------------
+;; NOT INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn_and_split "one_cmpl<mode>2"
+  [(set (match_operand:QHSI 0 "h8300_dst_operand" "=rQ")
+	(not:QHSI (match_operand:QHSI 1 "h8300_dst_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (not:QHSI (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "one_cmpl<mode>2_clobber_flags"
+  [(set (match_operand:QHSI 0 "h8300_dst_operand" "=rQ")
+	(not:QHSI (match_operand:QHSI 1 "h8300_dst_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  {
+    if (<MODE>mode == E_QImode)
+      return "not	%X0";
+    if (<MODE>mode == E_HImode)
+      return "not.w	%T0";
+    if (<MODE>mode == E_SImode)
+      return "not.l	%S0";
+    gcc_unreachable ();
+  }
+  [(set_attr "length_table" "unary")
+   (set_attr "cc" "set_znv")])
+
+(define_insn "one_cmpl<mode>2_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN (not:QHSI (match_operand:QHSI 1 "h8300_dst_operand" "0"))
+		      (const_int 0)))
+   (set (match_operand:QHSI 0 "h8300_dst_operand" "=rQ")
+	(not:QHSI (match_dup 1)))]
+  ""
+  {
+    if (<MODE>mode == E_QImode)
+      return "not	%X0";
+    if (<MODE>mode == E_HImode)
+      return "not.w	%T0";
+    if (<MODE>mode == E_SImode)
+      return "not.l	%S0";
+    gcc_unreachable ();
+  }
+  [(set_attr "length_table" "unary")])
diff --git a/gcc/config/h8300/mova.md b/gcc/config/h8300/mova.md
index 926edbb2c3c..cdcd4b8f6a4 100644
--- a/gcc/config/h8300/mova.md
+++ b/gcc/config/h8300/mova.md
@@ -24,8 +24,7 @@
 		 (match_operand:QI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:QI 0 "register_operand" "=r,r")
@@ -34,8 +33,7 @@
 		 (match_operand:QI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:QI 0 "register_operand" "=r,r")
@@ -44,8 +42,7 @@
 		 (match_operand:QI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:QI 0 "register_operand" "=r,r")
@@ -54,8 +51,7 @@
 		 (match_operand:QI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -63,8 +59,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/b.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -72,8 +67,7 @@
 		  (const_int 2)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -82,8 +76,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -92,8 +85,7 @@
 		(const_int 510)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -103,8 +95,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -113,8 +104,7 @@
 		(const_int 510)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -124,8 +114,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -133,8 +122,7 @@
 		  (const_int 1)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -143,8 +131,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -153,8 +140,7 @@
 		(const_int 510)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -164,8 +150,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -174,8 +159,7 @@
 		(const_int 510)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -185,8 +169,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -194,8 +177,7 @@
 		  (const_int 4)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -204,8 +186,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -214,8 +195,7 @@
 		(const_int 1020)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -225,8 +205,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -235,8 +214,7 @@
 		(const_int 1020)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -246,8 +224,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -255,8 +232,7 @@
 		  (const_int 2)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -265,8 +241,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -275,8 +250,7 @@
 		(const_int 1020)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -286,8 +260,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -296,8 +269,7 @@
 		(const_int 1020)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r")
@@ -307,8 +279,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -316,8 +287,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/b.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -325,8 +295,7 @@
 		  (const_int 2)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -335,8 +304,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -345,8 +313,7 @@
 		(const_int 510)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -356,8 +323,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -366,8 +332,7 @@
 		(const_int 510)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -377,8 +342,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -386,8 +350,7 @@
 		  (const_int 1)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -396,8 +359,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -406,8 +368,7 @@
 		(const_int 510)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -417,8 +378,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -427,8 +387,7 @@
 		(const_int 510)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -438,8 +397,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -447,8 +405,7 @@
 		  (const_int 4)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -457,8 +414,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -467,8 +423,7 @@
 		(const_int 1020)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -478,8 +433,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -488,8 +442,7 @@
 		(const_int 1020)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -499,8 +452,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -508,8 +460,7 @@
 		  (const_int 2)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -518,8 +469,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -528,8 +478,7 @@
 		(const_int 1020)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -539,8 +488,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -549,8 +497,7 @@
 		(const_int 1020)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%X1.b),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -560,8 +507,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%X1.b),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -570,8 +516,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -580,8 +525,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -590,8 +534,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:HI 0 "register_operand" "=r,r")
@@ -600,8 +543,7 @@
 		 (match_operand:HI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -609,8 +551,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/b.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -618,8 +559,7 @@
 		  (const_int 2)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -628,8 +568,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -638,8 +577,7 @@
 		(const_int 131070)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -649,8 +587,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -659,8 +596,7 @@
 		(const_int 131070)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -670,8 +606,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -679,8 +614,7 @@
 		  (const_int 1)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -689,8 +623,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -699,8 +632,7 @@
 		(const_int 131070)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -710,8 +642,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -720,8 +651,7 @@
 		(const_int 131070)))]
   "TARGET_H8300SX"
   "mova/w.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -731,8 +661,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/w.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -740,8 +669,7 @@
 		  (const_int 4)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -750,8 +678,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -760,8 +687,7 @@
 		(const_int 262140)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -771,8 +697,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -781,8 +706,7 @@
 		(const_int 262140)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -792,8 +716,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -801,8 +724,7 @@
 		  (const_int 2)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r,r")
@@ -811,8 +733,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i,i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -821,8 +742,7 @@
 		(const_int 262140)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -832,8 +752,7 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -842,8 +761,7 @@
 		(const_int 262140)))]
   "TARGET_H8300SX"
   "mova/l.l @(0,%T1.w),%S0"
-  [(set_attr "length_table" "mova_zero")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova_zero")])
 
 (define_insn ""
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -853,6 +771,5 @@
 		 (match_operand:SI 2 "immediate_operand" "i")))]
   "TARGET_H8300SX"
   "mova/l.l @(%o2%C2,%T1.w),%S0"
-  [(set_attr "length_table" "mova")
-   (set_attr "cc" "none")])
+  [(set_attr "length_table" "mova")])
 
diff --git a/gcc/config/h8300/movepush.md b/gcc/config/h8300/movepush.md
new file mode 100644
index 00000000000..90a38ce5991
--- /dev/null
+++ b/gcc/config/h8300/movepush.md
@@ -0,0 +1,430 @@
+;; ----------------------------------------------------------------------
+;; MOVE INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+;; movqi
+
+(define_insn_and_split "*movqi"
+  [(set (match_operand:QI 0 "general_operand_dst" "=r,r ,<,r,r,m")
+	(match_operand:QI 1 "general_operand_src" " I,r>,r,n,m,r"))]
+  "!TARGET_H8300SX && h8300_move_ok (operands[0], operands[1])"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*movqi_clobber_flags"
+  [(set (match_operand:QI 0 "general_operand_dst" "=r,r ,<,r,r,m")
+	(match_operand:QI 1 "general_operand_src" " I,r>,r,n,m,r"))
+   (clobber (reg:CC CC_REG))]
+  "!TARGET_H8300SX && h8300_move_ok (operands[0], operands[1])"
+  "@
+   sub.b	%X0,%X0
+   mov.b	%R1,%X0
+   mov.b	%X1,%R0
+   mov.b	%R1,%X0
+   mov.b	%R1,%X0
+   mov.b	%X1,%R0"
+  [(set (attr "length") (symbol_ref "compute_mov_length (operands)"))])
+
+(define_insn "*movqi_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operand:QI 1 "general_operand_src" "r>,r,m,r")
+	  (const_int 0)))
+   (set (match_operand:QI 0 "general_operand_dst" "=r ,<,r,m")
+	(match_dup 1))]
+  "(!TARGET_H8300SX
+    && h8300_move_ok (operands[0], operands[1])
+    && !CONSTANT_P (operands[1]))"
+  "@
+   mov.b	%R1,%X0
+   mov.b	%X1,%R0
+   mov.b	%R1,%X0
+   mov.b	%X1,%R0"
+  [(set (attr "length") (symbol_ref "compute_mov_length (operands)"))])
+
+(define_insn_and_split "*movqi_h8sx"
+  [(set (match_operand:QI 0 "general_operand_dst" "=Z,rQ")
+	(match_operand:QI 1 "general_operand_src" "P4>X,rQi"))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*movqi_h8sx_clobber_flags"
+  [(set (match_operand:QI 0 "general_operand_dst" "=Z,rQ")
+	(match_operand:QI 1 "general_operand_src" "P4>X,rQi"))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  "@
+    mov.b	%X1:4,%X0
+    mov.b	%X1,%X0"
+  [(set_attr "length_table" "mov_imm4,movb")])
+
+(define_insn "*movqi_h8sx_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operand:QI 1 "general_operand_src" ">X,rQ")
+	  (const_int 0)))
+   (set (match_operand:QI 0 "general_operand_dst" "=Z,rQ")
+	(match_dup 1))]
+  "TARGET_H8300SX && !CONSTANT_P (operands[1])"
+   "mov.b	%X1,%X0"
+  [(set_attr "length_table" "mov_imm4,movb")])
+
+(define_expand "mov<mode>"
+  [(set (match_operand:QHSIF 0 "general_operand_dst" "")
+	(match_operand:QHSIF 1 "general_operand_src" ""))]
+  ""
+  {
+    enum machine_mode mode = <MODE>mode;
+    if (!TARGET_H8300SX)
+      {
+	/* Other H8 chips, except the H8/SX family can only handle a
+	   single memory operand, which is checked by h8300_move_ok.
+
+	   We could perhaps have h8300_move_ok handle the H8/SX better
+	   and just remove the !TARGET_H8300SX conditional.  */
+	if (!h8300_move_ok (operands[0], operands[1]))
+	  operands[1] = copy_to_mode_reg (mode, operand1);
+      }
+  })
+
+(define_insn_and_split "movstrictqi"
+  [(set (strict_low_part (match_operand:QI 0 "general_operand_dst" "+r,r"))
+			 (match_operand:QI 1 "general_operand_src" "I,rmi>"))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (strict_low_part (match_dup 0)) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+
+
+(define_insn "movstrictqi_clobber_flags"
+  [(set (strict_low_part (match_operand:QI 0 "general_operand_dst" "+r,r"))
+			 (match_operand:QI 1 "general_operand_src" "I,rmi>"))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "@
+   sub.b	%X0,%X0
+   mov.b	%X1,%X0"
+  [(set_attr "length" "2,*")
+   (set_attr "length_table" "*,movb")])
+
+;; movhi
+
+(define_insn_and_split "*movhi"
+  [(set (match_operand:HI 0 "general_operand_dst" "=r,r,<,r,r,m")
+	(match_operand:HI 1 "general_operand_src" "I,r>,r,i,m,r"))]
+  "!TARGET_H8300SX
+    && h8300_move_ok (operands[0], operands[1])"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*movhi_clobber_flags"
+  [(set (match_operand:HI 0 "general_operand_dst" "=r,r,<,r,r,m")
+	(match_operand:HI 1 "general_operand_src" "I,r>,r,i,m,r"))
+   (clobber (reg:CC CC_REG))]
+  "!TARGET_H8300SX
+    && h8300_move_ok (operands[0], operands[1])"
+  "@
+   sub.w	%T0,%T0
+   mov.w	%T1,%T0
+   mov.w	%T1,%T0
+   mov.w	%T1,%T0
+   mov.w	%T1,%T0
+   mov.w	%T1,%T0"
+  [(set (attr "length") (symbol_ref "compute_mov_length (operands)"))])
+
+(define_insn "*movhi_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operand:HI 1 "general_operand_src" "r>,r,m,r")
+	  (const_int 0)))
+   (set (match_operand:HI 0 "general_operand_dst" "=r,<,r,m")
+	(match_dup 1))]
+  "(!TARGET_H8300SX
+    && h8300_move_ok (operands[0], operands[1])
+    && !CONSTANT_P (operands[1]))"
+  "@
+   mov.w	%T1,%T0
+   mov.w	%T1,%T0
+   mov.w	%T1,%T0
+   mov.w	%T1,%T0"
+  [(set (attr "length") (symbol_ref "compute_mov_length (operands)"))])
+
+(define_insn_and_split "*movhi_h8sx"
+  [(set (match_operand:HI 0 "general_operand_dst" "=r,r,Z,Q,rQ")
+	(match_operand:HI 1 "general_operand_src" "I,P3>X,P4>X,IP8>X,rQi"))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+  
+(define_insn "*movhi_h8sx_clobber_flags"
+  [(set (match_operand:HI 0 "general_operand_dst" "=r,r,Z,Q,rQ")
+	(match_operand:HI 1 "general_operand_src" "I,P3>X,P4>X,IP8>X,rQi"))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  "@
+   sub.w	%T0,%T0
+   mov.w	%T1:3,%T0
+   mov.w	%T1:4,%T0
+   mov.w	%T1,%T0
+   mov.w	%T1,%T0"
+  [(set_attr "length_table" "*,*,mov_imm4,short_immediate,movw")
+   (set_attr "length" "2,2,*,*,*")])
+
+(define_insn "*movhi_h8sx_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operand:HI 1 "general_operand_src" ">X,>X,>X,rQ")
+	  (const_int 0)))
+   (set (match_operand:HI 0 "general_operand_dst" "=r,Z,Q,rQ")
+	(match_dup 1))]
+  "TARGET_H8300SX && !CONSTANT_P (operands[1])"
+  "mov.w	%T1,%T0"
+  [(set_attr "length_table" "*,mov_imm4,short_immediate,movw")
+   (set_attr "length" "2,*,*,*")])
+
+(define_insn_and_split "movstricthi"
+  [(set (strict_low_part (match_operand:HI 0 "general_operand_dst" "+r,r,r"))
+			 (match_operand:HI 1 "general_operand_src" "I,P3>X,rmi"))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (strict_low_part (match_dup 0)) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "movstricthi_clobber_flags"
+  [(set (strict_low_part (match_operand:HI 0 "general_operand_dst" "+r,r,r"))
+			 (match_operand:HI 1 "general_operand_src" "I,P3>X,rmi"))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "@
+   sub.w	%T0,%T0
+   mov.w	%T1,%T0
+   mov.w	%T1,%T0"
+  [(set_attr "length" "2,2,*")
+   (set_attr "length_table" "*,*,movw")])
+
+;; movsi
+(define_insn_and_split "*movsi"
+  [(set (match_operand:SI 0 "general_operand_dst" "=r,r,r,<,r,r,m,*a,*a,r")
+	(match_operand:SI 1 "general_operand_src" "I,r,i,r,>,m,r,I,r,*a"))]
+  "(TARGET_H8300S || TARGET_H8300H) && !TARGET_H8300SX
+    && h8300_move_ok (operands[0], operands[1])"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*movsi_clobber_flags"
+  [(set (match_operand:SI 0 "general_operand_dst" "=r,r,r,<,r,r,m,*a,*a,r")
+	(match_operand:SI 1 "general_operand_src" "I,r,i,r,>,m,r,I,r,*a"))
+   (clobber (reg:CC CC_REG))]
+  "(TARGET_H8300S || TARGET_H8300H) && !TARGET_H8300SX
+    && h8300_move_ok (operands[0], operands[1])"
+{
+  switch (which_alternative)
+    {
+    case 0:
+      return "sub.l	%S0,%S0";
+    case 7:
+      return "clrmac";
+    case 8:
+      return "clrmac\;ldmac %1,macl";
+    case 9:
+      return "stmac	macl,%0";
+    default:
+      if (GET_CODE (operands[1]) == CONST_INT)
+	{
+	  int val = INTVAL (operands[1]);
+
+	  /* Look for constants which can be made by adding an 8-bit
+	     number to zero in one of the two low bytes.  */
+	  if (val == (val & 0xff))
+	    {
+	      operands[1] = GEN_INT ((char) val & 0xff);
+	      return "sub.l\\t%S0,%S0\;add.b\\t%1,%w0";
+	    }
+
+	  if (val == (val & 0xff00))
+	    {
+	      operands[1] = GEN_INT ((char) (val >> 8) & 0xff);
+	      return "sub.l\\t%S0,%S0\;add.b\\t%1,%x0";
+	    }
+
+	  /* Look for constants that can be obtained by subs, inc, and
+	     dec to 0.  */
+	  switch (val & 0xffffffff)
+	    {
+	    case 0xffffffff:
+	      return "sub.l\\t%S0,%S0\;subs\\t#1,%S0";
+	    case 0xfffffffe:
+	      return "sub.l\\t%S0,%S0\;subs\\t#2,%S0";
+	    case 0xfffffffc:
+	      return "sub.l\\t%S0,%S0\;subs\\t#4,%S0";
+
+	    case 0x0000ffff:
+	      return "sub.l\\t%S0,%S0\;dec.w\\t#1,%f0";
+	    case 0x0000fffe:
+	      return "sub.l\\t%S0,%S0\;dec.w\\t#2,%f0";
+
+	    case 0xffff0000:
+	      return "sub.l\\t%S0,%S0\;dec.w\\t#1,%e0";
+	    case 0xfffe0000:
+	      return "sub.l\\t%S0,%S0\;dec.w\\t#2,%e0";
+
+	    case 0x00010000:
+	      return "sub.l\\t%S0,%S0\;inc.w\\t#1,%e0";
+	    case 0x00020000:
+	      return "sub.l\\t%S0,%S0\;inc.w\\t#2,%e0";
+	    }
+	}
+    }
+   return "mov.l	%S1,%S0";
+}
+  [(set (attr "length") (symbol_ref "compute_mov_length (operands)"))])
+
+(define_insn "*movsi_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operand:SI 1 "general_operand_src" "r,r,>,m,r,r,*a")
+	  (const_int 0)))
+   (set (match_operand:SI 0 "general_operand_dst" "=r,<,r,r,m,*a,r")
+	(match_dup 1))]
+  "(!TARGET_H8300SX
+    && h8300_move_ok (operands[0], operands[1])
+    && !CONSTANT_P (operands[1])
+    && (GET_CODE (operands[0]) != REG
+	|| REGNO (operands[0]) != MAC_REG)
+    && (GET_CODE (operands[1]) != REG
+	|| REGNO (operands[1]) != MAC_REG))"
+  "mov.l	%S1,%S0"
+  [(set (attr "length") (symbol_ref "compute_mov_length (operands)"))])
+
+(define_insn_and_split "*movsi_h8sx"
+  [(set (match_operand:SI 0 "general_operand_dst" "=r,r,Q,rQ,*a,*a,r")
+	(match_operand:SI 1 "general_operand_src" "I,P3>X,IP8>X,rQi,I,r,*a"))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*movsi_h8sx_clobber_flags"
+  [(set (match_operand:SI 0 "general_operand_dst" "=r,r,Q,rQ,*a,*a,r")
+	(match_operand:SI 1 "general_operand_src" "I,P3>X,IP8>X,rQi,I,r,*a"))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  "@
+   sub.l	%S0,%S0
+   mov.l	%S1:3,%S0
+   mov.l	%S1,%S0
+   mov.l	%S1,%S0
+   clrmac
+   clrmac\;ldmac	%1,macl
+   stmac	macl,%0"
+  [(set_attr "length_table" "*,*,short_immediate,movl,*,*,*")
+   (set_attr "length" "2,2,*,*,2,6,4")])
+
+(define_insn "*movsi_h8sx_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operand:SI 1 "general_operand_src" ">X,>X,rQ")
+	  (const_int 0)))
+   (set (match_operand:SI 0 "general_operand_dst" "=r,Q,rQ")
+	(match_dup 1))]
+  "(TARGET_H8300SX
+    && !CONSTANT_P (operands[1])
+    && (GET_CODE (operands[0]) != REG
+	|| REGNO (operands[0]) != MAC_REG)
+    && (GET_CODE (operands[1]) != REG
+	|| REGNO (operands[1]) != MAC_REG))"
+  "mov.l	%S1,%S0"
+  [(set_attr "length_table" "*,short_immediate,movl")
+   (set_attr "length" "2,*,*")])
+
+(define_insn_and_split "*movsf_h8sx"
+  [(set (match_operand:SF 0 "general_operand_dst" "=r,rQ")
+	(match_operand:SF 1 "general_operand_src" "G,rQi"))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*movsf_h8sx_clobber_flags"
+  [(set (match_operand:SF 0 "general_operand_dst" "=r,rQ")
+	(match_operand:SF 1 "general_operand_src" "G,rQi"))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  "@
+    sub.l	%S0,%S0
+    mov.l	%S1,%S0"
+  [(set_attr "length" "2,*")
+   (set_attr "length_table" "*,movl")])
+
+(define_insn_and_split "*movsf"
+  [(set (match_operand:SF 0 "general_operand_dst" "=r,r,r,m,<,r")
+	(match_operand:SF 1 "general_operand_src" "G,r,im,r,r,>"))]
+  "!TARGET_H8300SX
+    && (register_operand (operands[0], SFmode)
+	|| register_operand (operands[1], SFmode))"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_dup 1))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*movsf_clobber_flags"
+  [(set (match_operand:SF 0 "general_operand_dst" "=r,r,r,m,<,r")
+	(match_operand:SF 1 "general_operand_src" "G,r,im,r,r,>"))
+   (clobber (reg:CC CC_REG))]
+  "!TARGET_H8300SX
+    && (register_operand (operands[0], SFmode)
+	|| register_operand (operands[1], SFmode))"
+  "@
+   sub.l	%S0,%S0
+   mov.l	%S1,%S0
+   mov.l	%S1,%S0
+   mov.l	%S1,%S0
+   mov.l	%S1,%S0
+   mov.l	%S1,%S0"
+  [(set (attr "length") (symbol_ref "compute_mov_length (operands)"))])
+
+;; ----------------------------------------------------------------------
+;; PUSH INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn_and_split "*push1_<QHI:mode>"
+  [(set (mem:QHI
+	(pre_modify:P
+	  (reg:P SP_REG)
+	  (plus:P (reg:P SP_REG) (const_int -4))))
+	(match_operand:QHI 0 "register_no_sp_elim_operand" "r"))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (mem:QHI
+		     (pre_modify:P (reg:P SP_REG)
+				   (plus:P (reg:P SP_REG) (const_int -4))))
+		   (match_dup 0))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*push1_<QHI:mode>_clobber_flags"
+  [(set (mem:QHI
+	(pre_modify:P
+	  (reg:P SP_REG)
+	  (plus:P (reg:P SP_REG) (const_int -4))))
+	(match_operand:QHI 0 "register_no_sp_elim_operand" "r"))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mov.l\\t%S0,@-er7"
+  [(set_attr "length" "4")])
+
diff --git a/gcc/config/h8300/multiply.md b/gcc/config/h8300/multiply.md
new file mode 100644
index 00000000000..839798dd547
--- /dev/null
+++ b/gcc/config/h8300/multiply.md
@@ -0,0 +1,342 @@
+;; ----------------------------------------------------------------------
+;; MULTIPLY INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+;; Note that the H8/300 can only handle umulqihi3.
+
+(define_expand "mulqihi3"
+  [(set (match_operand:HI 0 "register_operand" "")
+	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" ""))
+		 ;; intentionally-mismatched modes
+		 (match_operand:QI 2 "reg_or_nibble_operand" "")))]
+  ""
+  {
+    if (GET_MODE (operands[2]) != VOIDmode)
+      operands[2] = gen_rtx_SIGN_EXTEND (HImode, operands[2]);
+  })
+
+(define_insn_and_split "*mulqihi3_const"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
+		 (match_operand:QI 2 "nibble_operand" "IP4>X")))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (mult:HI (sign_extend:HI (match_dup 1)) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*mulqihi3_const_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
+		 (match_operand:QI 2 "nibble_operand" "IP4>X")))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  "mulxs.b	%X2,%T0"
+  [(set_attr "length" "4")])
+
+(define_insn "*mulqihi3_const_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
+		   (match_operand:QI 2 "nibble_operand" "IP4>X"))
+	  (const_int 0)))
+   (set (match_operand:HI 0 "register_operand" "=r")
+	(mult:HI (sign_extend:HI (match_dup 1)) (match_dup 2)))]
+  "TARGET_H8300SX"
+  "mulxs.b	%X2,%T0"
+  [(set_attr "length" "4")])
+
+(define_insn_and_split "*mulqihi3"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
+		 (sign_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (mult:HI (sign_extend:HI (match_dup 1))
+			    (sign_extend:HI (match_dup 2))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*mulqihi3_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
+		 (sign_extend:HI (match_operand:QI 2 "register_operand" "r"))))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mulxs.b	%X2,%T0"
+  [(set_attr "length" "4")])
+
+(define_insn "*mulqihi3_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (mult:HI
+	    (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
+	    (sign_extend:HI (match_operand:QI 2 "register_operand" "r")))
+	  (const_int 0)))
+   (set (match_operand:HI 0 "register_operand" "=r")
+	(mult:HI (sign_extend:HI (match_dup 1)) (sign_extend (match_dup 2))))]
+  ""
+  "mulxs.b	%X2,%T0"
+  [(set_attr "length" "4")])
+
+(define_expand "mulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" ""))
+		 ;; intentionally-mismatched modes
+		 (match_operand:HI 2 "reg_or_nibble_operand" "")))]
+  ""
+  {
+    if (GET_MODE (operands[2]) != VOIDmode)
+      operands[2] = gen_rtx_SIGN_EXTEND (SImode, operands[2]);
+  })
+
+(define_insn_and_split "*mulhisi3_const"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
+		 (match_operand:SI 2 "nibble_operand" "IP4>X")))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (mult:SI (sign_extend:SI (match_dup 1)) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*mulhisi3_const_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
+		 (match_operand:SI 2 "nibble_operand" "IP4>X")))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  "mulxs.w	%T2,%S0"
+  [(set_attr "length" "4")])
+
+(define_insn "*mulhisi3_const_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
+		   (match_operand:SI 2 "nibble_operand" "IP4>X"))
+	  (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI (sign_extend:SI (match_dup 1)) (match_dup 2)))]
+  "TARGET_H8300SX"
+  "mulxs.w	%T2,%S0"
+  [(set_attr "length" "4")])
+
+(define_insn_and_split "*mulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
+		 (sign_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (mult:SI (sign_extend:SI (match_dup 1))
+			    (sign_extend:SI (match_dup 2))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*mulhisi3_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
+		 (sign_extend:SI (match_operand:HI 2 "register_operand" "r"))))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "mulxs.w	%T2,%S0"
+  [(set_attr "length" "4")])
+
+(define_insn "*mulhisi3_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
+		   (sign_extend:SI (match_operand:HI 2 "register_operand" "r")))
+	  (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI (sign_extend:SI (match_dup 1))
+		 (sign_extend:SI (match_dup 2))))]
+  ""
+  "mulxs.w	%T2,%S0"
+  [(set_attr "length" "4")])
+
+(define_expand "umulqihi3"
+  [(set (match_operand:HI 0 "register_operand" "")
+	(mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" ""))
+		 ;; intentionally-mismatched modes
+		 (match_operand:QI 2 "reg_or_nibble_operand" "")))]
+  ""
+  {
+    if (GET_MODE (operands[2]) != VOIDmode)
+      operands[2] = gen_rtx_ZERO_EXTEND (HImode, operands[2]);
+  })
+
+(define_insn "*umulqihi3_const"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "%0"))
+		 (match_operand:QI 2 "nibble_operand" "IP4>X")))]
+  "TARGET_H8300SX"
+  "mulxu.b	%X2,%T0"
+  [(set_attr "length" "4")])
+
+(define_insn "*umulqihi3"
+  [(set (match_operand:HI 0 "register_operand" "=r")
+	(mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "%0"))
+		 (zero_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
+  ""
+  "mulxu.b	%X2,%T0"
+  [(set_attr "length" "2")])
+
+(define_expand "umulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(mult:SI (zero_extend:SI (match_operand:HI 1 "register_operand" ""))
+		 ;; intentionally-mismatched modes
+		 (match_operand:HI 2 "reg_or_nibble_operand" "")))]
+  ""
+  {
+    if (GET_MODE (operands[2]) != VOIDmode)
+      operands[2] = gen_rtx_ZERO_EXTEND (SImode, operands[2]);
+  })
+
+(define_insn "*umulhisi3_const"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI (zero_extend:SI (match_operand:HI 1 "register_operand" "%0"))
+		 (match_operand:SI 2 "nibble_operand" "IP4>X")))]
+  "TARGET_H8300SX"
+  "mulxu.w	%T2,%S0"
+  [(set_attr "length" "4")])
+
+(define_insn "*umulhisi3"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(mult:SI (zero_extend:SI (match_operand:HI 1 "register_operand" "%0"))
+		 (zero_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
+  ""
+  "mulxu.w	%T2,%S0"
+  [(set_attr "length" "2")])
+
+;; We could have used mulu.[wl] here, but mulu.[lw] is only available
+;; on a H8SX with a multiplier, whereas muls.w seems to be available
+;; on all H8SX variants.
+
+(define_insn_and_split "mul<mode>3"
+  [(set (match_operand:HSI 0 "register_operand" "=r")
+        (mult:HSI (match_operand:HSI 1 "register_operand" "%0")
+		  (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X")))]
+  "TARGET_H8300SX"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (mult:HSI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "mul<mode>3_clobber_flags"
+  [(set (match_operand:HSI 0 "register_operand" "=r")
+        (mult:HSI (match_operand:HSI 1 "register_operand" "%0")
+		  (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X")))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SX"
+  { return <MODE>mode == HImode ? "muls.w\\t%T2,%T0" : "muls.l\\t%S2,%S0"; }
+  [(set_attr "length" "4")])
+
+(define_insn "mul<mode>3_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (mult:HSI (match_operand:HSI 1 "register_operand" "%0")
+		    (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X"))
+	  (const_int 0)))
+   (set (match_operand:HSI 0 "register_operand" "=r")
+        (mult:HSI (match_dup 1) (match_dup 2)))]
+  "TARGET_H8300SX"
+  { return <MODE>mode == HImode ? "muls.w\\t%T2,%T0" : "muls.l\\t%S2,%S0"; }
+  [(set_attr "length" "4")])
+
+(define_insn_and_split "smulsi3_highpart"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(truncate:SI
+	 (lshiftrt:DI
+	  (mult:DI
+	   (sign_extend:DI (match_operand:SI 1 "register_operand" "%0"))
+	   (sign_extend:DI (match_operand:SI 2 "reg_or_nibble_operand" "r IP4>X")))
+	  (const_int 32))))]
+  "TARGET_H8300SXMUL"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0)
+		   (truncate:SI (lshiftrt:DI (mult:DI
+					       (sign_extend:DI (match_dup 1))
+					       (sign_extend:DI (match_dup 2)))
+					     (const_int 32))))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "smulsi3_highpart_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(truncate:SI
+	 (lshiftrt:DI
+	  (mult:DI
+	   (sign_extend:DI (match_operand:SI 1 "register_operand" "%0"))
+	   (sign_extend:DI (match_operand:SI 2 "reg_or_nibble_operand" "r IP4>X")))
+	  (const_int 32))))
+   (clobber (reg:CC CC_REG))]
+  "TARGET_H8300SXMUL"
+  "muls/u.l\\t%S2,%S0"
+  [(set_attr "length" "4")])
+
+(define_insn "smulsi3_highpart_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (truncate:SI
+	    (lshiftrt:DI
+	      (mult:DI
+	        (sign_extend:DI (match_operand:SI 1 "register_operand" "%0"))
+	        (sign_extend:DI (match_operand:SI 2 "reg_or_nibble_operand" "r IP4>X")))
+	      (const_int 32)))
+	  (const_int 0)))
+    (set (match_operand:SI 0 "register_operand" "=r")
+	(truncate:SI
+	 (lshiftrt:DI
+	  (mult:DI (sign_extend:DI (match_dup 1)) (sign_extend:DI (match_dup 2)))
+	  (const_int 32))))]
+  "TARGET_H8300SXMUL"
+  "muls/u.l\\t%S2,%S0"
+  [(set_attr "length" "4")])
+
+(define_insn "umulsi3_highpart"
+  [(set (match_operand:SI 0 "register_operand" "=r")
+	(truncate:SI
+	  (ashiftrt:DI
+	    (mult:DI
+	      (zero_extend:DI (match_operand:SI 1 "register_operand" "%0"))
+	      (zero_extend:DI (match_operand:SI 2 "reg_or_nibble_operand" "r IP4>X")))
+	    (const_int 32))))]
+  "TARGET_H8300SX"
+  "mulu/u.l\\t%S2,%S0"
+  [(set_attr "length" "4")])
+
+;; This is a "bridge" instruction.  Combine can't cram enough insns
+;; together to crate a MAC instruction directly, but it can create
+;; this instruction, which then allows combine to create the real
+;; MAC insn.
+;;
+;; Unfortunately, if combine doesn't create a MAC instruction, this
+;; insn must generate reasonably correct code.  Egad.
+
+(define_insn ""
+  [(set (match_operand:SI 0 "register_operand" "=a")
+	(mult:SI
+	  (sign_extend:SI
+	    (mem:HI (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
+	  (sign_extend:SI
+	    (mem:HI (post_inc:SI (match_operand:SI 2 "register_operand" "r"))))))]
+  "TARGET_MAC"
+  "clrmac\;mac	@%2+,@%1+"
+  [(set_attr "length" "6")])
+
+(define_insn ""
+  [(set (match_operand:SI 0 "register_operand" "=a")
+	(plus:SI (mult:SI
+	  (sign_extend:SI (mem:HI
+	    (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
+	  (sign_extend:SI (mem:HI
+	    (post_inc:SI (match_operand:SI 2 "register_operand" "r")))))
+	      (match_operand:SI 3 "register_operand" "0")))]
+  "TARGET_MAC"
+  "mac	@%2+,@%1+"
+  [(set_attr "length" "4")])
+
diff --git a/gcc/config/h8300/other.md b/gcc/config/h8300/other.md
new file mode 100644
index 00000000000..572a29fb2d9
--- /dev/null
+++ b/gcc/config/h8300/other.md
@@ -0,0 +1,26 @@
+;; ----------------------------------------------------------------------
+;; ABSOLUTE VALUE INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_insn_and_split "abssf2"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(abs:SF (match_operand:SF 1 "register_operand" "0")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (abs:SF (match_dup 1)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "abssf2_clobber_flags"
+  [(set (match_operand:SF 0 "register_operand" "=r")
+	(abs:SF (match_operand:SF 1 "register_operand" "0")))
+   (clobber (reg:CC CC_REG))]
+  ""
+  "and.w\\t#32767,%e0"
+  [(set_attr "length" "4")])
+
+(define_insn "nop"
+  [(const_int 0)]
+  ""
+  "nop"
+  [(set_attr "length" "2")])
diff --git a/gcc/config/h8300/peepholes.md b/gcc/config/h8300/peepholes.md
new file mode 100644
index 00000000000..9086bddcf57
--- /dev/null
+++ b/gcc/config/h8300/peepholes.md
@@ -0,0 +1,1541 @@
+;; -----------------------------------------------------------------
+;; PEEPHOLE PATTERNS
+;; -----------------------------------------------------------------
+
+;; Convert (A >> B) & C to (A & 255) >> B if C == 255 >> B.
+
+(define_peephole2
+  [(parallel [(set (match_operand:HI 0 "register_operand" "")
+		   (lshiftrt:HI (match_dup 0)
+				(match_operand:HI 1 "const_int_operand" "")))
+	      (clobber (match_operand:HI 2 "" ""))])
+   (set (match_dup 0)
+	(and:HI (match_dup 0)
+		(match_operand:HI 3 "const_int_operand" "")))]
+  "INTVAL (operands[3]) == (255 >> INTVAL (operands[1]))"
+  [(set (match_dup 0)
+	(and:HI (match_dup 0)
+		(const_int 255)))
+   (parallel [(set (match_dup 0)
+		   (lshiftrt:HI (match_dup 0) (match_dup 1)))
+	      (clobber (match_dup 2))])]
+  "")
+
+;; Convert (A << B) & C to (A & 255) << B if C == 255 << B.
+
+(define_peephole2
+  [(parallel [(set (match_operand:HI 0 "register_operand" "")
+		   (ashift:HI (match_dup 0)
+			      (match_operand:HI 1 "const_int_operand" "")))
+	      (clobber (match_operand:HI 2 "" ""))])
+   (set (match_dup 0)
+	(and:HI (match_dup 0)
+		(match_operand:HI 3 "const_int_operand" "")))]
+  "INTVAL (operands[3]) == (255 << INTVAL (operands[1]))"
+  [(set (match_dup 0)
+	(and:HI (match_dup 0)
+		(const_int 255)))
+   (parallel [(set (match_dup 0)
+		   (ashift:HI (match_dup 0) (match_dup 1)))
+	      (clobber (match_dup 2))])]
+  "")
+
+;; Convert (A >> B) & C to (A & 255) >> B if C == 255 >> B.
+
+(define_peephole2
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (lshiftrt:SI (match_dup 0)
+				(match_operand:SI 1 "const_int_operand" "")))
+	      (clobber (match_operand:SI 2 "" ""))])
+   (set (match_dup 0)
+	(and:SI (match_dup 0)
+		(match_operand:SI 3 "const_int_operand" "")))]
+  "INTVAL (operands[3]) == (255 >> INTVAL (operands[1]))"
+  [(set (match_dup 0)
+	(and:SI (match_dup 0)
+		(const_int 255)))
+   (parallel [(set (match_dup 0)
+		   (lshiftrt:SI (match_dup 0) (match_dup 1)))
+	      (clobber (match_dup 2))])]
+  "")
+
+;; Convert (A << B) & C to (A & 255) << B if C == 255 << B.
+
+(define_peephole2
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (ashift:SI (match_dup 0)
+			      (match_operand:SI 1 "const_int_operand" "")))
+	      (clobber (match_operand:SI 2 "" ""))])
+   (set (match_dup 0)
+	(and:SI (match_dup 0)
+		(match_operand:SI 3 "const_int_operand" "")))]
+  "INTVAL (operands[3]) == (255 << INTVAL (operands[1]))"
+  [(set (match_dup 0)
+	(and:SI (match_dup 0)
+		(const_int 255)))
+   (parallel [(set (match_dup 0)
+		   (ashift:SI (match_dup 0) (match_dup 1)))
+	      (clobber (match_dup 2))])]
+  "")
+
+;; Convert (A >> B) & C to (A & 65535) >> B if C == 65535 >> B.
+
+(define_peephole2
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (lshiftrt:SI (match_dup 0)
+				(match_operand:SI 1 "const_int_operand" "")))
+	      (clobber (match_operand:SI 2 "" ""))])
+   (set (match_dup 0)
+	(and:SI (match_dup 0)
+		(match_operand:SI 3 "const_int_operand" "")))]
+  "INTVAL (operands[3]) == (65535 >> INTVAL (operands[1]))"
+  [(set (match_dup 0)
+	(and:SI (match_dup 0)
+		(const_int 65535)))
+   (parallel [(set (match_dup 0)
+		   (lshiftrt:SI (match_dup 0) (match_dup 1)))
+	      (clobber (match_dup 2))])]
+  "")
+
+;; Convert (A << B) & C to (A & 65535) << B if C == 65535 << B.
+
+(define_peephole2
+  [(parallel [(set (match_operand:SI 0 "register_operand" "")
+		   (ashift:SI (match_dup 0)
+			      (match_operand:SI 1 "const_int_operand" "")))
+	      (clobber (match_operand:SI 2 "" ""))])
+   (set (match_dup 0)
+	(and:SI (match_dup 0)
+		(match_operand:SI 3 "const_int_operand" "")))]
+  "INTVAL (operands[3]) == (65535 << INTVAL (operands[1]))"
+  [(set (match_dup 0)
+	(and:SI (match_dup 0)
+		(const_int 65535)))
+   (parallel [(set (match_dup 0)
+		   (ashift:SI (match_dup 0) (match_dup 1)))
+	      (clobber (match_dup 2))])]
+  "")
+
+;; Cram four pushes into stm.l.
+
+(define_peephole2
+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+	(match_operand:SI 0 "register_operand" ""))
+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+	(match_operand:SI 1 "register_operand" ""))
+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+	(match_operand:SI 2 "register_operand" ""))
+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+	(match_operand:SI 3 "register_operand" ""))]
+  "TARGET_H8300S && !TARGET_NORMAL_MODE
+   && (REGNO_REG_CLASS (REGNO (operands[3])) == GENERAL_REGS
+       && REGNO (operands[1]) == REGNO (operands[0]) + 1
+       && REGNO (operands[2]) == REGNO (operands[0]) + 2
+       && REGNO (operands[3]) == REGNO (operands[0]) + 3
+       && (TARGET_H8300SX || REGNO (operands[0]) == 0))"
+  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))
+		   (match_dup 0))
+	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))
+		   (match_dup 1))
+	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))
+		   (match_dup 2))
+	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -16)))
+		   (match_dup 3))
+	      (set (reg:SI SP_REG)
+		   (plus:SI (reg:SI SP_REG)
+			    (const_int -16)))])]
+  "")
+
+(define_peephole2
+  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
+	(match_operand:SI 0 "register_operand" ""))
+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
+	(match_operand:SI 1 "register_operand" ""))
+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
+	(match_operand:SI 2 "register_operand" ""))
+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
+	(match_operand:SI 3 "register_operand" ""))]
+  "TARGET_H8300S && TARGET_NORMAL_MODE
+   && (REGNO_REG_CLASS (REGNO (operands[3])) == GENERAL_REGS
+       && REGNO (operands[1]) == REGNO (operands[0]) + 1
+       && REGNO (operands[2]) == REGNO (operands[0]) + 2
+       && REGNO (operands[3]) == REGNO (operands[0]) + 3
+       && (TARGET_H8300SX || REGNO (operands[0]) == 0))"
+  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))
+		   (match_dup 0))
+	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))
+		   (match_dup 1))
+	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))
+		   (match_dup 2))
+	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -16)))
+		   (match_dup 3))
+	      (set (reg:HI SP_REG)
+		   (plus:HI (reg:HI SP_REG)
+			    (const_int -16)))])]
+  "")
+
+;; Cram three pushes into stm.l.
+
+(define_peephole2
+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+	(match_operand:SI 0 "register_operand" ""))
+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+	(match_operand:SI 1 "register_operand" ""))
+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+	(match_operand:SI 2 "register_operand" ""))]
+  "TARGET_H8300S && !TARGET_NORMAL_MODE
+   && (REGNO_REG_CLASS (REGNO (operands[2])) == GENERAL_REGS
+       && REGNO (operands[1]) == REGNO (operands[0]) + 1
+       && REGNO (operands[2]) == REGNO (operands[0]) + 2
+       && (TARGET_H8300SX || (REGNO (operands[0]) & 3) == 0))"
+  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))
+		   (match_dup 0))
+	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))
+		   (match_dup 1))
+	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -12)))
+		   (match_dup 2))
+	      (set (reg:SI SP_REG)
+		   (plus:SI (reg:SI SP_REG)
+			    (const_int -12)))])]
+  "")
+
+(define_peephole2
+  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
+	(match_operand:SI 0 "register_operand" ""))
+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
+	(match_operand:SI 1 "register_operand" ""))
+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
+	(match_operand:SI 2 "register_operand" ""))]
+  "TARGET_H8300S && TARGET_NORMAL_MODE
+   && (REGNO_REG_CLASS (REGNO (operands[2])) == GENERAL_REGS
+       && REGNO (operands[1]) == REGNO (operands[0]) + 1
+       && REGNO (operands[2]) == REGNO (operands[0]) + 2
+       && (TARGET_H8300SX || (REGNO (operands[0]) & 3) == 0))"
+  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))
+		   (match_dup 0))
+	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))
+		   (match_dup 1))
+	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -12)))
+		   (match_dup 2))
+	      (set (reg:HI SP_REG)
+		   (plus:HI (reg:HI SP_REG)
+			    (const_int -12)))])]
+  "")
+
+;; Cram two pushes into stm.l.
+
+(define_peephole2
+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+	(match_operand:SI 0 "register_operand" ""))
+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+	(match_operand:SI 1 "register_operand" ""))]
+  "TARGET_H8300S && !TARGET_NORMAL_MODE
+   && (REGNO_REG_CLASS (REGNO (operands[1])) == GENERAL_REGS
+       && REGNO (operands[1]) == REGNO (operands[0]) + 1
+       && (TARGET_H8300SX || (REGNO (operands[0]) & 1) == 0))"
+  [(parallel [(set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -4)))
+		   (match_dup 0))
+	      (set (mem:SI (plus:SI (reg:SI SP_REG) (const_int -8)))
+		   (match_dup 1))
+	      (set (reg:SI SP_REG)
+		   (plus:SI (reg:SI SP_REG)
+			    (const_int -8)))])]
+  "")
+
+(define_peephole2
+  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
+	(match_operand:SI 0 "register_operand" ""))
+   (set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
+	(match_operand:SI 1 "register_operand" ""))]
+  "TARGET_H8300S && TARGET_NORMAL_MODE
+   && (REGNO_REG_CLASS (REGNO (operands[1])) == GENERAL_REGS
+       && REGNO (operands[1]) == REGNO (operands[0]) + 1
+       && (TARGET_H8300SX || (REGNO (operands[0]) & 1) == 0))"
+  [(parallel [(set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -4)))
+		   (match_dup 0))
+	      (set (mem:SI (plus:HI (reg:HI SP_REG) (const_int -8)))
+		   (match_dup 1))
+	      (set (reg:HI SP_REG)
+		   (plus:HI (reg:HI SP_REG)
+			    (const_int -8)))])]
+  "")
+
+;; Turn
+;;
+;;   mov.w #2,r0
+;;   add.w r7,r0  (6 bytes)
+;;
+;; into
+;;
+;;   mov.w r7,r0
+;;   adds  #2,r0  (4 bytes)
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+	(match_operand:HI 1 "const_int_operand" ""))
+   (set (match_dup 0)
+	(plus:HI (match_dup 0)
+		 (match_operand:HI 2 "register_operand" "")))]
+  "REG_P (operands[0]) && REG_P (operands[2])
+   && REGNO (operands[0]) != REGNO (operands[2])
+   && (satisfies_constraint_J (operands[1])
+       || satisfies_constraint_L (operands[1])
+       || satisfies_constraint_N (operands[1]))"
+  [(set (match_dup 0)
+	(match_dup 2))
+   (set (match_dup 0)
+	(plus:HI (match_dup 0)
+		 (match_dup 1)))]
+  "")
+
+;; Turn
+;;
+;;   sub.l  er0,er0
+;;   add.b  #4,r0l
+;;   add.l  er7,er0  (6 bytes)
+;;
+;; into
+;;
+;;   mov.l  er7,er0
+;;   adds   #4,er0   (4 bytes)
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "const_int_operand" ""))
+   (set (match_dup 0)
+	(plus:SI (match_dup 0)
+		 (match_operand:SI 2 "register_operand" "")))]
+  "REG_P (operands[0]) && REG_P (operands[2])
+   && REGNO (operands[0]) != REGNO (operands[2])
+   && (satisfies_constraint_L (operands[1])
+       || satisfies_constraint_N (operands[1]))"
+  [(set (match_dup 0)
+	(match_dup 2))
+   (set (match_dup 0)
+	(plus:SI (match_dup 0)
+		 (match_dup 1)))]
+  "")
+
+;; Turn
+;;
+;;   mov.l er7,er0
+;;   add.l #10,er0  (takes 8 bytes)
+;;
+;; into
+;;
+;;   sub.l er0,er0
+;;   add.b #10,r0l
+;;   add.l er7,er0  (takes 6 bytes)
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "register_operand" ""))
+   (set (match_dup 0)
+	(plus:SI (match_dup 0)
+		 (match_operand:SI 2 "const_int_operand" "")))]
+  "operands[0] != stack_pointer_rtx
+   && REG_P (operands[0]) && REG_P (operands[1])
+   && REGNO (operands[0]) != REGNO (operands[1])
+   && !satisfies_constraint_L (operands[2])
+   && !satisfies_constraint_N (operands[2])
+   && ((INTVAL (operands[2]) & 0xff) == INTVAL (operands[2])
+       || (INTVAL (operands[2]) & 0xff00) == INTVAL (operands[2])
+       || INTVAL (operands[2]) == 0xffff
+       || INTVAL (operands[2]) == 0xfffe)"
+  [(set (match_dup 0)
+	(match_dup 2))
+   (set (match_dup 0)
+	(plus:SI (match_dup 0)
+		 (match_dup 1)))]
+  "")
+
+;; Turn
+;;
+;;   subs   #1,er4
+;;   mov.w  r4,r4
+;;   bne    .L2028
+;;
+;; into
+;;
+;;   dec.w  #1,r4
+;;   bne    .L2028
+
+(define_peephole2
+  [(set (match_operand:HI 0 "register_operand" "")
+	(plus:HI (match_dup 0)
+		 (match_operand 1 "incdec_operand" "")))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_operator 3 "eqne_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  ""
+  [(set (match_operand:HI 0 "register_operand" "")
+	(unspec:HI [(match_dup 0)
+		    (match_dup 1)]
+		   UNSPEC_INCDEC))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  "")
+
+;; The SImode version of the previous pattern.
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(plus:SI (match_dup 0)
+		 (match_operand 1 "incdec_operand" "")))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_operator 3 "eqne_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  ""
+  [(set (match_operand:SI 0 "register_operand" "")
+	(unspec:SI [(match_dup 0)
+		    (match_dup 1)]
+		   UNSPEC_INCDEC))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  "")
+
+(define_peephole2
+  [(parallel [(set (cc0)
+		   (compare (zero_extract:SI (match_operand:QI 0 "register_operand" "")
+					     (const_int 1)
+					     (const_int 7))
+			    (const_int 0)))
+	      (clobber (scratch:QI))])
+   (set (pc)
+	(if_then_else (match_operator 1 "eqne_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  ""
+  [(set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  {
+    operands[3] = ((GET_CODE (operands[1]) == EQ)
+		   ? gen_rtx_GE (VOIDmode, cc0_rtx, const0_rtx)
+		   : gen_rtx_LT (VOIDmode, cc0_rtx, const0_rtx));
+  })
+
+;; The next three peephole2's will try to transform
+;;
+;;   mov.b A,r0l    (or mov.l A,er0)
+;;   and.l #CST,er0
+;;
+;; into
+;;
+;;   sub.l er0
+;;   mov.b A,r0l
+;;   and.b #CST,r0l (if CST is not 255)
+
+(define_peephole2
+  [(set (match_operand:QI 0 "register_operand" "")
+	(match_operand:QI 1 "general_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "")
+	(and:SI (match_dup 2)
+		(const_int 255)))]
+  "!reg_overlap_mentioned_p (operands[2], operands[1])
+   && REGNO (operands[0]) == REGNO (operands[2])"
+  [(set (match_dup 2)
+	(const_int 0))
+   (set (strict_low_part (match_dup 0))
+	(match_dup 1))]
+  "")
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "nonimmediate_operand" ""))
+   (set (match_dup 0)
+	(and:SI (match_dup 0)
+		(const_int 255)))]
+  "!reg_overlap_mentioned_p (operands[0], operands[1])
+   && !(GET_CODE (operands[1]) == MEM && !offsettable_memref_p (operands[1]))
+   && !(GET_CODE (operands[1]) == MEM && MEM_VOLATILE_P (operands[1]))"
+  [(set (match_dup 0)
+	(const_int 0))
+   (set (strict_low_part (match_dup 2))
+	(match_dup 3))]
+  {
+    operands[2] = gen_lowpart (QImode, operands[0]);
+    operands[3] = gen_lowpart (QImode, operands[1]);
+  })
+
+(define_peephole2
+  [(set (match_operand 0 "register_operand" "")
+	(match_operand 1 "nonimmediate_operand" ""))
+   (set (match_operand:SI 2 "register_operand" "")
+	(and:SI (match_dup 2)
+		(match_operand:SI 3 "const_int_qi_operand" "")))]
+  "(GET_MODE (operands[0]) == QImode
+    || GET_MODE (operands[0]) == HImode
+    || GET_MODE (operands[0]) == SImode)
+   && GET_MODE (operands[0]) == GET_MODE (operands[1])
+   && REGNO (operands[0]) == REGNO (operands[2])
+   && !reg_overlap_mentioned_p (operands[2], operands[1])
+   && !(GET_MODE (operands[1]) != QImode
+	&& GET_CODE (operands[1]) == MEM
+	&& !offsettable_memref_p (operands[1]))
+   && !(GET_MODE (operands[1]) != QImode
+	&& GET_CODE (operands[1]) == MEM
+	&& MEM_VOLATILE_P (operands[1]))"
+  [(set (match_dup 2)
+	(const_int 0))
+   (set (strict_low_part (match_dup 4))
+	(match_dup 5))
+   (set (match_dup 2)
+	(and:SI (match_dup 2)
+		(match_dup 6)))]
+  {
+    operands[4] = gen_lowpart (QImode, operands[0]);
+    operands[5] = gen_lowpart (QImode, operands[1]);
+    operands[6] = GEN_INT (~0xff | INTVAL (operands[3]));
+  })
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "register_operand" ""))
+   (set (match_dup 0)
+	(and:SI (match_dup 0)
+		(const_int 65280)))]
+  "!reg_overlap_mentioned_p (operands[0], operands[1])"
+  [(set (match_dup 0)
+	(const_int 0))
+   (set (zero_extract:SI (match_dup 0)
+			 (const_int 8)
+			 (const_int 8))
+	(lshiftrt:SI (match_dup 1)
+		     (const_int 8)))]
+  "")
+
+;; If a load of mem:SI is followed by an AND that turns off the upper
+;; half, then we can load mem:HI instead.
+
+(define_peephole2
+  [(set (match_operand:SI 0 "register_operand" "")
+	(match_operand:SI 1 "memory_operand" ""))
+   (set (match_dup 0)
+	(and:SI (match_dup 0)
+		(match_operand:SI 2 "const_int_operand" "")))]
+  "!MEM_VOLATILE_P (operands[1])
+   && offsettable_memref_p (operands[1])
+   && (INTVAL (operands[2]) & ~0xffff) == 0
+   && INTVAL (operands[2]) != 255"
+  [(set (match_dup 3)
+	(match_dup 4))
+   (set (match_dup 0)
+	(and:SI (match_dup 0)
+		(match_dup 2)))]
+  {
+    operands[3] = gen_lowpart (HImode, operands[0]);
+    operands[4] = gen_lowpart (HImode, operands[1]);
+  })
+
+;; Convert a memory comparison to a move if there is a scratch register.
+
+(define_peephole2
+  [(match_scratch:QI 1 "r")
+   (set (cc0)
+	(compare (match_operand:QI 0 "memory_operand" "")
+		 (const_int 0)))]
+  ""
+  [(set (match_dup 1)
+	(match_dup 0))
+   (set (cc0) (compare (match_dup 1)
+		       (const_int 0)))]
+  "")
+
+(define_peephole2
+  [(match_scratch:HI 1 "r")
+   (set (cc0)
+	(compare (match_operand:HI 0 "memory_operand" "")
+		 (const_int 0)))]
+  ""
+  [(set (match_dup 1)
+	(match_dup 0))
+   (set (cc0) (compare (match_dup 1)
+		       (const_int 0)))]
+  "")
+
+(define_peephole2
+  [(match_scratch:SI 1 "r")
+   (set (cc0)
+	(compare (match_operand:SI 0 "memory_operand" "")
+		 (const_int 0)))]
+  ""
+  [(set (match_dup 1)
+	(match_dup 0))
+   (set (cc0) (compare (match_dup 1)
+		       (const_int 0)))]
+  "")
+
+
+;; (compare (reg:HI) (const_int)) takes 4 bytes, so we try to achieve
+;; the equivalent with shorter sequences.  Here is the summary.  Cases
+;; are grouped for each define_peephole2.
+;;
+;; reg  const_int                   use     insn
+;; --------------------------------------------------------
+;; dead    -2                       eq/ne   inc.l
+;; dead    -1                       eq/ne   inc.l
+;; dead     1                       eq/ne   dec.l
+;; dead     2                       eq/ne   dec.l
+;;
+;; dead     1                       ge/lt shar.l
+;; dead     3 (H8S)                 ge/lt shar.l
+;;
+;; dead     1                       geu/ltu shar.l
+;; dead     3 (H8S)                 geu/ltu shar.l
+;;
+;; ----   255                       ge/lt mov.b
+;;
+;; ----   255                       geu/ltu mov.b
+
+;; Transform
+;;
+;;	cmp.w	#1,r0
+;;	bne	.L1
+;;
+;; into
+;;
+;;	dec.w	#1,r0
+;;	bne	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:HI 0 "register_operand" "")
+		 (match_operand:HI 1 "incdec_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 3 "eqne_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  "INTVAL (operands[1]) != 0 && peep2_reg_dead_p (1, operands[0])"
+  [(set (match_dup 0)
+	(unspec:HI [(match_dup 0)
+		    (match_dup 4)]
+		   UNSPEC_INCDEC))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  {
+    operands[4] = GEN_INT (- INTVAL (operands[1]));
+  })
+
+;; Transform
+;;
+;;	cmp.w	#1,r0
+;;	bgt	.L1
+;;
+;; into
+;;
+;;	shar.w	r0
+;;	bgt	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:HI 0 "register_operand" "")
+		 (match_operand:HI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 2 "gtle_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))]
+  "peep2_reg_dead_p (1, operands[0])
+   && (INTVAL (operands[1]) == 1
+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))"
+  [(parallel [(set (match_dup 0)
+		   (ashiftrt:HI (match_dup 0)
+				(match_dup 4)))
+	      (clobber (scratch:QI))])
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 2)
+		      (label_ref (match_dup 3))
+		      (pc)))]
+  {
+    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
+  })
+
+;; Transform
+;;
+;;	cmp.w	#1,r0
+;;	bhi	.L1
+;;
+;; into
+;;
+;;	shar.w	r0
+;;	bne	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:HI 0 "register_operand" "")
+		 (match_operand:HI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 2 "gtuleu_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))]
+  "peep2_reg_dead_p (1, operands[0])
+   && (INTVAL (operands[1]) == 1
+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))"
+  [(parallel [(set (match_dup 0)
+		   (ashiftrt:HI (match_dup 0)
+				(match_dup 4)))
+	      (clobber (scratch:QI))])
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 5)
+		      (label_ref (match_dup 3))
+		      (pc)))]
+  {
+    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
+    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,
+				  VOIDmode, cc0_rtx, const0_rtx);
+  })
+
+;; Transform
+;;
+;;	cmp.w	#255,r0
+;;	bgt	.L1
+;;
+;; into
+;;
+;;	mov.b	r0h,r0h
+;;	bgt	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:HI 0 "register_operand" "")
+		 (const_int 255)))
+   (set (pc)
+	(if_then_else (match_operator 1 "gtle_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  ""
+  [(set (cc0) (compare (and:HI (match_dup 0)
+			       (const_int -256))
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 1)
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  "")
+
+;; Transform
+;;
+;;	cmp.w	#255,r0
+;;	bhi	.L1
+;;
+;; into
+;;
+;;	mov.b	r0h,r0h
+;;	bne	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:HI 0 "register_operand" "")
+		 (const_int 255)))
+   (set (pc)
+	(if_then_else (match_operator 1 "gtuleu_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  ""
+  [(set (cc0) (compare (and:HI (match_dup 0)
+			       (const_int -256))
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 3)
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  {
+    operands[3] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,
+				  VOIDmode, cc0_rtx, const0_rtx);
+  })
+
+;; (compare (reg:SI) (const_int)) takes 6 bytes, so we try to achieve
+;; the equivalent with shorter sequences.  Here is the summary.  Cases
+;; are grouped for each define_peephole2.
+;;
+;; reg  const_int                   use     insn
+;; --------------------------------------------------------
+;; live    -2                       eq/ne   copy and inc.l
+;; live    -1                       eq/ne   copy and inc.l
+;; live     1                       eq/ne   copy and dec.l
+;; live     2                       eq/ne   copy and dec.l
+;;
+;; dead    -2                       eq/ne   inc.l
+;; dead    -1                       eq/ne   inc.l
+;; dead     1                       eq/ne   dec.l
+;; dead     2                       eq/ne   dec.l
+;;
+;; dead -131072                     eq/ne   inc.w and test
+;; dead  -65536                     eq/ne   inc.w and test
+;; dead   65536                     eq/ne   dec.w and test
+;; dead  131072                     eq/ne   dec.w and test
+;;
+;; dead 0x000000?? except 1 and 2   eq/ne   xor.b and test
+;; dead 0x0000??00                  eq/ne   xor.b and test
+;; dead 0x0000ffff                  eq/ne   not.w and test
+;;
+;; dead 0xffffff?? except -1 and -2 eq/ne   xor.b and not.l
+;; dead 0xffff??ff                  eq/ne   xor.b and not.l
+;; dead 0x40000000 (H8S)            eq/ne   rotl.l and dec.l
+;; dead 0x80000000                  eq/ne   rotl.l and dec.l
+;;
+;; live     1                       ge/lt copy and shar.l
+;; live     3 (H8S)                 ge/lt copy and shar.l
+;;
+;; live     1                       geu/ltu copy and shar.l
+;; live     3 (H8S)                 geu/ltu copy and shar.l
+;;
+;; dead     1                       ge/lt shar.l
+;; dead     3 (H8S)                 ge/lt shar.l
+;;
+;; dead     1                       geu/ltu shar.l
+;; dead     3 (H8S)                 geu/ltu shar.l
+;;
+;; dead     3 (H8/300H)             ge/lt and.b and test
+;; dead     7                       ge/lt and.b and test
+;; dead    15                       ge/lt and.b and test
+;; dead    31                       ge/lt and.b and test
+;; dead    63                       ge/lt and.b and test
+;; dead   127                       ge/lt and.b and test
+;; dead   255                       ge/lt and.b and test
+;;
+;; dead     3 (H8/300H)             geu/ltu and.b and test
+;; dead     7                       geu/ltu and.b and test
+;; dead    15                       geu/ltu and.b and test
+;; dead    31                       geu/ltu and.b and test
+;; dead    63                       geu/ltu and.b and test
+;; dead   127                       geu/ltu and.b and test
+;; dead   255                       geu/ltu and.b and test
+;;
+;; ---- 65535                       ge/lt mov.w
+;;
+;; ---- 65535                       geu/ltu mov.w
+
+;; Transform
+;;
+;;	cmp.l	#1,er0
+;;	beq	.L1
+;;
+;; into
+;;
+;;	dec.l	#1,er0
+;;	beq	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "incdec_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 3 "eqne_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  "INTVAL (operands[1]) != 0 && peep2_reg_dead_p (1, operands[0])"
+  [(set (match_dup 0)
+	(unspec:SI [(match_dup 0)
+		    (match_dup 4)]
+		   UNSPEC_INCDEC))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  {
+    operands[4] = GEN_INT (- INTVAL (operands[1]));
+  })
+
+;; Transform
+;;
+;;	cmp.l	#65536,er0
+;;	beq	.L1
+;;
+;; into
+;;
+;;	dec.l	#1,e0
+;;	beq	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 3 "eqne_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  "peep2_reg_dead_p (1, operands[0])
+   && (INTVAL (operands[1]) == -131072
+       || INTVAL (operands[1]) == -65536
+       || INTVAL (operands[1]) == 65536
+       || INTVAL (operands[1]) == 131072)"
+  [(set (match_dup 0)
+	(plus:SI (match_dup 0)
+		 (match_dup 4)))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  {
+    operands[4] = GEN_INT (- INTVAL (operands[1]));
+  })
+
+;; Transform
+;;
+;;	cmp.l	#100,er0
+;;	beq	.L1
+;;
+;; into
+;;
+;;	xor.b	#100,er0
+;;	mov.l	er0,er0
+;;	beq	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 3 "eqne_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  "peep2_reg_dead_p (1, operands[0])
+   && ((INTVAL (operands[1]) & 0x00ff) == INTVAL (operands[1])
+       || (INTVAL (operands[1]) & 0xff00) == INTVAL (operands[1])
+       || INTVAL (operands[1]) == 0x0000ffff)
+   && INTVAL (operands[1]) != 0
+   && INTVAL (operands[1]) != 1
+   && INTVAL (operands[1]) != 2"
+  [(set (match_dup 0)
+	(xor:SI (match_dup 0)
+		(match_dup 1)))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  "")
+
+;; Transform
+;;
+;;	cmp.l	#-100,er0
+;;	beq	.L1
+;;
+;; into
+;;
+;;	xor.b	#99,er0
+;;	not.l	er0
+;;	beq	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 3 "eqne_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  "peep2_reg_dead_p (1, operands[0])
+   && ((INTVAL (operands[1]) | 0x00ff) == -1
+       || (INTVAL (operands[1]) | 0xff00) == -1)
+   && INTVAL (operands[1]) != -1
+   && INTVAL (operands[1]) != -2"
+  [(set (match_dup 0)
+	(xor:SI (match_dup 0)
+		(match_dup 4)))
+   (set (match_dup 0)
+	(not:SI (match_dup 0)))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  {
+    operands[4] = GEN_INT (INTVAL (operands[1]) ^ -1);
+  })
+
+;; Transform
+;;
+;;	cmp.l	#-2147483648,er0
+;;	beq	.L1
+;;
+;; into
+;;
+;;	rotl.l	er0
+;;	dec.l	#1,er0
+;;	beq	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 3 "eqne_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  "peep2_reg_dead_p (1, operands[0])
+   && (INTVAL (operands[1]) == -2147483647 - 1
+       || (TARGET_H8300S && INTVAL (operands[1]) == 1073741824))"
+  [(set (match_dup 0)
+	(rotate:SI (match_dup 0)
+		   (match_dup 4)))
+   (set (match_dup 0)
+	(unspec:SI [(match_dup 0)
+		    (const_int -1)]
+		   UNSPEC_INCDEC))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  {
+    operands[4] = GEN_INT (INTVAL (operands[1]) == -2147483647 - 1 ? 1 : 2);
+  })
+
+;; Transform
+;;
+;;	cmp.l	#1,er0
+;;	bgt	.L1
+;;
+;; into
+;;
+;;	mov.l	er0,er1
+;;	shar.l	er1
+;;	bgt	.L1
+
+;; We avoid this transformation if we see more than one copy of the
+;; same compare insn immediately before this one.
+
+(define_peephole2
+  [(match_scratch:SI 4 "r")
+   (set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 2 "gtle_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))]
+  "!peep2_reg_dead_p (1, operands[0])
+   && (INTVAL (operands[1]) == 1
+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))
+   && !same_cmp_preceding_p (insn)"
+  [(set (match_dup 4)
+	(match_dup 0))
+   (parallel [(set (match_dup 4)
+		   (ashiftrt:SI (match_dup 4)
+				(match_dup 5)))
+	      (clobber (scratch:QI))])
+   (set (cc0) (compare (match_dup 4)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 2)
+		      (label_ref (match_dup 3))
+		      (pc)))]
+  {
+    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
+  })
+
+;; Transform
+;;
+;;	cmp.l	#1,er0
+;;	bhi	.L1
+;;
+;; into
+;;
+;;	mov.l	er0,er1
+;;	shar.l	er1
+;;	bne	.L1
+
+;; We avoid this transformation if we see more than one copy of the
+;; same compare insn immediately before this one.
+
+(define_peephole2
+  [(match_scratch:SI 4 "r")
+   (set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 2 "gtuleu_operator"
+		         [(cc0) (const_int 0)])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))]
+  "!peep2_reg_dead_p (1, operands[0])
+   && (INTVAL (operands[1]) == 1
+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))
+   && !same_cmp_preceding_p (insn)"
+  [(set (match_dup 4)
+	(match_dup 0))
+   (parallel [(set (match_dup 4)
+		   (ashiftrt:SI (match_dup 4)
+				(match_dup 5)))
+	      (clobber (scratch:QI))])
+   (set (cc0) (compare (match_dup 4)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 6)
+		      (label_ref (match_dup 3))
+		      (pc)))]
+  {
+    operands[5] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
+    operands[6] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,
+				  VOIDmode, cc0_rtx, const0_rtx);
+  })
+
+;; Transform
+;;
+;;	cmp.l	#1,er0
+;;	bgt	.L1
+;;
+;; into
+;;
+;;	shar.l	er0
+;;	bgt	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 2 "gtle_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))]
+  "peep2_reg_dead_p (1, operands[0])
+   && (INTVAL (operands[1]) == 1
+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))"
+  [(parallel [(set (match_dup 0)
+		   (ashiftrt:SI (match_dup 0)
+				(match_dup 4)))
+	      (clobber (scratch:QI))])
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 2)
+		      (label_ref (match_dup 3))
+		      (pc)))]
+  {
+    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
+  })
+
+;; Transform
+;;
+;;	cmp.l	#1,er0
+;;	bhi	.L1
+;;
+;; into
+;;
+;;	shar.l	er0
+;;	bne	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 2 "gtuleu_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))]
+  "peep2_reg_dead_p (1, operands[0])
+   && (INTVAL (operands[1]) == 1
+       || (TARGET_H8300S && INTVAL (operands[1]) == 3))"
+  [(parallel [(set (match_dup 0)
+		   (ashiftrt:SI (match_dup 0)
+				(match_dup 4)))
+	      (clobber (scratch:QI))])
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 5)
+		      (label_ref (match_dup 3))
+		      (pc)))]
+  {
+    operands[4] = GEN_INT (exact_log2 (INTVAL (operands[1]) + 1));
+    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,
+				  VOIDmode, cc0_rtx, const0_rtx);
+  })
+
+;; Transform
+;;
+;;	cmp.l	#15,er0
+;;	bgt	.L1
+;;
+;; into
+;;
+;;	and	#240,r0l
+;;	mov.l	er0,er0
+;;	bgt	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 2 "gtle_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))]
+  "peep2_reg_dead_p (1, operands[0])
+   && (INTVAL (operands[1]) == 3
+       || INTVAL (operands[1]) == 7
+       || INTVAL (operands[1]) == 15
+       || INTVAL (operands[1]) == 31
+       || INTVAL (operands[1]) == 63
+       || INTVAL (operands[1]) == 127
+       || INTVAL (operands[1]) == 255)"
+  [(set (match_dup 0)
+	(and:SI (match_dup 0)
+		(match_dup 4)))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 2)
+		      (label_ref (match_dup 3))
+		      (pc)))]
+  {
+    operands[4] = GEN_INT (~INTVAL (operands[1]));
+  })
+
+;; Transform
+;;
+;;	cmp.l	#15,er0
+;;	bhi	.L1
+;;
+;; into
+;;
+;;	and	#240,r0l
+;;	mov.l	er0,er0
+;;	bne	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "const_int_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 2 "gtuleu_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 3 "" ""))
+		      (pc)))]
+  "peep2_reg_dead_p (1, operands[0])
+   && ((TARGET_H8300H && INTVAL (operands[1]) == 3)
+	|| INTVAL (operands[1]) == 7
+	|| INTVAL (operands[1]) == 15
+	|| INTVAL (operands[1]) == 31
+	|| INTVAL (operands[1]) == 63
+	|| INTVAL (operands[1]) == 127
+	|| INTVAL (operands[1]) == 255)"
+  [(set (match_dup 0)
+	(and:SI (match_dup 0)
+		(match_dup 4)))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 5)
+		      (label_ref (match_dup 3))
+		      (pc)))]
+  {
+    operands[4] = GEN_INT (~INTVAL (operands[1]));
+    operands[5] = gen_rtx_fmt_ee (GET_CODE (operands[2]) == GTU ? NE : EQ,
+				  VOIDmode, cc0_rtx, const0_rtx);
+  })
+
+;; Transform
+;;
+;;	cmp.l	#65535,er0
+;;	bgt	.L1
+;;
+;; into
+;;
+;;	mov.l	e0,e0
+;;	bgt	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (const_int 65535)))
+   (set (pc)
+	(if_then_else (match_operator 1 "gtle_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  ""
+  [(set (cc0) (compare (and:SI (match_dup 0)
+			       (const_int -65536))
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 1)
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  "")
+
+;; Transform
+;;
+;;	cmp.l	#65535,er0
+;;	bhi	.L1
+;;
+;; into
+;;
+;;	mov.l	e0,e0
+;;	bne	.L1
+
+(define_peephole2
+  [(set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (const_int 65535)))
+   (set (pc)
+	(if_then_else (match_operator 1 "gtuleu_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  ""
+  [(set (cc0) (compare (and:SI (match_dup 0)
+			       (const_int -65536))
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_dup 3)
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  {
+    operands[3] = gen_rtx_fmt_ee (GET_CODE (operands[1]) == GTU ? NE : EQ,
+				  VOIDmode, cc0_rtx, const0_rtx);
+  })
+
+;; Transform
+;;
+;;	cmp.l	#1,er0
+;;	beq	.L1
+;;
+;; into
+;;
+;;	mov.l	er0,er1
+;;	dec.l	#1,er1
+;;	beq	.L1
+
+;; We avoid this transformation if we see more than one copy of the
+;; same compare insn.
+
+(define_peephole2
+  [(match_scratch:SI 4 "r")
+   (set (cc0)
+	(compare (match_operand:SI 0 "register_operand" "")
+		 (match_operand:SI 1 "incdec_operand" "")))
+   (set (pc)
+	(if_then_else (match_operator 3 "eqne_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  "INTVAL (operands[1]) != 0
+   && !peep2_reg_dead_p (1, operands[0])
+   && !same_cmp_following_p (insn)"
+  [(set (match_dup 4)
+	(match_dup 0))
+   (set (match_dup 4)
+	(unspec:SI [(match_dup 4)
+		    (match_dup 5)]
+		   UNSPEC_INCDEC))
+   (set (cc0) (compare (match_dup 4)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  {
+    operands[5] = GEN_INT (- INTVAL (operands[1]));
+  })
+
+;; Narrow the mode of testing if possible.
+
+(define_peephole2
+  [(set (match_operand:HSI 0 "register_operand" "")
+	(and:HSI (match_dup 0)
+		 (match_operand:HSI 1 "const_int_operand" "")))
+   (set (cc0) (compare (match_dup 0)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_operator 3 "eqne_operator"
+		       [(cc0) (const_int 0)])
+		      (label_ref (match_operand 2 "" ""))
+		      (pc)))]
+  "((const_int_qi_operand (operands[1], QImode)
+     || (GET_MODE (operands[0]) == SImode
+	 && const_int_hi_operand (operands[1], HImode)))
+    && peep2_reg_dead_p (2, operands[0]))"
+  [(set (match_dup 4) (match_dup 6))
+   (set (cc0) (compare (match_dup 4)
+		       (const_int 0)))
+   (set (pc)
+	(if_then_else (match_op_dup 3 [(cc0) (const_int 0)])
+		      (label_ref (match_dup 2))
+		      (pc)))]
+  {
+    enum machine_mode mode;
+
+    mode = const_int_qi_operand (operands[1], QImode) ? QImode : HImode;
+    operands[4] = gen_rtx_REG (mode, REGNO (operands[0]));
+    operands[5] = gen_int_mode (INTVAL (operands[1]), mode);
+    operands[6] = gen_rtx_AND (mode, operands[4], operands[5]);
+  })
+
+;; These triggers right at the end of allocation of locals in the
+;; prologue (and possibly at other places).
+
+;; stack adjustment of -4, generate one push
+;;
+;; before : 6 bytes, 10 clocks
+;; after  : 4 bytes, 10 clocks
+
+(define_peephole2
+  [(set (reg:SI SP_REG)
+	(plus:SI (reg:SI SP_REG)
+		 (const_int -4)))
+   (set (mem:SI (reg:SI SP_REG))
+	(match_operand:SI 0 "register_operand" ""))]
+  "!TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG"
+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+	(match_dup 0))]
+  "")
+
+;; stack adjustment of -12, generate one push
+;;
+;; before : 10 bytes, 14 clocks
+;; after  :  8 bytes, 14 clocks
+
+(define_peephole2
+  [(set (reg:SI SP_REG)
+	(plus:SI (reg:SI SP_REG)
+		 (const_int -12)))
+   (set (mem:SI (reg:SI SP_REG))
+	(match_operand:SI 0 "register_operand" ""))]
+  "!TARGET_NORMAL_MODE && REGNO (operands[0]) != SP_REG"
+  [(set (reg:SI SP_REG)
+	(plus:SI (reg:SI SP_REG)
+		 (const_int -4)))
+   (set (reg:SI SP_REG)
+	(plus:SI (reg:SI SP_REG)
+		 (const_int -4)))
+   (set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+	(match_dup 0))]
+  "")
+
+;; Transform
+;;
+;;	mov	dst,reg
+;;	op	reg
+;;	mov	reg,dst
+;;
+;; into
+;;
+;;	op	dst
+;;
+;; if "reg" dies at the end of the sequence.
+
+(define_peephole2
+  [(set (match_operand 0 "register_operand" "")
+	(match_operand 1 "memory_operand" ""))
+   (set (match_dup 0)
+	(match_operator 2 "h8sx_unary_memory_operator"
+	 [(match_dup 0)]))
+   (set (match_operand 3 "memory_operand" "")
+	(match_dup 0))]
+  "TARGET_H8300SX
+   && peep2_reg_dead_p (3, operands[0])
+   && !reg_overlap_mentioned_p (operands[0], operands[3])
+   && h8sx_mergeable_memrefs_p (operands[3], operands[1])"
+  [(set (match_dup 3)
+	(match_dup 4))]
+  {
+    operands[4] = shallow_copy_rtx (operands[2]);
+    XEXP (operands[4], 0) = operands[1];
+  })
+
+;; Transform
+;;
+;;	mov	src1,reg
+;;	cmp	reg,src2
+;;
+;; into
+;;
+;;	cmp	src1,src2
+;;
+;; if "reg" dies in the comparison.
+
+(define_peephole2
+  [(set (match_operand 0 "register_operand" "")
+	(match_operand 1 "h8300_dst_operand" ""))
+   (set (cc0)
+	(compare (match_dup 0)
+		 (match_operand 2 "h8300_src_operand" "")))]
+  "TARGET_H8300SX
+   && peep2_reg_dead_p (2, operands[0])
+   && !reg_overlap_mentioned_p (operands[0], operands[2])
+   && operands[2] != const0_rtx"
+  [(set (cc0)
+	(compare (match_dup 1)
+		 (match_dup 2)))])
+
+;; Likewise for the second operand.
+
+(define_peephole2
+  [(set (match_operand 0 "register_operand" "")
+	(match_operand 1 "h8300_src_operand" ""))
+   (set (cc0)
+	(compare (match_operand 2 "h8300_dst_operand" "")
+		 (match_dup 0)))]
+  "TARGET_H8300SX
+   && peep2_reg_dead_p (2, operands[0])
+   && !reg_overlap_mentioned_p (operands[0], operands[2])"
+  [(set (cc0)
+	(compare (match_dup 2)
+		 (match_dup 1)))])
+
+;; Combine two moves.
+
+(define_peephole2
+  [(set (match_operand 0 "register_operand" "")
+	(match_operand 1 "h8300_src_operand" ""))
+   (set (match_operand 2 "h8300_dst_operand" "")
+	(match_dup 0))]
+  "TARGET_H8300SX
+   && peep2_reg_dead_p (2, operands[0])
+   && !reg_overlap_mentioned_p (operands[0], operands[2])"
+  [(set (match_dup 2)
+	(match_dup 1))])
+
+
diff --git a/gcc/config/h8300/predicates.md b/gcc/config/h8300/predicates.md
index 5e9461180f7..6496992dbe8 100644
--- a/gcc/config/h8300/predicates.md
+++ b/gcc/config/h8300/predicates.md
@@ -296,30 +296,17 @@
          the negative case.  */
       if (value < 0)
 	value = -value;
-      if (TARGET_H8300H || TARGET_H8300S)
-	{
-	  /* A constant addition/subtraction takes 2 states in QImode,
-	     4 states in HImode, and 6 states in SImode.  Thus, the
-	     only case we can win is when SImode is used, in which
-	     case, two adds/subs are used, taking 4 states.  */
-	  if (mode == SImode
-	      && (value == 2 + 1
-		  || value == 4 + 1
-		  || value == 4 + 2
-		  || value == 4 + 4))
-	    return 1;
-	}
-      else
-	{
-	  /* We do not profit directly by splitting addition or
-	     subtraction of 3 and 4.  However, since these are
-	     implemented as a sequence of adds or subs, they do not
-	     clobber (cc0) unlike a sequence of add.b and add.x.  */
-	  if (mode == HImode
-	      && (value == 2 + 1
-		  || value == 2 + 2))
-	    return 1;
-	}
+
+      /* A constant addition/subtraction takes 2 states in QImode,
+	 4 states in HImode, and 6 states in SImode.  Thus, the
+	 only case we can win is when SImode is used, in which
+	 case, two adds/subs are used, taking 4 states.  */
+      if (mode == SImode
+	  && (value == 2 + 1
+	      || value == 4 + 1
+	      || value == 4 + 2
+	      || value == 4 + 4))
+	return 1;
     }
 
   return 0;
diff --git a/gcc/config/h8300/proepi.md b/gcc/config/h8300/proepi.md
new file mode 100644
index 00000000000..44d59682496
--- /dev/null
+++ b/gcc/config/h8300/proepi.md
@@ -0,0 +1,123 @@
+;; ----------------------------------------------------------------------
+;; PROLOGUE/EPILOGUE-RELATED INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+(define_expand "push_h8300hs_advanced"
+  [(set (mem:SI (pre_dec:SI (reg:SI SP_REG)))
+        (match_operand:SI 0 "register_operand" ""))]
+  "TARGET_H8300H && TARGET_H8300S && !TARGET_NORMAL_MODE"
+  "")
+
+(define_expand "push_h8300hs_normal"
+  [(set (mem:SI (pre_dec:HI (reg:HI SP_REG)))
+        (match_operand:SI 0 "register_operand" ""))]
+  "TARGET_H8300H && TARGET_H8300S && TARGET_NORMAL_MODE"
+  "")
+
+(define_expand "pop_h8300hs_advanced"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(mem:SI (post_inc:SI (reg:SI SP_REG))))]
+  "TARGET_H8300H && TARGET_H8300S && !TARGET_NORMAL_MODE"
+  "")
+
+(define_expand "pop_h8300hs_normal"
+  [(set (match_operand:SI 0 "register_operand" "")
+	(mem:SI (post_inc:HI (reg:HI SP_REG))))]
+  "TARGET_H8300H && TARGET_H8300S && TARGET_NORMAL_MODE"
+  "")
+
+(define_insn "ldm_h8300sx"
+  [(match_parallel           0 "h8300_ldm_parallel"
+    [(set (match_operand:SI 1 "register_operand" "")
+	  (match_operand:SI 2 "memory_operand" ""))])]
+  "TARGET_H8300S"
+{
+  operands[3] = SET_DEST (XVECEXP (operands[0], 0,
+				   XVECLEN (operands[0], 0) - 2));
+  return "ldm.l\t@er7+,%S1-%S3";
+}
+  [(set_attr "length" "4")])
+
+(define_insn "stm_h8300sx"
+  [(match_parallel           0 "h8300_stm_parallel"
+    [(set (match_operand:SI 1 "memory_operand" "")
+	  (match_operand:SI 2 "register_operand" ""))])]
+  "TARGET_H8300S"
+{
+  operands[3] = SET_SRC (XVECEXP (operands[0], 0,
+				  XVECLEN (operands[0], 0) - 2));
+  return "stm.l\t%S2-%S3,@-er7";
+}
+  [(set_attr "length" "4")])
+
+(define_insn "return_h8sx"
+  [(match_parallel           0 "h8300_return_parallel"
+    [(return)
+     (set (match_operand:SI 1 "register_operand" "")
+	  (match_operand:SI 2 "memory_operand" ""))])]
+  "TARGET_H8300SX"
+{
+  operands[3] = SET_DEST (XVECEXP (operands[0], 0,
+				   XVECLEN (operands[0], 0) - 2));
+  if (h8300_current_function_interrupt_function_p ()
+      || h8300_current_function_monitor_function_p ())
+    return "rte/l\t%S1-%S3";
+  else
+    return "rts/l\t%S1-%S3";
+}
+  [(set_attr "can_delay" "no")
+   (set_attr "length" "2")])
+
+(define_expand "return"
+  [(return)]
+  "h8300_can_use_return_insn_p ()"
+  "")
+
+(define_insn "*return_1"
+  [(return)]
+  "reload_completed"
+{
+  if (h8300_current_function_interrupt_function_p ()
+      || h8300_current_function_monitor_function_p ())
+    return "rte";
+  else
+    return "rts";
+}
+  [(set_attr "can_delay" "no")
+   (set_attr "length" "2")])
+
+(define_expand "prologue"
+  [(const_int 0)]
+  ""
+  {
+    h8300_expand_prologue ();
+    DONE;
+  })
+
+(define_expand "epilogue"
+  [(return)]
+  ""
+  {
+    h8300_expand_epilogue ();
+    DONE;
+  })
+
+(define_insn "monitor_prologue"
+  [(unspec_volatile [(const_int 0)] UNSPEC_MONITOR)]
+  ""
+{
+  if (TARGET_H8300H && TARGET_NORMAL_MODE)
+    return "subs\\t#2,er7\;mov.l\\ter0,@-er7\;stc\\tccr,r0l\;mov.b\\tr0l,@(4,er7)\;mov.l\\t@er7+,er0\;orc\\t#128,ccr";
+  else if (TARGET_H8300H)
+    return "mov.l\\ter0,@-er7\;stc\\tccr,r0l\;mov.b\\tr0l,@(4,er7)\;mov.l\\t@er7+,er0\;orc\\t#128,ccr";
+  else if (TARGET_H8300S && TARGET_NEXR )
+    return "mov.l\\ter0,@-er7\;stc\tccr,r0l\;mov.b\tr0l,@(4,er7)\;mov.l\\t@er7+,er0\;orc\t#128,ccr";
+  else if (TARGET_H8300S && TARGET_NEXR && TARGET_NORMAL_MODE)
+    return "subs\\t#2,er7\;mov.l\\ter0,@-er7\;stc\tccr,r0l\;mov.b\tr0l,@(4,er7)\;mov.l\\t@er7+,er0\;orc\t#128,ccr";
+  else if (TARGET_H8300S && TARGET_NORMAL_MODE)
+    return "subs\\t#2,er7\;stc\texr,@-er7\;mov.l\\ter0,@-er7\;stc\tccr,r0l\;mov.b\tr0l,@(6,er7)\;mov.l\\t@er7+,er0\;orc\t#128,ccr";
+  else if (TARGET_H8300S)
+    return "stc\texr,@-er7\;mov.l\\ter0,@-er7\;stc\tccr,r0l\;mov.b\tr0l,@(6,er7)\;mov.l\\t@er7+,er0\;orc\t#128,ccr";
+  gcc_unreachable ();
+}
+  [(set_attr "length" "20")])
diff --git a/gcc/config/h8300/shiftrotate.md b/gcc/config/h8300/shiftrotate.md
new file mode 100644
index 00000000000..a6f05097ece
--- /dev/null
+++ b/gcc/config/h8300/shiftrotate.md
@@ -0,0 +1,393 @@
+;; ----------------------------------------------------------------------
+;; SHIFTS
+;; ----------------------------------------------------------------------
+;;
+;; We make some attempt to provide real efficient shifting.  One example is
+;; doing an 8-bit shift of a 16-bit value by moving a byte reg into the other
+;; reg and moving 0 into the former reg.
+;;
+;; We also try to achieve this in a uniform way.  IE: We don't try to achieve
+;; this in both rtl and at insn emit time.  Ideally, we'd use rtl as that would
+;; give the optimizer more cracks at the code.  However, we wish to do things
+;; like optimizing shifting the sign bit to bit 0 by rotating the other way.
+;; There is rtl to handle this (rotate + and), but the H8/300 doesn't handle
+;; 16-bit rotates.  Also, if we emit complicated rtl, combine may not be able
+;; to detect cases it can optimize.
+;;
+;; For these and other fuzzy reasons, I've decided to go the less pretty but
+;; easier "do it at insn emit time" route.
+
+
+(define_expand "ashl<mode>3"
+  [(set (match_operand:QHSI 0 "register_operand" "")
+	(ashift:QHSI (match_operand:QHSI 1 "register_operand" "")
+		     (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  {
+    if (expand_a_shift (<MODE>mode, ASHIFT, operands))
+    DONE;
+  })
+
+(define_expand "ashr<mode>3"
+  [(set (match_operand:QHSI 0 "register_operand" "")
+	(ashiftrt:QHSI (match_operand:QHSI 1 "register_operand" "")
+		       (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  {
+    if (expand_a_shift (<MODE>mode, ASHIFTRT, operands))
+    DONE;
+  })
+
+(define_expand "lshr<mode>3"
+  [(set (match_operand:QHSI 0 "register_operand" "")
+	(lshiftrt:QHSI (match_operand:QHSI 1 "register_operand" "")
+		       (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  {
+    if (expand_a_shift (<MODE>mode, LSHIFTRT, operands))
+    DONE;
+  })
+
+;; QI/HI/SI BIT SHIFTS
+
+(define_insn_and_split ""
+  [(set (match_operand:QHSI 0 "h8300_dst_operand" "=rQ")
+	(match_operator:QHSI 3 "h8sx_unary_shift_operator"
+	 [(match_operand:QHSI 1 "h8300_dst_operand" "0")
+	  (match_operand:QI 2 "const_int_operand" "")]))]
+  "h8300_operands_match_p (operands)"
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_op_dup 3 [(match_dup 1) (match_dup 2)]))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn ""
+  [(set (match_operand:QHSI 0 "h8300_dst_operand" "=rQ")
+	(match_operator:QHSI 3 "h8sx_unary_shift_operator"
+	 [(match_operand:QHSI 1 "h8300_dst_operand" "0")
+	  (match_operand:QI 2 "const_int_operand" "")]))
+   (clobber (reg:CC CC_REG))]
+  "h8300_operands_match_p (operands)"
+{
+  if (<MODE>mode == E_QImode)
+    return output_h8sx_shift (operands, 'b', 'X');
+  if (<MODE>mode == E_HImode)
+    return output_h8sx_shift (operands, 'w', 'T');
+  if (<MODE>mode == E_SImode)
+    return output_h8sx_shift (operands, 'l', 'S');
+  gcc_unreachable ();
+}
+  [(set_attr "length_table" "unary")])
+
+(define_insn ""
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operator:QHSI 3 "h8sx_unary_shift_operator"
+	    [(match_operand:QHSI 1 "h8300_dst_operand" "0")
+	     (match_operand:QI 2 "const_int_operand" "")])
+	  (const_int 0)))
+   (set (match_operand:QHSI 0 "h8300_dst_operand" "=rQ")
+	(match_op_dup 3 [(match_dup 1) (match_dup 2)]))]
+  "h8300_operands_match_p (operands)"
+{
+  if (<MODE>mode == E_QImode)
+    return output_h8sx_shift (operands, 'b', 'X');
+  if (<MODE>mode == E_HImode)
+    return output_h8sx_shift (operands, 'w', 'T');
+  if (<MODE>mode == E_SImode)
+    return output_h8sx_shift (operands, 'l', 'S');
+  gcc_unreachable ();
+}
+  [(set_attr "length_table" "unary")])
+
+(define_insn_and_split ""
+  [(set (match_operand:QHSI 0 "register_operand" "=r")
+	(match_operator:QHSI 3 "h8sx_binary_shift_operator"
+	 [(match_operand:QHSI 1 "register_operand" "0")
+	  (match_operand:QI 2 "nonmemory_operand" "r P5>X")]))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_op_dup 3 [(match_dup 1) (match_dup 2)]))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn ""
+  [(set (match_operand:QHSI 0 "register_operand" "=r")
+	(match_operator:QHSI 3 "h8sx_binary_shift_operator"
+	 [(match_operand:QHSI 1 "register_operand" "0")
+	  (match_operand:QI 2 "nonmemory_operand" "r P5>X")]))
+   (clobber (reg:CC CC_REG))]
+  ""
+{
+  if (<MODE>mode == QImode)
+    return output_h8sx_shift (operands, 'b', 'X');
+  if (<MODE>mode == HImode)
+    return output_h8sx_shift (operands, 'w', 'T');
+  if (<MODE>mode == SImode)
+    return output_h8sx_shift (operands, 'l', 'S');
+  gcc_unreachable ();
+}
+  [(set_attr "length" "4")])
+
+(define_insn ""
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operator:QHSI 3 "h8sx_binary_shift_operator"
+	   [(match_operand:QHSI 1 "register_operand" "0")
+	    (match_operand:QI 2 "nonmemory_operand" "r P5>X")])
+	  (const_int 0)))
+   (set (match_operand:QHSI 0 "register_operand" "=r")
+	(match_op_dup 3 [(match_dup 1) (match_dup 2)]))]
+  ""
+{
+  if (<MODE>mode == QImode)
+    return output_h8sx_shift (operands, 'b', 'X');
+  if (<MODE>mode == HImode)
+    return output_h8sx_shift (operands, 'w', 'T');
+  if (<MODE>mode == SImode)
+    return output_h8sx_shift (operands, 'l', 'S');
+  gcc_unreachable ();
+}
+  [(set_attr "length" "4")])
+
+(define_insn_and_split "*shiftqi"
+  [(set (match_operand:QI 0 "register_operand" "=r,r")
+	(match_operator:QI 3 "nshift_operator"
+	 [(match_operand:QI 1 "register_operand" "0,0")
+	  (match_operand:QI 2 "nonmemory_operand" "R,rn")]))
+   (clobber (match_scratch:QI 4 "=X,&r"))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_op_dup 3 [(match_dup 1) (match_dup 2)]))
+	      (clobber (match_dup 4))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*shiftqi_clobber_flags"
+  [(set (match_operand:QI 0 "register_operand" "=r,r")
+	(match_operator:QI 3 "nshift_operator"
+	 [(match_operand:QI 1 "register_operand" "0,0")
+	  (match_operand:QI 2 "nonmemory_operand" "R,rn")]))
+   (clobber (match_scratch:QI 4 "=X,&r"))
+   (clobber (reg:CC CC_REG))]
+  ""
+{
+  return output_a_shift (operands);
+}
+  [(set (attr "length")
+	(symbol_ref "compute_a_shift_length (insn, operands)"))])
+
+(define_insn "*shiftqi_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operator:QI 3 "nshift_operator"
+	   [(match_operand:QI 1 "register_operand" "0,0")
+	    (match_operand:QI 2 "nonmemory_operand" "R,rn")])
+	(const_int 0)))
+   (set (match_operand:QI 0 "register_operand" "=r,r")
+	(match_op_dup 3 [(match_dup 1) (match_dup 2)]))
+   (clobber (match_scratch:QI 4 "=X,&r"))]
+  "(compute_a_shift_cc (insn, operands) == 2
+    || compute_a_shift_cc (insn, operands) == 3)"
+{
+  return output_a_shift (operands);
+}
+  [(set (attr "length")
+	(symbol_ref "compute_a_shift_length (insn, operands)"))])
+
+(define_insn_and_split "*shifthi"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+	(match_operator:HI 3 "nshift_operator"
+	 [(match_operand:HI 1 "register_operand" "0,0")
+	  (match_operand:QI 2 "nonmemory_operand" "S,rn")]))
+   (clobber (match_scratch:QI 4 "=X,&r"))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_op_dup 3 [(match_dup 1) (match_dup 2)]))
+	      (clobber (match_dup 4))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "*shifthi_clobber_flags"
+  [(set (match_operand:HI 0 "register_operand" "=r,r")
+	(match_operator:HI 3 "nshift_operator"
+	 [(match_operand:HI 1 "register_operand" "0,0")
+	  (match_operand:QI 2 "nonmemory_operand" "S,rn")]))
+   (clobber (match_scratch:QI 4 "=X,&r"))
+   (clobber (reg:CC CC_REG))]
+  ""
+{
+  return output_a_shift (operands);
+}
+  [(set (attr "length")
+	(symbol_ref "compute_a_shift_length (insn, operands)"))])
+
+(define_insn "*shifthi_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operator:HI 3 "nshift_operator"
+	   [(match_operand:HI 1 "register_operand" "0,0")
+	    (match_operand:QI 2 "nonmemory_operand" "S,rn")])
+	  (const_int 0)))
+   (set (match_operand:HI 0 "register_operand" "=r,r")
+	(match_op_dup 3 [(match_dup 1) (match_dup 2)]))
+   (clobber (match_scratch:QI 4 "=X,&r"))]
+  "(compute_a_shift_cc (insn, operands) == 2
+    || compute_a_shift_cc (insn, operands) == 3)"
+{
+  return output_a_shift (operands);
+}
+  [(set (attr "length")
+	(symbol_ref "compute_a_shift_length (insn, operands)"))])
+
+(define_insn "*shiftsi"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(match_operator:SI 3 "nshift_operator"
+	 [(match_operand:SI 1 "register_operand" "0,0")
+	  (match_operand:QI 2 "nonmemory_operand" "T,rn")]))
+   (clobber (match_scratch:QI 4 "=X,&r"))]
+  ""
+  "#")
+
+(define_insn "*shiftsi_clobber_flags"
+  [(set (match_operand:SI 0 "register_operand" "=r,r")
+	(match_operator:SI 3 "nshift_operator"
+	 [(match_operand:SI 1 "register_operand" "0,0")
+	  (match_operand:QI 2 "nonmemory_operand" "T,rn")]))
+   (clobber (match_scratch:QI 4 "=X,&r"))
+   (clobber (reg:CC CC_REG))]
+  ""
+{
+  return output_a_shift (operands);
+}
+  [(set (attr "length")
+	(symbol_ref "compute_a_shift_length (insn, operands)"))])
+
+(define_insn "*shiftsi_set_flags"
+  [(set (reg:CCZN CC_REG)
+	(compare:CCZN
+	  (match_operator:SI 3 "nshift_operator"
+	   [(match_operand:SI 1 "register_operand" "0,0")
+	    (match_operand:QI 2 "nonmemory_operand" "T,rn")])
+	  (const_int 0)))
+   (set (match_operand:SI 0 "register_operand" "=r,r")
+	(match_op_dup 3 [(match_dup 1) (match_dup 2)]))
+   (clobber (match_scratch:QI 4 "=X,&r"))]
+  "(compute_a_shift_cc (insn, operands) == 2
+    || compute_a_shift_cc (insn, operands) == 3)"
+{
+  return output_a_shift (operands);
+}
+  [(set (attr "length")
+	(symbol_ref "compute_a_shift_length (insn, operands)"))])
+
+;; Split a variable shift into a loop.  If the register containing
+;; the shift count dies, then we just use that register.
+
+(define_split
+  [(set (match_operand 0 "register_operand" "")
+	(match_operator 2 "nshift_operator"
+	 [(match_dup 0)
+	  (match_operand:QI 1 "register_operand" "")]))
+   (clobber (match_operand:QI 3 "register_operand" ""))
+   (clobber (reg:CC CC_REG))]
+  "epilogue_completed
+   && find_regno_note (insn, REG_DEAD, REGNO (operands[1]))"
+  [(set (pc)
+        (if_then_else (le (match_dup 1) (const_int 0))
+		      (label_ref (match_dup 5))
+		      (pc)))
+   (match_dup 4)
+   (parallel
+     [(set (match_dup 0)
+	   (match_op_dup 2 [(match_dup 0) (const_int 1)]))
+      (clobber (scratch:QI))])
+   (set (match_dup 1) (plus:QI (match_dup 1) (const_int -1)))
+   (set (pc)
+        (if_then_else (ne (match_dup 1) (const_int 0))
+		      (label_ref (match_dup 4))
+		      (pc)))
+   (match_dup 5)]
+  {
+    operands[4] = gen_label_rtx ();
+    operands[5] = gen_label_rtx ();
+  })
+
+(define_split
+  [(set (match_operand 0 "register_operand" "")
+	(match_operator 2 "nshift_operator"
+	 [(match_dup 0)
+	  (match_operand:QI 1 "register_operand" "")]))
+   (clobber (match_operand:QI 3 "register_operand" ""))
+   (clobber (reg:CC CC_REG))]
+  "epilogue_completed
+   && !find_regno_note (insn, REG_DEAD, REGNO (operands[1]))"
+  [(set (match_dup 3)
+	(match_dup 1))
+   (set (pc)
+        (if_then_else (le (match_dup 3) (const_int 0))
+		      (label_ref (match_dup 5))
+		      (pc)))
+   (match_dup 4)
+   (parallel
+     [(set (match_dup 0)
+	   (match_op_dup 2 [(match_dup 0) (const_int 1)]))
+      (clobber (scratch:QI))])
+   (set (match_dup 3) (plus:QI (match_dup 3) (const_int -1)))
+   (set (pc)
+        (if_then_else (ne (match_dup 3) (const_int 0))
+		      (label_ref (match_dup 4))
+		      (pc)))
+   (match_dup 5)]
+  {
+    operands[4] = gen_label_rtx ();
+    operands[5] = gen_label_rtx ();
+  })
+
+(define_split
+  [(set (match_operand:SI 0 "register_operand")
+	(match_operator:SI 3 "nshift_operator"
+	 [(match_operand:SI 1 "register_operand")
+	  (match_operand:QI 2 "nonmemory_operand")]))
+   (clobber (match_scratch:QI 4))]
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (match_op_dup 3 [(match_dup 1) (match_dup 2)]))
+	      (clobber (match_dup 4))
+	      (clobber (reg:CC CC_REG))])])
+
+
+;; ----------------------------------------------------------------------
+;; ROTATIONS
+;; ----------------------------------------------------------------------
+
+(define_expand "rotl<mode>3"
+  [(set (match_operand:QHSI 0 "register_operand" "")
+	(rotate:QHSI (match_operand:QHSI 1 "register_operand" "")
+		     (match_operand:QI 2 "nonmemory_operand" "")))]
+  ""
+  {
+    if (expand_a_rotate (operands))
+    DONE;
+  })
+
+(define_insn_and_split "rotl<mode>3_1"
+  [(set (match_operand:QHSI 0 "register_operand" "=r")
+	(rotate:QHSI (match_operand:QHSI 1 "register_operand" "0")
+		     (match_operand:QI 2 "immediate_operand" "")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel [(set (match_dup 0) (rotate:QHSI (match_dup 1) (match_dup 2)))
+	      (clobber (reg:CC CC_REG))])])
+
+(define_insn "rotl<mode>3_1_clobber_flags"
+  [(set (match_operand:QHSI 0 "register_operand" "=r")
+	(rotate:QHSI (match_operand:QHSI 1 "register_operand" "0")
+		     (match_operand:QI 2 "immediate_operand" "")))
+   (clobber (reg:CC CC_REG))]
+  ""
+{
+  return output_a_rotate (ROTATE, operands);
+}
+  [(set (attr "length")
+	(symbol_ref "compute_a_rotate_length (operands)"))])
diff --git a/gcc/config/h8300/t-h8300 b/gcc/config/h8300/t-h8300
index ee34d819932..62d27000774 100644
--- a/gcc/config/h8300/t-h8300
+++ b/gcc/config/h8300/t-h8300
@@ -16,9 +16,8 @@
 # along with GCC; see the file COPYING3.  If not see
 # <http://www.gnu.org/licenses/>.
 
-MULTILIB_OPTIONS = mh/ms/msx mn mint32
-MULTILIB_DIRNAMES = h8300h h8300s h8sx normal int32
-MULTILIB_EXCEPTIONS = mint32 mn mn/mint32
+MULTILIB_OPTIONS = ms/msx mn mint32
+MULTILIB_DIRNAMES = h8300s h8sx normal int32
 
 s-config s-conditions s-flags s-codes s-constants s-emit s-recog \
 s-opinit s-extract s-peep s-attr s-attrtab s-output: \
diff --git a/gcc/config/h8300/testcompare.md b/gcc/config/h8300/testcompare.md
new file mode 100644
index 00000000000..61c876d799e
--- /dev/null
+++ b/gcc/config/h8300/testcompare.md
@@ -0,0 +1,192 @@
+;; ----------------------------------------------------------------------
+;; TEST INSTRUCTIONS
+;; ----------------------------------------------------------------------
+
+;;(define_insn_and_split "*tst_extzv_1_n"
+  ;;[(set (cc0)
+	;;(compare (zero_extract:SI (match_operand:QI 0 "general_operand_src" "r,U,mn>")
+				  ;;(const_int 1)
+				  ;;(match_operand 1 "const_int_operand" "n,n,n"))
+		 ;;(const_int 0)))
+   ;;(clobber (match_scratch:QI 2 "=X,X,&r"))]
+  ;;"0"
+  ;;"@
+   ;;btst\\t%Z1,%Y0
+   ;;btst\\t%Z1,%Y0
+   ;;#"
+  ;;"&& reload_completed
+   ;;&& !satisfies_constraint_U (operands[0])"
+  ;;[(set (match_dup 2)
+	;;(match_dup 0))
+   ;;(parallel [(set (cc0) (compare (zero_extract:SI (match_dup 2)
+						   ;;(const_int 1)
+						   ;;(match_dup 1))
+				  ;;(const_int 0)))
+	      ;;(clobber (scratch:QI))])]
+  ;;""
+  ;;[(set_attr "length" "2,8,10")
+   ;;(set_attr "cc" "set_zn,set_zn,set_zn")])
+;;
+;;(define_insn ""
+  ;;[(set (cc0)
+	;;(compare (zero_extract:HSI (match_operand:HSI 0 "register_operand" "r")
+				   ;;(const_int 1)
+				   ;;(match_operand 1 "const_int_operand" "n"))
+		 ;;(const_int 0)))]
+  ;;"0 && INTVAL (operands[1]) <= 15"
+  ;;"btst	%Z1,%Y0"
+  ;;[(set_attr "length" "2")
+   ;;(set_attr "cc" "set_zn")])
+;;
+;;(define_insn_and_split "*tstsi_upper_bit"
+  ;;[(set (cc0)
+	;;(compare (zero_extract:SI (match_operand:SI 0 "register_operand" "r")
+				  ;;(const_int 1)
+				  ;;(match_operand 1 "const_int_operand" "n"))
+		 ;;(const_int 0)))
+   ;;(clobber (match_scratch:SI 2 "=&r"))]
+  ;;"0 && INTVAL (operands[1]) >= 16"
+  ;;"#"
+  ;;"&& reload_completed"
+  ;;[(set (match_dup 2)
+	;;(ior:SI (and:SI (match_dup 2)
+			;;(const_int -65536))
+		;;(lshiftrt:SI (match_dup 0)
+			     ;;(const_int 16))))
+   ;;(set (cc0)
+	;;(compare (zero_extract:SI (match_dup 2)
+				  ;;(const_int 1)
+				  ;;(match_dup 3))
+		 ;;(const_int 0)))]
+  ;;{
+    ;;operands[3] = GEN_INT (INTVAL (operands[1]) - 16);
+  ;;})
+;;
+;;(define_insn "*tstsi_variable_bit"
+  ;;[(set (cc0)
+	;;(compare (zero_extract:SI (match_operand:SI 0 "register_operand" "r")
+				  ;;(const_int 1)
+				  ;;(and:SI (match_operand:SI 1 "register_operand" "r")
+					  ;;(const_int 7)))
+		 ;;(const_int 0)))]
+  ;;"0"
+  ;;"btst	%w1,%w0"
+  ;;[(set_attr "length" "2")
+   ;;(set_attr "cc" "set_zn")])
+;;
+;;(define_insn_and_split "*tstsi_variable_bit_qi"
+  ;;[(set (cc0)
+	;;(compare (zero_extract:SI (zero_extend:SI (match_operand:QI 0 "general_operand_src" "r,U,mn>"))
+				  ;;(const_int 1)
+				  ;;(and:SI (match_operand:SI 1 "register_operand" "r,r,r")
+					  ;;(const_int 7)))
+		 ;;(const_int 0)))
+   ;;(clobber (match_scratch:QI 2 "=X,X,&r"))]
+  ;;"0"
+  ;;"@
+   ;;btst\\t%w1,%X0
+   ;;btst\\t%w1,%X0
+   ;;#"
+  ;;"&& reload_completed
+   ;;&& !satisfies_constraint_U (operands[0])"
+  ;;[(set (match_dup 2)
+	;;(match_dup 0))
+   ;;(parallel [(set (cc0)
+		   ;;(compare (zero_extract:SI (zero_extend:SI (match_dup 2))
+					     ;;(const_int 1)
+					     ;;(and:SI (match_dup 1)
+						     ;;(const_int 7)))
+			    ;;(const_int 0)))
+	      ;;(clobber (scratch:QI))])]
+  ;;""
+  ;;[(set_attr "length" "2,8,10")
+   ;;(set_attr "cc" "set_zn,set_zn,set_zn")])
+
+(define_insn "*tst<mode>"
+  [(set (reg:CCZNV CC_REG)
+	(compare (match_operand:QHSI 0 "register_operand" "r")
+		 (const_int 0)))]
+  ""
+  {
+    if (<MODE>mode == QImode)
+      return "mov.b	%X0,%X0";
+    else if (<MODE>mode == HImode)
+      return "mov.w	%T0,%T0";
+    else if (<MODE>mode == SImode)
+      return "mov.w	%S0,%S0";
+    gcc_unreachable ();
+  }
+  [(set_attr "length" "2")
+   (set_attr "cc" "set_znv")])
+
+;;
+;;(define_insn "*tsthi_upper"
+  ;;[(set (cc0)
+	;;(compare (and:HI (match_operand:HI 0 "register_operand" "r")
+			 ;;(const_int -256))
+		 ;;(const_int 0)))]
+  ;;"0"
+  ;;"mov.b	%t0,%t0"
+  ;;[(set_attr "length" "2")
+   ;;(set_attr "cc" "set_znv")])
+
+;;(define_insn "*tstsi_upper"
+  ;;[(set (cc0)
+	;;(compare (and:SI (match_operand:SI 0 "register_operand" "r")
+			 ;;(const_int -65536))
+		 ;;(const_int 0)))]
+  ;;"0"
+  ;;"mov.w	%e0,%e0"
+  ;;;;[(set_attr "length" "2")
+   ;;(set_attr "cc" "set_znv")])
+
+(define_insn "*cmpqi"
+  [(set (reg:CC CC_REG)
+	(compare (match_operand:QI 0 "h8300_dst_operand" "rQ")
+		 (match_operand:QI 1 "h8300_src_operand" "rQi")))]
+  "reload_completed"
+  "cmp.b	%X1,%X0"
+  [(set_attr "length_table" "add")])
+
+(define_insn "*cmphi"
+  [(set (reg:CC CC_REG)
+	(compare (match_operand:HI 0 "h8300_dst_operand" "rU,rQ")
+		 (match_operand:HI 1 "h8300_src_operand" "P3>X,rQi")))]
+  "reload_completed"
+{
+  switch (which_alternative)
+    {
+    case 0:
+      if (!TARGET_H8300SX)
+	return "cmp.w	%T1,%T0";
+      else
+	return "cmp.w	%T1:3,%T0";
+    case 1:
+      return "cmp.w	%T1,%T0";
+    default:
+      gcc_unreachable ();
+      }
+}
+  [(set_attr "length_table" "short_immediate,add")])
+
+(define_insn "cmpsi"
+  [(set (reg:CC CC_REG)
+	(compare (match_operand:SI 0 "h8300_dst_operand" "r,rQ")
+		 (match_operand:SI 1 "h8300_src_operand" "P3>X,rQi")))]
+  "reload_completed"
+{
+  switch (which_alternative)
+    {
+    case 0:
+      if (!TARGET_H8300SX)
+	return "cmp.l	%S1,%S0";
+      else
+	return "cmp.l	%S1:3,%S0";
+    case 1:
+      return "cmp.l	%S1,%S0";
+    default:
+      gcc_unreachable ();
+    }
+}
+  [(set_attr "length" "2,*")
+   (set_attr "length_table" "*,add")])
