diff --git a/gcc/config/h8300/bitfield.md b/gcc/config/h8300/bitfield.md
index 8fa6fde433a..722c147fe4f 100644
--- a/gcc/config/h8300/bitfield.md
+++ b/gcc/config/h8300/bitfield.md
@@ -69,8 +69,7 @@
 {
   return output_simode_bld (0, operands);
 }
-  [(set_attr "cc" "set_znv,set_znv")
-   (set_attr "length" "8,6")])
+  [(set_attr "length" "8,6")])
 
 ;;
 ;; Inverted loads with a 32bit destination.
@@ -104,8 +103,7 @@
 {
   return output_simode_bld (1, operands);
 }
-  [(set_attr "cc" "set_znv,set_znv")
-   (set_attr "length" "8,6")])
+  [(set_attr "length" "8,6")])
 
 (define_expand "insv"
   [(set (zero_extract:HI (match_operand:HI 0 "general_operand" "")
@@ -312,8 +310,7 @@
 			 - (1 << INTVAL (operands[3])));
   return "bfld	%2,%1,%R0";
 }
-  [(set_attr "cc" "none_0hit")
-   (set_attr "length_table" "bitfield")])
+  [(set_attr "length_table" "bitfield")])
 
 (define_insn_and_split "bfst"
   [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU")
@@ -339,8 +336,7 @@
 			 - (1 << INTVAL (operands[3])));
   return "bfst	%R1,%2,%0";
 }
-  [(set_attr "cc" "none_0hit")
-   (set_attr "length_table" "bitfield")])
+  [(set_attr "length_table" "bitfield")])
 
 ;;(define_expand "cstore<mode>4"
 ;;  [(use (match_operator 1 "eqne_operator"
@@ -357,8 +353,7 @@
 ;;  [(set (match_operand:HI 0 "register_operand" "=r")
 ;;	(match_operator:HI 1 "eqne_operator" [(cc0) (const_int 0)]))]
 ;;  "TARGET_H8300SX"
-;;  "mulu.w	#0,%T0\;b%k1	.Lh8BR%=\;inc.w	#1,%T0\\n.Lh8BR%=:"
-;;  [(set_attr "cc" "clobber")])
+;;  "mulu.w	#0,%T0\;b%k1	.Lh8BR%=\;inc.w	#1,%T0\\n.Lh8BR%=:")
 
 ;;(define_insn_and_split "*cmpstz"
 ;;  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU,WU")
@@ -379,8 +374,7 @@
 ;;	(match_op_dup:QI 2 [(cc0) (const_int 0)]))]
 ;;  {
 ;;    operands[5] = gen_rtx_COMPARE (VOIDmode, operands[3], operands[4]);
-;;  }
-;;  [(set_attr "cc" "set_znv,compare")])
+;;  })
 
 ;;(define_insn "*bstz"
 ;;  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU")
@@ -389,8 +383,7 @@
 ;;	(eq:QI (cc0) (const_int 0)))]
 ;;  "TARGET_H8300SX && reload_completed"
 ;;  "bstz	%1,%0"
-;;  [(set_attr "cc" "none_0hit")
-;;   (set_attr "length_table" "unary")])
+;;  [(set_attr "length_table" "unary")])
 
 ;;(define_insn "*bistz"
 ;;  [(set (zero_extract:QI (match_operand:QI 0 "bit_memory_operand" "+WU")
@@ -399,8 +392,7 @@
 ;;	(ne:QI (cc0) (const_int 0)))]
 ;;  "TARGET_H8300SX && reload_completed"
 ;;  "bistz	%1,%0"
-;;  [(set_attr "cc" "none_0hit")
-;;   (set_attr "length_table" "unary")])
+;;  [(set_attr "length_table" "unary")])
 
 ;;(define_insn_and_split "*cmpcondbset"
 ;;  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
@@ -420,8 +412,7 @@
 ;;			 (match_dup 4)))]
 ;;  {
 ;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
-;;  }
-;; [(set_attr "cc" "set_znv,compare")])
+;;  })
 
 ;;(define_insn "*condbset"
 ;;  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
@@ -432,8 +423,7 @@
 ;;			 (match_dup 3)))]
 ;;  "TARGET_H8300SX && reload_completed"
 ;;  "bset/%j2\t%V1,%0"
-;;  [(set_attr "cc" "none_0hit")
-;;   (set_attr "length_table" "logicb")])
+;;  [(set_attr "length_table" "logicb")])
 
 ;;(define_insn_and_split "*cmpcondbclr"
 ;;  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
@@ -453,8 +443,7 @@
 ;;			 (match_dup 4)))]
 ;;  {
 ;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
-;;  }
-;;  [(set_attr "cc" "set_znv,compare")])
+;;  })
 
 ;;(define_insn "*condbclr"
 ;;  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
@@ -465,8 +454,7 @@
 ;;			 (match_dup 3)))]
 ;;  "TARGET_H8300SX && reload_completed"
 ;;  "bclr/%j2\t%W1,%0"
-;;  [(set_attr "cc" "none_0hit")
-;;   (set_attr "length_table" "logicb")])
+;;  [(set_attr "length_table" "logicb")])
 
 ;;(define_insn_and_split "*cmpcondbsetreg"
 ;;  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
@@ -489,8 +477,7 @@
 ;;			 (match_dup 4)))]
 ;;  {
 ;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
-;;  }
-;;  [(set_attr "cc" "set_znv,compare")])
+;;  })
 
 ;;(define_insn "*condbsetreg"
 ;;  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
@@ -502,8 +489,7 @@
 ;;			 (match_dup 3)))]
 ;;  "TARGET_H8300SX && reload_completed"
 ;;  "bset/%j2\t%R1,%0"
-;;  [(set_attr "cc" "none_0hit")
-;;   (set_attr "length_table" "logicb")])
+;;  [(set_attr "length_table" "logicb")])
 
 ;;(define_insn_and_split "*cmpcondbclrreg"
 ;;  [(set (match_operand:QI 0 "nonimmediate_operand" "=WU,WU")
@@ -526,8 +512,7 @@
 ;;			 (match_dup 4)))]
 ;;  {
 ;;    operands[6] = gen_rtx_COMPARE (VOIDmode, operands[2], operands[3]);
-;;  }
-;;  [(set_attr "cc" "set_znv,compare")])
+;;  })
 
 ;;(define_insn "*condbclrreg"
 ;;  [(set (match_operand:QI 0 "bit_memory_operand" "=WU")
@@ -539,6 +524,5 @@
 ;;			 (match_dup 3)))]
 ;;  "TARGET_H8300SX && reload_completed"
 ;;  "bclr/%j2\t%R1,%0"
-;;  [(set_attr "cc" "none_0hit")
-;;   (set_attr "length_table" "logicb")])
+;;  [(set_attr "length_table" "logicb")])
 
diff --git a/gcc/config/h8300/combiner.md b/gcc/config/h8300/combiner.md
index 432c1d88a61..20e19da0419 100644
--- a/gcc/config/h8300/combiner.md
+++ b/gcc/config/h8300/combiner.md
@@ -144,8 +144,7 @@
   "@
    mov.b\\t%x1,%w0\;extu.w\\t%f0\;extu.l\\t%S0
    sub.l\\t%S0,%S0\;mov.b\\t%x1,%w0"
-  [(set_attr "cc" "set_znv,clobber")
-   (set_attr "length" "6,4")])
+  [(set_attr "length" "6,4")])
 
 (define_insn_and_split "*extzv_8_16"
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -167,8 +166,7 @@
    (clobber (reg:CC CC_REG))]
   ""
   "mov.w\\t%e1,%f0\;extu.w\\t%f0\;extu.l\\t%S0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length" "6")])
+  [(set_attr "length" "6")])
 
 (define_insn_and_split "*extzv_16_8"
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -192,8 +190,7 @@
    (clobber (reg:CC CC_REG))]
   "TARGET_H8300H"
   "mov.w\\t%e1,%f2\;mov.b\\t%x1,%w0\;mov.b\\t%w2,%x0\;extu.l\\t%S0"
-  [(set_attr "length" "8")
-   (set_attr "cc" "set_znv")])
+  [(set_attr "length" "8")])
 
 ;; Extract the exponent of a float.
 
@@ -775,8 +772,7 @@
    (clobber (reg:CC CC_REG))]
   ""
   "rotxl.l\\t%S0\;bor\\t#0,%w1\;rotxr.l\\t%S0"
-  [(set_attr "length" "6")
-   (set_attr "cc" "set_znv")])
+  [(set_attr "length" "6")])
 
 (define_insn_and_split "*iorsi3_and_ashift"
   [(set (match_operand:SI 0 "register_operand" "=r")
@@ -1163,8 +1159,7 @@
    (clobber (reg:CC CC_REG))]
   ""
   "mov.b\\t%t1,%R0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length" "8")])
+  [(set_attr "length" "8")])
 
 ;; Storing a part of SImode to QImode.
 
@@ -1186,8 +1181,7 @@
    (clobber (reg:CC CC_REG))]
   ""
   "mov.b\\t%x1,%R0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length" "8")])
+  [(set_attr "length" "8")])
 
 (define_insn_and_split ""
   [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
@@ -1210,8 +1204,7 @@
    (clobber (reg:CC CC_REG))]
   ""
   "mov.w\\t%e1,%f2\;mov.b\\t%w2,%R0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length" "10")])
+  [(set_attr "length" "10")])
 
 (define_insn_and_split ""
   [(set (match_operand:QI 0 "general_operand_dst" "=rm<")
@@ -1234,8 +1227,7 @@
    (clobber (reg:CC CC_REG))]
   ""
   "mov.w\\t%e1,%f2\;mov.b\\t%x2,%R0"
-  [(set_attr "cc" "set_znv")
-   (set_attr "length" "10")])
+  [(set_attr "length" "10")])
 
 ;;(define_insn_and_split ""
 ;;  [(set (pc)
diff --git a/gcc/config/h8300/h8300.c b/gcc/config/h8300/h8300.c
index 09e9cbfb838..31e23b238cc 100644
--- a/gcc/config/h8300/h8300.c
+++ b/gcc/config/h8300/h8300.c
@@ -1956,74 +1956,6 @@ h8300_select_cc_mode (enum rtx_code cond, rtx op0, rtx op1)
   return CCmode;
 }
 
-#if 0
-/* Update the condition code from the insn.  */
-
-void
-notice_update_cc (rtx body, rtx_insn *insn)
-{
-  rtx set;
-
-  switch (get_attr_cc (insn))
-    {
-    case CC_NONE:
-      /* Insn does not affect CC at all.  */
-      break;
-
-    case CC_NONE_0HIT:
-      /* Insn does not change CC, but the 0'th operand has been changed.  */
-      if (cc_status.value1 != 0
-	  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))
-	cc_status.value1 = 0;
-      if (cc_status.value2 != 0
-	  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value2))
-	cc_status.value2 = 0;
-      break;
-
-    case CC_SET_ZN:
-      /* Insn sets the Z,N flags of CC to recog_data.operand[0].
-	 The V flag is unusable.  The C flag may or may not be known but
-	 that's ok because alter_cond will change tests to use EQ/NE.  */
-      CC_STATUS_INIT;
-      cc_status.flags |= CC_OVERFLOW_UNUSABLE | CC_NO_CARRY;
-      set = single_set (insn);
-      cc_status.value1 = SET_SRC (set);
-      if (SET_DEST (set) != cc0_rtx)
-	cc_status.value2 = SET_DEST (set);
-      break;
-
-    case CC_SET_ZNV:
-      /* Insn sets the Z,N,V flags of CC to recog_data.operand[0].
-	 The C flag may or may not be known but that's ok because
-	 alter_cond will change tests to use EQ/NE.  */
-      CC_STATUS_INIT;
-      cc_status.flags |= CC_NO_CARRY;
-      set = single_set (insn);
-      cc_status.value1 = SET_SRC (set);
-      if (SET_DEST (set) != cc0_rtx)
-	{
-	  /* If the destination is STRICT_LOW_PART, strip off
-	     STRICT_LOW_PART.  */
-	  if (GET_CODE (SET_DEST (set)) == STRICT_LOW_PART)
-	    cc_status.value2 = XEXP (SET_DEST (set), 0);
-	  else
-	    cc_status.value2 = SET_DEST (set);
-	}
-      break;
-
-    case CC_COMPARE:
-      /* The insn is a compare instruction.  */
-      CC_STATUS_INIT;
-      cc_status.value1 = SET_SRC (body);
-      break;
-
-    case CC_CLOBBER:
-      /* Insn doesn't leave CC in a usable state.  */
-      CC_STATUS_INIT;
-      break;
-    }
-}
-#endif
 
 /* Given that X occurs in an address of the form (plus X constant),
    return the part of X that is expected to be a register.  There are
@@ -2882,7 +2814,7 @@ compute_plussi_length (rtx *operands, bool need_flags)
 
 /* Compute which flag bits are valid after an addition insn.  */
 
-enum attr_cc
+enum attr_old_cc
 compute_plussi_cc (rtx *operands)
 {
   machine_mode mode = GET_MODE (operands[0]);
@@ -2895,9 +2827,9 @@ compute_plussi_cc (rtx *operands)
       HOST_WIDE_INT intval = INTVAL (operands[2]);
 
       if (TARGET_H8300SX && (intval >= 1 && intval <= 7))
-	return CC_SET_ZN;
+	return OLD_CC_SET_ZN;
       if (TARGET_H8300SX && (intval >= -7 && intval <= -1))
-	return CC_SET_ZN;
+	return OLD_CC_SET_ZN;
 
       /* See if we can finish with 2 bytes.  */
 
@@ -2906,28 +2838,28 @@ compute_plussi_cc (rtx *operands)
 	case 0x00000001:
 	case 0x00000002:
 	case 0x00000004:
-	  return CC_NONE_0HIT;
+	  return OLD_CC_NONE_0HIT;
 
 	case 0xffffffff:
 	case 0xfffffffe:
 	case 0xfffffffc:
-	  return CC_NONE_0HIT;
+	  return OLD_CC_NONE_0HIT;
 
 	case 0x00010000:
 	case 0x00020000:
-	  return CC_CLOBBER;
+	  return OLD_CC_CLOBBER;
 
 	case 0xffff0000:
 	case 0xfffe0000:
-	  return CC_CLOBBER;
+	  return OLD_CC_CLOBBER;
 	}
 
       /* See if we can finish with 4 bytes.  */
       if ((intval & 0xffff) == 0)
-	return CC_CLOBBER;
+	return OLD_CC_CLOBBER;
     }
 
-  return CC_SET_ZN;
+  return OLD_CC_SET_ZN;
 }
 
 /* Output a logical insn.  */
@@ -3234,7 +3166,7 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)
   int lower_half_easy_p = 0;
   int upper_half_easy_p = 0;
   /* Condition code.  */
-  enum attr_cc cc = CC_CLOBBER;
+  enum attr_old_cc cc = OLD_CC_CLOBBER;
 
   switch (mode)
     {
@@ -3242,7 +3174,7 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)
       /* First, see if we can finish with one insn.  */
       if (b0 != 0 && b1 != 0)
 	{
-	  cc = CC_SET_ZNV;
+	  cc = OLD_CC_SET_ZNV;
 	}
       break;
     case E_SImode:
@@ -3264,7 +3196,7 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)
 	  && !(code == IOR && w1 == 0xffff
 	       && (w0 & 0x8000) != 0 && lower_half_easy_p))
 	{
-	  cc = CC_SET_ZNV;
+	  cc = OLD_CC_SET_ZNV;
 	}
       else
 	{
@@ -3272,7 +3204,7 @@ compute_logical_op_cc (machine_mode mode, rtx *operands)
 	      && w1 == 0xffff
 	      && (w0 & 0x8000) != 0)
 	    {
-	      cc = CC_SET_ZNV;
+	      cc = OLD_CC_SET_ZNV;
 	    }
 	}
       break;
@@ -3500,13 +3432,13 @@ enum shift_mode
 };
 
 /* For single bit shift insns, record assembler and what bits of the
-   condition code are valid afterwards (represented as various CC_FOO
+   condition code are valid afterwards (represented as various OLD_CC_FOO
    bits, 0 means CC isn't left in a usable state).  */
 
 struct shift_insn
 {
   const char *const assembler;
-  const enum attr_cc cc_valid;
+  const enum attr_old_cc cc_valid;
 };
 
 /* Assembler instruction shift table.
@@ -3520,42 +3452,42 @@ static const struct shift_insn shift_one[2][3][3] =
   {
 /* SHIFT_ASHIFT */
     {
-      { "shll\t%X0", CC_SET_ZNV },
-      { "add.w\t%T0,%T0", CC_SET_ZN },
-      { "add.w\t%f0,%f0\n\taddx\t%y0,%y0\n\taddx\t%z0,%z0", CC_CLOBBER }
+      { "shll\t%X0", OLD_CC_SET_ZNV },
+      { "add.w\t%T0,%T0", OLD_CC_SET_ZN },
+      { "add.w\t%f0,%f0\n\taddx\t%y0,%y0\n\taddx\t%z0,%z0", OLD_CC_CLOBBER }
     },
 /* SHIFT_LSHIFTRT */
     {
-      { "shlr\t%X0", CC_SET_ZNV },
-      { "shlr\t%t0\n\trotxr\t%s0", CC_CLOBBER },
-      { "shlr\t%z0\n\trotxr\t%y0\n\trotxr\t%x0\n\trotxr\t%w0", CC_CLOBBER }
+      { "shlr\t%X0", OLD_CC_SET_ZNV },
+      { "shlr\t%t0\n\trotxr\t%s0", OLD_CC_CLOBBER },
+      { "shlr\t%z0\n\trotxr\t%y0\n\trotxr\t%x0\n\trotxr\t%w0", OLD_CC_CLOBBER }
     },
 /* SHIFT_ASHIFTRT */
     {
-      { "shar\t%X0", CC_SET_ZNV },
-      { "shar\t%t0\n\trotxr\t%s0", CC_CLOBBER },
-      { "shar\t%z0\n\trotxr\t%y0\n\trotxr\t%x0\n\trotxr\t%w0", CC_CLOBBER }
+      { "shar\t%X0", OLD_CC_SET_ZNV },
+      { "shar\t%t0\n\trotxr\t%s0", OLD_CC_CLOBBER },
+      { "shar\t%z0\n\trotxr\t%y0\n\trotxr\t%x0\n\trotxr\t%w0", OLD_CC_CLOBBER }
     }
   },
 /* H8/300H */
   {
 /* SHIFT_ASHIFT */
     {
-      { "shll.b\t%X0", CC_SET_ZNV },
-      { "shll.w\t%T0", CC_SET_ZNV },
-      { "shll.l\t%S0", CC_SET_ZNV }
+      { "shll.b\t%X0", OLD_CC_SET_ZNV },
+      { "shll.w\t%T0", OLD_CC_SET_ZNV },
+      { "shll.l\t%S0", OLD_CC_SET_ZNV }
     },
 /* SHIFT_LSHIFTRT */
     {
-      { "shlr.b\t%X0", CC_SET_ZNV },
-      { "shlr.w\t%T0", CC_SET_ZNV },
-      { "shlr.l\t%S0", CC_SET_ZNV }
+      { "shlr.b\t%X0", OLD_CC_SET_ZNV },
+      { "shlr.w\t%T0", OLD_CC_SET_ZNV },
+      { "shlr.l\t%S0", OLD_CC_SET_ZNV }
     },
 /* SHIFT_ASHIFTRT */
     {
-      { "shar.b\t%X0", CC_SET_ZNV },
-      { "shar.w\t%T0", CC_SET_ZNV },
-      { "shar.l\t%S0", CC_SET_ZNV }
+      { "shar.b\t%X0", OLD_CC_SET_ZNV },
+      { "shar.w\t%T0", OLD_CC_SET_ZNV },
+      { "shar.l\t%S0", OLD_CC_SET_ZNV }
     }
   }
 };
@@ -3564,21 +3496,21 @@ static const struct shift_insn shift_two[3][3] =
 {
 /* SHIFT_ASHIFT */
     {
-      { "shll.b\t#2,%X0", CC_SET_ZNV },
-      { "shll.w\t#2,%T0", CC_SET_ZNV },
-      { "shll.l\t#2,%S0", CC_SET_ZNV }
+      { "shll.b\t#2,%X0", OLD_CC_SET_ZNV },
+      { "shll.w\t#2,%T0", OLD_CC_SET_ZNV },
+      { "shll.l\t#2,%S0", OLD_CC_SET_ZNV }
     },
 /* SHIFT_LSHIFTRT */
     {
-      { "shlr.b\t#2,%X0", CC_SET_ZNV },
-      { "shlr.w\t#2,%T0", CC_SET_ZNV },
-      { "shlr.l\t#2,%S0", CC_SET_ZNV }
+      { "shlr.b\t#2,%X0", OLD_CC_SET_ZNV },
+      { "shlr.w\t#2,%T0", OLD_CC_SET_ZNV },
+      { "shlr.l\t#2,%S0", OLD_CC_SET_ZNV }
     },
 /* SHIFT_ASHIFTRT */
     {
-      { "shar.b\t#2,%X0", CC_SET_ZNV },
-      { "shar.w\t#2,%T0", CC_SET_ZNV },
-      { "shar.l\t#2,%S0", CC_SET_ZNV }
+      { "shar.b\t#2,%X0", OLD_CC_SET_ZNV },
+      { "shar.w\t#2,%T0", OLD_CC_SET_ZNV },
+      { "shar.l\t#2,%S0", OLD_CC_SET_ZNV }
     }
 };
 
@@ -3674,10 +3606,10 @@ struct shift_info {
   const char *shift2;
 
   /* CC status for SHIFT_INLINE.  */
-  enum attr_cc cc_inline;
+  enum attr_old_cc cc_inline;
 
   /* CC status  for SHIFT_SPECIAL.  */
-  enum attr_cc cc_special;
+  enum attr_old_cc cc_special;
 };
 
 static void get_shift_alg (enum shift_type,
@@ -3746,7 +3678,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
     case SHIFT_ROT_AND:
       info->shift1 = rotate_one[cpu_type][shift_type][shift_mode];
       info->shift2 = rotate_two[shift_type][shift_mode];
-      info->cc_inline = CC_CLOBBER;
+      info->cc_inline = OLD_CC_CLOBBER;
       goto end;
 
     case SHIFT_SPECIAL:
@@ -3755,7 +3687,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
       info->shift1 = shift_one[cpu_type][shift_type][shift_mode].assembler;
       info->shift2 = shift_two[shift_type][shift_mode].assembler;
       info->cc_inline = shift_one[cpu_type][shift_type][shift_mode].cc_valid;
-      info->cc_special = CC_CLOBBER;
+      info->cc_special = OLD_CC_CLOBBER;
       break;
     }
 
@@ -3797,11 +3729,11 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      goto end;
 	    case SHIFT_LSHIFTRT:
 	      info->special = "mov.b\t%t0,%s0\n\textu.w\t%T0";
-	      info->cc_special = CC_SET_ZNV;
+	      info->cc_special = OLD_CC_SET_ZNV;
 	      goto end;
 	    case SHIFT_ASHIFTRT:
 	      info->special = "mov.b\t%t0,%s0\n\texts.w\t%T0";
-	      info->cc_special = CC_SET_ZNV;
+	      info->cc_special = OLD_CC_SET_ZNV;
 	      goto end;
 	    }
 	}
@@ -3817,7 +3749,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      if (TARGET_H8300H)
 		{
 		  info->special = "shll.b\t%t0\n\tsubx.b\t%s0,%s0\n\tshll.b\t%t0\n\trotxl.b\t%s0\n\texts.w\t%T0";
-		  info->cc_special = CC_SET_ZNV;
+		  info->cc_special = OLD_CC_SET_ZNV;
 		}
 	      else /* TARGET_H8300S */
 		gcc_unreachable ();
@@ -3863,11 +3795,11 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	    {
 	    case SHIFT_ASHIFT:
 	      info->special = "shlr.w\t%e0\n\tmov.w\t%f0,%e0\n\txor.w\t%f0,%f0\n\trotxr.l\t%S0";
-	      info->cc_special = CC_SET_ZNV;
+	      info->cc_special = OLD_CC_SET_ZNV;
 	      goto end;
 	    case SHIFT_LSHIFTRT:
 	      info->special = "shll.w\t%f0\n\tmov.w\t%e0,%f0\n\txor.w\t%e0,%e0\n\trotxl.l\t%S0";
-	      info->cc_special = CC_SET_ZNV;
+	      info->cc_special = OLD_CC_SET_ZNV;
 	      goto end;
 	    case SHIFT_ASHIFTRT:
 	      gcc_unreachable ();
@@ -3885,11 +3817,11 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      goto end;
 	    case SHIFT_LSHIFTRT:
 	      info->special = "mov.w\t%e0,%f0\n\textu.l\t%S0";
-	      info->cc_special = CC_SET_ZNV;
+	      info->cc_special = OLD_CC_SET_ZNV;
 	      goto end;
 	    case SHIFT_ASHIFTRT:
 	      info->special = "mov.w\t%e0,%f0\n\texts.l\t%S0";
-	      info->cc_special = CC_SET_ZNV;
+	      info->cc_special = OLD_CC_SET_ZNV;
 	      goto end;
 	    }
 	}
@@ -3905,11 +3837,11 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      goto end;
 	    case SHIFT_LSHIFTRT:
 	      info->special = "mov.w\t%e0,%f0\n\tmov.b\t%t0,%s0\n\textu.w\t%f0\n\textu.l\t%S0";
-	      info->cc_special = CC_SET_ZNV;
+	      info->cc_special = OLD_CC_SET_ZNV;
 	      goto end;
 	    case SHIFT_ASHIFTRT:
 	      info->special = "mov.w\t%e0,%f0\n\tmov.b\t%t0,%s0\n\texts.w\t%f0\n\texts.l\t%S0";
-	      info->cc_special = CC_SET_ZNV;
+	      info->cc_special = OLD_CC_SET_ZNV;
 	      goto end;
 	    }
 	}
@@ -3927,7 +3859,7 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      if (TARGET_H8300H)
 		{
 		  info->special = "sub.w\t%f0,%f0\n\trotl.l\t%S0\n\trotl.l\t%S0\n\trotl.l\t%S0\n\trotl.l\t%S0\n\textu.l\t%S0";
-		  info->cc_special = CC_SET_ZNV;
+		  info->cc_special = OLD_CC_SET_ZNV;
 		}
 	      else
 		info->special = "sub.w\t%f0,%f0\n\trotl.l\t#2,%S0\n\trotl.l\t#2,%S0\n\textu.l\t%S0";
@@ -3950,12 +3882,12 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	      if (TARGET_H8300H)
 		{
 		  info->special = "sub.w\t%f0,%f0\n\trotl.l\t%S0\n\trotl.l\t%S0\n\trotl.l\t%S0\n\textu.l\t%S0";
-		  info->cc_special = CC_SET_ZNV;
+		  info->cc_special = OLD_CC_SET_ZNV;
 		}
 	      else
 		{
 		  info->special = "sub.w\t%f0,%f0\n\trotl.l\t#2,%S0\n\trotl.l\t%S0\n\textu.l\t%S0";
-		  info->cc_special = CC_SET_ZNV;
+		  info->cc_special = OLD_CC_SET_ZNV;
 		}
 	      goto end;
 	    case SHIFT_ASHIFTRT:
@@ -3988,15 +3920,15 @@ get_shift_alg (enum shift_type shift_type, enum shift_mode shift_mode,
 	    {
 	    case SHIFT_ASHIFT:
 	      info->special = "shlr.l\t%S0\n\txor.l\t%S0,%S0\n\trotxr.l\t%S0";
-	      info->cc_special = CC_SET_ZNV;
+	      info->cc_special = OLD_CC_SET_ZNV;
 	      goto end;
 	    case SHIFT_LSHIFTRT:
 	      info->special = "shll.l\t%S0\n\txor.l\t%S0,%S0\n\trotxl.l\t%S0";
-	      info->cc_special = CC_SET_ZNV;
+	      info->cc_special = OLD_CC_SET_ZNV;
 	      goto end;
 	    case SHIFT_ASHIFTRT:
 	      info->special = "shll\t%e0\n\tsubx\t%w0,%w0\n\texts.w\t%T0\n\texts.l\t%S0";
-	      info->cc_special = CC_SET_ZNV;
+	      info->cc_special = OLD_CC_SET_ZNV;
 	      goto end;
 	    }
 	}
@@ -4459,7 +4391,7 @@ compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)
       
     case SHIFT_ROT_AND:
       /* This case always ends with an and instruction.  */
-      return CC_SET_ZNV;
+      return OLD_CC_SET_ZNV;
       
     case SHIFT_LOOP:
       /* A loop to shift by a "large" constant value.
@@ -4469,7 +4401,7 @@ compute_a_shift_cc (rtx insn ATTRIBUTE_UNUSED, rtx *operands)
 	  if (n % 2)
 	    return info.cc_inline;
 	}
-      return CC_CLOBBER;
+      return OLD_CC_CLOBBER;
       
     default:
       gcc_unreachable ();
diff --git a/gcc/config/h8300/h8300.md b/gcc/config/h8300/h8300.md
index 7ed2453f433..7c9cc324f39 100644
--- a/gcc/config/h8300/h8300.md
+++ b/gcc/config/h8300/h8300.md
@@ -131,7 +131,7 @@
 ;; compare - compare instruction
 ;; clobber - value of cc is unknown
 
-(define_attr "cc" "none,none_0hit,set_znv,set_zn,compare,clobber"
+(define_attr "old_cc" "none,none_0hit,set_znv,set_zn,compare,clobber"
   (const_string "clobber"))
 
 ;; Type of delay slot.  NONE means the instruction has no delay slot.
diff --git a/gcc/config/h8300/jumpcall.md b/gcc/config/h8300/jumpcall.md
index 6c72724b669..c07dbaf999c 100644
--- a/gcc/config/h8300/jumpcall.md
+++ b/gcc/config/h8300/jumpcall.md
@@ -46,8 +46,7 @@
   else
     return "b%k1	.Lh8BR%=\;jmp	@%l0\\n.Lh8BR%=:";
 }
- [(set_attr "type" "branch")
-   (set_attr "cc" "none")])
+ [(set_attr "type" "branch")])
 
 
 (define_insn "*branch_1_false"
@@ -65,8 +64,7 @@
   else
     return "b%j1	.Lh8BR%=\;jmp	@%l0\\n.Lh8BR%=:";
 }
- [(set_attr "type" "branch")
-   (set_attr "cc" "none")])
+ [(set_attr "type" "branch")])
 
 ;; The brabc/brabs patterns have been disabled because their length computation
 ;; is horribly broken.  When we call out to a function via a SYMBOL_REF we get
@@ -168,8 +166,7 @@
    (set (attr "delay_slot")
 	(if_then_else (match_test "TARGET_H8300SX")
 		      (const_string "jump")
-		      (const_string "none")))
-   (set_attr "cc" "none")])
+		      (const_string "none")))])
 
 ;; This is a define expand, because pointers may be either 16 or 32 bits.
 
@@ -190,8 +187,7 @@
       return "jmp	@%S0";
     abort ();
   }
-  [(set_attr "cc" "none")
-   (set_attr "length" "2")])
+  [(set_attr "length" "2")])
 
 ;; This is a define expand, because pointers may be either 16 or 32 bits.
 
@@ -210,8 +206,7 @@
       return "jmp	@%S0";
     abort ();
   }
-  [(set_attr "cc" "none")
-   (set_attr "length" "2")])
+  [(set_attr "length" "2")])
 
 ;; Call subroutine with no return value.
 
diff --git a/gcc/config/h8300/logical.md b/gcc/config/h8300/logical.md
index e4d3d330b6e..eb99c20b55d 100644
--- a/gcc/config/h8300/logical.md
+++ b/gcc/config/h8300/logical.md
@@ -278,8 +278,7 @@
       return "not.l	%S0";
     gcc_unreachable ();
   }
-  [(set_attr "length_table" "unary")
-   (set_attr "cc" "set_znv")])
+  [(set_attr "length_table" "unary")])
 
 ;; The next four peephole2's will try to transform
 ;;
diff --git a/gcc/config/h8300/save.md b/gcc/config/h8300/save.md
deleted file mode 100644
index a05119f33ac..00000000000
--- a/gcc/config/h8300/save.md
+++ /dev/null
@@ -1,403 +0,0 @@
-;; ----------------------------------------------------------------------
-;; MULTIPLY INSTRUCTIONS
-;; ----------------------------------------------------------------------
-
-;; Note that the H8/300 can only handle umulqihi3.
-
-(define_expand "mulqihi3"
-  [(set (match_operand:HI 0 "register_operand" "")
-	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" ""))
-		 ;; intentionally-mismatched modes
-		 (match_operand:QI 2 "reg_or_nibble_operand" "")))]
-  ""
-  {
-    if (GET_MODE (operands[2]) != VOIDmode)
-      operands[2] = gen_rtx_SIGN_EXTEND (HImode, operands[2]);
-  })
-
-(define_insn_and_split "*mulqihi3_const"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (match_operand:QI 2 "nibble_operand" "IP4>X")))]
-  "TARGET_H8300SX"
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (mult:HI (sign_extend:HI (match_dup 1)) (match_dup 2)))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn "*mulqihi3_const_clobber_flags"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (match_operand:QI 2 "nibble_operand" "IP4>X")))
-   (clobber (reg:CC CC_REG))]
-  "TARGET_H8300SX"
-  "mulxs.b	%X2,%T0"
-  [(set_attr "length" "4")])
-
-(define_insn "*mulqihi3_const_set_flags"
-  [(set (reg:CCZN CC_REG)
-	(compare:CCZN
-	  (mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		   (match_operand:QI 2 "nibble_operand" "IP4>X"))
-	  (const_int 0)))
-   (set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (sign_extend:HI (match_dup 1)) (match_dup 2)))]
-  "TARGET_H8300SX"
-  "mulxs.b	%X2,%T0"
-  [(set_attr "length" "4")])
-
-(define_insn_and_split "*mulqihi3"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (sign_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
-  ""
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (mult:HI (sign_extend:HI (match_dup 1))
-			    (sign_extend:HI (match_dup 2))))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn "*mulqihi3_clobber_flags"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (sign_extend:HI (match_operand:QI 2 "register_operand" "r"))))
-   (clobber (reg:CC CC_REG))]
-  ""
-  "mulxs.b	%X2,%T0"
-  [(set_attr "length" "4")])
-
-(define_insn "*mulqihi3_set_flags"
-  [(set (reg:CCZN CC_REG)
-	(compare:CCZN
-	  (mult:HI
-	    (sign_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-	    (sign_extend:HI (match_operand:QI 2 "register_operand" "r")))
-	  (const_int 0)))
-   (set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (sign_extend:HI (match_dup 1)) (sign_extend (match_dup 2))))]
-  ""
-  "mulxs.b	%X2,%T0"
-  [(set_attr "length" "4")])
-
-(define_expand "mulhisi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" ""))
-		 ;; intentionally-mismatched modes
-		 (match_operand:HI 2 "reg_or_nibble_operand" "")))]
-  ""
-  {
-    if (GET_MODE (operands[2]) != VOIDmode)
-      operands[2] = gen_rtx_SIGN_EXTEND (SImode, operands[2]);
-  })
-
-(define_insn_and_split "*mulhisi3_const"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (match_operand:SI 2 "nibble_operand" "IP4>X")))]
-  "TARGET_H8300SX"
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (mult:SI (sign_extend:SI (match_dup 1)) (match_dup 2)))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn "*mulhisi3_const_clobber_flags"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (match_operand:SI 2 "nibble_operand" "IP4>X")))
-   (clobber (reg:CC CC_REG))]
-  "TARGET_H8300SX"
-  "mulxs.w	%T2,%S0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_insn_and_split "*mulhisi3"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (sign_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
-  ""
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (mult:SI (sign_extend:SI (match_dup 1))
-			    (sign_extend:SI (match_dup 2))))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn "*mulhisi3_clobber_flags"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (sign_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (sign_extend:SI (match_operand:HI 2 "register_operand" "r"))))
-   (clobber (reg:CC CC_REG))]
-  ""
-  "mulxs.w	%T2,%S0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_expand "umulqihi3"
-  [(set (match_operand:HI 0 "register_operand" "")
-	(mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" ""))
-		 ;; intentionally-mismatched modes
-		 (match_operand:QI 2 "reg_or_nibble_operand" "")))]
-  ""
-  {
-    if (GET_MODE (operands[2]) != VOIDmode)
-      operands[2] = gen_rtx_ZERO_EXTEND (HImode, operands[2]);
-  })
-
-(define_insn_and_split "*umulqihi3_const"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (match_operand:QI 2 "nibble_operand" "IP4>X")))]
-  "TARGET_H8300SX"
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (mult:HI (zero_extend:HI (match_dup 1)) (match_dup 2)))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn "*umulqihi3_const_clobber_flags"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (match_operand:QI 2 "nibble_operand" "IP4>X")))
-   (clobber (reg:CC CC_REG))]
-  "TARGET_H8300SX"
-  "mulxu.b	%X2,%T0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_insn_and_split "*umulqihi3"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (zero_extend:HI (match_operand:QI 2 "register_operand" "r"))))]
-  ""
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (mult:HI (zero_extend:HI (match_dup 1))
-			    (zero_extend:HI (match_dup 2))))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn "*umulqihi3_clobber_flags"
-  [(set (match_operand:HI 0 "register_operand" "=r")
-	(mult:HI (zero_extend:HI (match_operand:QI 1 "register_operand" "%0"))
-		 (zero_extend:HI (match_operand:QI 2 "register_operand" "r"))))
-   (clobber (reg:CC CC_REG))]
-  ""
-  "mulxu.b	%X2,%T0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "none_0hit")])
-
-(define_expand "umulhisi3"
-  [(set (match_operand:SI 0 "register_operand" "")
-	(mult:SI (zero_extend:SI (match_operand:HI 1 "register_operand" ""))
-		 ;; intentionally-mismatched modes
-		 (match_operand:HI 2 "reg_or_nibble_operand" "")))]
-  ""
-  {
-    if (GET_MODE (operands[2]) != VOIDmode)
-      operands[2] = gen_rtx_ZERO_EXTEND (SImode, operands[2]);
-  })
-
-(define_insn_and_split "*umulhisi3_const"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (zero_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (match_operand:SI 2 "nibble_operand" "IP4>X")))]
-  "TARGET_H8300SX"
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (mult:SI (zero_extend:SI (match_dup 1)) (match_dup 2)))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn "*umulhisi3_const_clobber_flags"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (zero_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (match_operand:SI 2 "nibble_operand" "IP4>X")))
-   (clobber (reg:CC CC_REG))]
-  "TARGET_H8300SX"
-  "mulxu.w	%T2,%S0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_insn_and_split "*umulhisi3"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (zero_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (zero_extend:SI (match_operand:HI 2 "register_operand" "r"))))]
-  ""
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (mult:SI (zero_extend:SI (match_dup 1))
-			    (zero_extend:SI (match_dup 2))))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn "*umulhisi3_clobber_flags"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(mult:SI (zero_extend:SI (match_operand:HI 1 "register_operand" "%0"))
-		 (zero_extend:SI (match_operand:HI 2 "register_operand" "r"))))
-   (clobber (reg:CC CC_REG))]
-  ""
-  "mulxu.w	%T2,%S0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "none_0hit")])
-
-;; We could have used mulu.[wl] here, but mulu.[lw] is only available
-;; on a H8SX with a multiplier, whereas muls.w seems to be available
-;; on all H8SX variants.
-
-(define_insn_and_split "mul<mode>3"
-  [(set (match_operand:HSI 0 "register_operand" "=r")
-        (mult:HSI (match_operand:HSI 1 "register_operand" "%0")
-		  (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X")))]
-  "TARGET_H8300SX"
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0) (mult:HSI (match_dup 1) (match_dup 2)))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn "mul<mode>3_clobber_flags"
-  [(set (match_operand:HSI 0 "register_operand" "=r")
-        (mult:HSI (match_operand:HSI 1 "register_operand" "%0")
-		  (match_operand:HSI 2 "reg_or_nibble_operand" "r IP4>X")))
-   (clobber (reg:CC CC_REG))]
-  "TARGET_H8300SX"
-  { return <MODE>mode == HImode ? "muls.w\\t%T2,%T0" : "muls.l\\t%S2,%S0"; }
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_insn_and_split "smulsi3_highpart"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(truncate:SI
-	 (lshiftrt:DI
-	  (mult:DI
-	   (sign_extend:DI (match_operand:SI 1 "register_operand" "%0"))
-	   (sign_extend:DI (match_operand:SI 2 "reg_or_nibble_operand" "r IP4>X")))
-	  (const_int 32))))]
-  "TARGET_H8300SXMUL"
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (truncate:SI (lshiftrt:DI (mult:DI
-					       (sign_extend:DI (match_dup 1))
-					       (sign_extend:DI (match_dup 2)))
-					     (const_int 32))))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn "smulsi3_highpart_clobber_flags"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(truncate:SI
-	 (lshiftrt:DI
-	  (mult:DI
-	   (sign_extend:DI (match_operand:SI 1 "register_operand" "%0"))
-	   (sign_extend:DI (match_operand:SI 2 "reg_or_nibble_operand" "r IP4>X")))
-	  (const_int 32))))
-   (clobber (reg:CC CC_REG))]
-  "TARGET_H8300SXMUL"
-  "muls/u.l\\t%S2,%S0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "set_zn")])
-
-(define_insn_and_split "umulsi3_highpart"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(truncate:SI
-	  (ashiftrt:DI
-	    (mult:DI
-	      (zero_extend:DI (match_operand:SI 1 "register_operand" "%0"))
-	      (zero_extend:DI (match_operand:SI 2 "reg_or_nibble_operand" "r IP4>X")))
-	    (const_int 32))))]
-  "TARGET_H8300SX"
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (truncate:SI (ashiftrt:DI (mult:DI 
-					       (zero_extend:DI (match_dup 1))
-					       (zero_extend:DI (match_dup 2)))
-					     (const_int 32))))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn "umulsi3_highpart_clobber_flags"
-  [(set (match_operand:SI 0 "register_operand" "=r")
-	(truncate:SI
-	  (ashiftrt:DI
-	    (mult:DI
-	      (zero_extend:DI (match_operand:SI 1 "register_operand" "%0"))
-	      (zero_extend:DI (match_operand:SI 2 "reg_or_nibble_operand" "r IP4>X")))
-	    (const_int 32))))
-   (clobber (reg:CC CC_REG))]
-  "TARGET_H8300SX"
-  "mulu/u.l\\t%S2,%S0"
-  [(set_attr "length" "4")
-   (set_attr "cc" "none_0hit")])
-
-;; This is a "bridge" instruction.  Combine can't cram enough insns
-;; together to crate a MAC instruction directly, but it can create
-;; this instruction, which then allows combine to create the real
-;; MAC insn.
-;;
-;; Unfortunately, if combine doesn't create a MAC instruction, this
-;; insn must generate reasonably correct code.  Egad.
-
-(define_insn_and_split ""
-  [(set (match_operand:SI 0 "register_operand" "=a")
-	(mult:SI
-	  (sign_extend:SI
-	    (mem:HI (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
-	  (sign_extend:SI
-	    (mem:HI (post_inc:SI (match_operand:SI 2 "register_operand" "r"))))))]
-  "TARGET_MAC"
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (mult:SI (sign_extend:SI
-			      (mem:HI (post_inc:SI (match_dup 1))))
-			    (sign_extend:SI
-			      (mem:HI (post_inc:SI (match_dup 2))))))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn ""
-  [(set (match_operand:SI 0 "register_operand" "=a")
-	(mult:SI
-	  (sign_extend:SI
-	    (mem:HI (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
-	  (sign_extend:SI
-	    (mem:HI (post_inc:SI (match_operand:SI 2 "register_operand" "r"))))))
-   (clobber (reg:CC CC_REG))]
-  "TARGET_MAC"
-  "clrmac\;mac	@%2+,@%1+"
-  [(set_attr "length" "6")
-   (set_attr "cc" "none_0hit")])
-
-(define_insn_and_split ""
-  [(set (match_operand:SI 0 "register_operand" "=a")
-	(plus:SI (mult:SI
-	  (sign_extend:SI (mem:HI
-	    (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
-	  (sign_extend:SI (mem:HI
-	    (post_inc:SI (match_operand:SI 2 "register_operand" "r")))))
-	      (match_operand:SI 3 "register_operand" "0")))]
-  "TARGET_MAC"
-  "#"
-  "reload_completed"
-  [(parallel [(set (match_dup 0)
-		   (plus:SI
-		     (mult:SI
-			(sign_extend:SI (mem:HI (post_inc:SI (match_dup 1))))
-			(sign_extend:SI (mem:HI (post_inc:SI (match_dup 2)))))))
-	      (clobber (reg:CC CC_REG))])])
-
-(define_insn ""
-  [(set (match_operand:SI 0 "register_operand" "=a")
-	(plus:SI (mult:SI
-	  (sign_extend:SI (mem:HI
-	    (post_inc:SI (match_operand:SI 1 "register_operand" "r"))))
-	  (sign_extend:SI (mem:HI
-	    (post_inc:SI (match_operand:SI 2 "register_operand" "r")))))
-	      (match_operand:SI 3 "register_operand" "0")))
-   (clobber (reg:CC CC_REG))]
-  "TARGET_MAC"
-  "mac	@%2+,@%1+"
-  [(set_attr "length" "4")
-   (set_attr "cc" "none_0hit")])
-
diff --git a/gcc/config/h8300/testcompare.md b/gcc/config/h8300/testcompare.md
index 3ec961dd717..e9f6ddcf075 100644
--- a/gcc/config/h8300/testcompare.md
+++ b/gcc/config/h8300/testcompare.md
@@ -24,8 +24,7 @@
 ;;				  (const_int 0)))
 ;;	      (clobber (scratch:QI))])]
 ;;  ""
-;;  [(set_attr "length" "2,8,10")
-;;   (set_attr "cc" "set_zn,set_zn,set_zn")])
+;;  [(set_attr "length" "2,8,10")])
 ;;
 ;;(define_insn ""
 ;;  [(set (cc0)
@@ -35,8 +34,7 @@
 ;;		 (const_int 0)))]
 ;;  "INTVAL (operands[1]) <= 15"
 ;;  "btst	%Z1,%Y0"
-;;  [(set_attr "length" "2")
-;;   (set_attr "cc" "set_zn")])
+;;  [(set_attr "length" "2")])
 ;;
 ;;(define_insn_and_split "*tstsi_upper_bit"
 ;;  [(set (cc0)
@@ -71,8 +69,7 @@
 ;;		 (const_int 0)))]
 ;;  ""
 ;;  "btst	%w1,%w0"
-;;  [(set_attr "length" "2")
-;;   (set_attr "cc" "set_zn")])
+;;  [(set_attr "length" "2")])
 ;;
 ;;(define_insn_and_split "*tstsi_variable_bit_qi"
 ;;  [(set (cc0)
@@ -99,8 +96,7 @@
 ;;			    (const_int 0)))
 ;;	      (clobber (scratch:QI))])]
 ;;  ""
-;;  [(set_attr "length" "2,8,10")
-;;   (set_attr "cc" "set_zn,set_zn,set_zn")])
+;;  [(set_attr "length" "2,8,10")])
 
 (define_insn "*tst<mode>"
   [(set (reg:CCZN CC_REG)
@@ -116,8 +112,7 @@
       return "mov.l	%S0,%S0";
     gcc_unreachable ();
   }
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_znv")])
+  [(set_attr "length" "2")])
 
 (define_insn "*tsthi_upper"
   [(set (reg:CCZN CC_REG)
@@ -135,8 +130,7 @@
 		 (const_int 0)))]
   "reload_completed"
   "mov.w	%e0,%e0"
-  [(set_attr "length" "2")
-   (set_attr "cc" "set_znv")])
+  [(set_attr "length" "2")])
 
 (define_insn "*cmpqi"
   [(set (reg:CC CC_REG)
