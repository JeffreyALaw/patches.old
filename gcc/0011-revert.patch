diff --git a/gcc/config/i386/gcc-auto-profile b/gcc/config/i386/gcc-auto-profile
deleted file mode 100755
index 56f64cbff1f..00000000000
--- a/gcc/config/i386/gcc-auto-profile
+++ /dev/null
@@ -1,97 +0,0 @@
-#!/bin/sh
-# Profile workload for gcc profile feedback (autofdo) using Linux perf.
-# Auto generated. To regenerate for new CPUs run
-# contrib/gen_autofdo_event.py --script --all in gcc source
-
-# usages:
-# gcc-auto-profile program             (profile program and children)
-# gcc-auto-profile -a sleep X          (profile all for X secs, may need root)
-# gcc-auto-profile -p PID sleep X      (profile PID)
-# gcc-auto-profile --kernel -a sleep X (profile kernel)
-# gcc-auto-profile --all -a sleep X    (profile kernel and user space)
-
-# Identify branches taken event for CPU.
-#
-
-FLAGS=u
-
-if [ "$1" = "--kernel" ] ; then
-  FLAGS=k
-  shift
-fi
-if [ "$1" = "--all" ] ; then
-  FLAGS=uk
-  shift
-fi
-
-if ! grep -q Intel /proc/cpuinfo ; then
-  echo >&2 "Only Intel CPUs supported"
-  exit 1
-fi
-
-if grep -q hypervisor /proc/cpuinfo ; then
-  echo >&2 "Warning: branch profiling may not be functional in VMs"
-fi
-
-case `egrep -q "^cpu family\s*: 6" /proc/cpuinfo &&
-  egrep "^model\s*:" /proc/cpuinfo | head -n1` in
-model*:\ 55|\
-model*:\ 77|\
-model*:\ 76|\
-model*:\ 92|\
-model*:\ 95|\
-model*:\ 87|\
-model*:\ 133|\
-model*:\ 122) E="cpu/event=0xC4,umask=0xFE/p$FLAGS" ;;
-model*:\ 42|\
-model*:\ 45|\
-model*:\ 58|\
-model*:\ 62|\
-model*:\ 60|\
-model*:\ 69|\
-model*:\ 70|\
-model*:\ 63|\
-model*:\ 61|\
-model*:\ 71|\
-model*:\ 79|\
-model*:\ 86|\
-model*:\ 78|\
-model*:\ 94|\
-model*:\ 142|\
-model*:\ 158|\
-model*:\ 165|\
-model*:\ 166|\
-model*:\ 85|\
-model*:\ 85) E="cpu/event=0xC4,umask=0x20/p$FLAGS" ;;
-model*:\ 46|\
-model*:\ 30|\
-model*:\ 31|\
-model*:\ 26|\
-model*:\ 47|\
-model*:\ 37|\
-model*:\ 44) E="cpu/event=0x88,umask=0x40/p$FLAGS" ;;
-model*:\ 28|\
-model*:\ 38|\
-model*:\ 39|\
-model*:\ 54|\
-model*:\ 53) E="cpu/event=0x88,umask=0x41/p$FLAGS" ;;
-model*:\ 126|\
-model*:\ 140|\
-model*:\ 141|\
-model*:\ 106|\
-model*:\ 108) E="cpu/event=0xc4,umask=0x20/p$FLAGS" ;;
-*)
-echo >&2 "Unknown CPU. Run contrib/gen_autofdo_event.py --all --script to update script."
-	exit 1 ;;
-esac
-set -x
-if ! perf record -e $E -b "$@" ; then
-  # PEBS may not actually be working even if the processor supports it
-  # (e.g., in a virtual machine). Trying to run without /p.
-  set +x
-  echo >&2 "Retrying without /p."
-  E="$(echo "${E}" | sed -e 's/\/p/\//')"
-  set -x
-  exec perf record -e $E -b "$@"
- set +x
-fi
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
index 37c7daa7f9e..1e21fe6b13d 100644
--- a/gcc/tree-vect-loop.c
+++ b/gcc/tree-vect-loop.c
@@ -7227,13 +7227,24 @@ vectorizable_reduction (loop_vec_info loop_vinfo,
           if (dump_enabled_p ())
             dump_printf (MSG_NOTE, "op not supported by target.\n");
 	  if (maybe_ne (GET_MODE_SIZE (vec_mode), UNITS_PER_WORD)
-	      || !vect_can_vectorize_without_simd_p (code))
+	      || !vect_worthwhile_without_simd_p (loop_vinfo, code))
 	    ok = false;
 	  else
 	    if (dump_enabled_p ())
 	      dump_printf (MSG_NOTE, "proceeding using word mode.\n");
         }
 
+      /* Worthwhile without SIMD support?  */
+      if (ok
+	  && !VECTOR_MODE_P (TYPE_MODE (vectype_in))
+	  && !vect_worthwhile_without_simd_p (loop_vinfo, code))
+        {
+          if (dump_enabled_p ())
+	    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+			     "not worthwhile without SIMD support.\n");
+	  ok = false;
+        }
+
       /* lane-reducing operations have to go through vect_transform_reduction.
          For the other cases try without the single cycle optimization.  */
       if (!ok)
@@ -7937,28 +7948,46 @@ vectorizable_phi (vec_info *,
 }
 
 
-/* Return true if we can emulate CODE on an integer mode representation
-   of a vector.  */
+/* Function vect_min_worthwhile_factor.
 
-bool
-vect_can_vectorize_without_simd_p (tree_code code)
+   For a loop where we could vectorize the operation indicated by CODE,
+   return the minimum vectorization factor that makes it worthwhile
+   to use generic vectors.  */
+static unsigned int
+vect_min_worthwhile_factor (enum tree_code code)
 {
   switch (code)
     {
     case PLUS_EXPR:
     case MINUS_EXPR:
     case NEGATE_EXPR:
+      return 4;
+
     case BIT_AND_EXPR:
     case BIT_IOR_EXPR:
     case BIT_XOR_EXPR:
     case BIT_NOT_EXPR:
-      return true;
+      return 2;
 
     default:
-      return false;
+      return INT_MAX;
     }
 }
 
+/* Return true if VINFO indicates we are doing loop vectorization and if
+   it is worth decomposing CODE operations into scalar operations for
+   that loop's vectorization factor.  */
+
+bool
+vect_worthwhile_without_simd_p (vec_info *vinfo, tree_code code)
+{
+  loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);
+  unsigned HOST_WIDE_INT value;
+  return (loop_vinfo
+	  && LOOP_VINFO_VECT_FACTOR (loop_vinfo).is_constant (&value)
+	  && value >= vect_min_worthwhile_factor (code));
+}
+
 /* Function vectorizable_induction
 
    Check if STMT_INFO performs an induction computation that can be vectorized.
diff --git a/gcc/tree-vect-stmts.c b/gcc/tree-vect-stmts.c
index 5b94d41e292..94bdb74ea8d 100644
--- a/gcc/tree-vect-stmts.c
+++ b/gcc/tree-vect-stmts.c
@@ -5685,13 +5685,24 @@ vectorizable_shift (vec_info *vinfo,
       /* Check only during analysis.  */
       if (maybe_ne (GET_MODE_SIZE (vec_mode), UNITS_PER_WORD)
 	  || (!vec_stmt
-	      && !vect_can_vectorize_without_simd_p (code)))
+	      && !vect_worthwhile_without_simd_p (vinfo, code)))
         return false;
       if (dump_enabled_p ())
         dump_printf_loc (MSG_NOTE, vect_location,
                          "proceeding using word mode.\n");
     }
 
+  /* Worthwhile without SIMD support?  Check only during analysis.  */
+  if (!vec_stmt
+      && !VECTOR_MODE_P (TYPE_MODE (vectype))
+      && !vect_worthwhile_without_simd_p (vinfo, code))
+    {
+      if (dump_enabled_p ())
+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+                         "not worthwhile without SIMD support.\n");
+      return false;
+    }
+
   if (!vec_stmt) /* transformation not required.  */
     {
       if (slp_node
@@ -6083,13 +6094,24 @@ vectorizable_operation (vec_info *vinfo,
                          "op not supported by target.\n");
       /* Check only during analysis.  */
       if (maybe_ne (GET_MODE_SIZE (vec_mode), UNITS_PER_WORD)
-	  || (!vec_stmt && !vect_can_vectorize_without_simd_p (code)))
+	  || (!vec_stmt && !vect_worthwhile_without_simd_p (vinfo, code)))
         return false;
       if (dump_enabled_p ())
 	dump_printf_loc (MSG_NOTE, vect_location,
                          "proceeding using word mode.\n");
     }
 
+  /* Worthwhile without SIMD support?  Check only during analysis.  */
+  if (!VECTOR_MODE_P (vec_mode)
+      && !vec_stmt
+      && !vect_worthwhile_without_simd_p (vinfo, code))
+    {
+      if (dump_enabled_p ())
+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+                         "not worthwhile without SIMD support.\n");
+      return false;
+    }
+
   int reduc_idx = STMT_VINFO_REDUC_IDX (stmt_info);
   vec_loop_masks *masks = (loop_vinfo ? &LOOP_VINFO_MASKS (loop_vinfo) : NULL);
   internal_fn cond_fn = get_conditional_internal_fn (code);
diff --git a/gcc/tree-vectorizer.h b/gcc/tree-vectorizer.h
index de0ecf86478..5571b3cce3b 100644
--- a/gcc/tree-vectorizer.h
+++ b/gcc/tree-vectorizer.h
@@ -2061,7 +2061,7 @@ extern bool vectorizable_lc_phi (loop_vec_info, stmt_vec_info,
 				 gimple **, slp_tree);
 extern bool vectorizable_phi (vec_info *, stmt_vec_info, gimple **, slp_tree,
 			      stmt_vector_for_cost *);
-extern bool vect_can_vectorize_without_simd_p (tree_code);
+extern bool vect_worthwhile_without_simd_p (vec_info *, tree_code);
 extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,
 					stmt_vector_for_cost *,
 					stmt_vector_for_cost *,
