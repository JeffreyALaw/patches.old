diff --git a/gcc/ipa-visibility.c b/gcc/ipa-visibility.c
index 97d93889c86..122f19b250e 100644
--- a/gcc/ipa-visibility.c
+++ b/gcc/ipa-visibility.c
@@ -578,8 +578,6 @@ localize_node (bool whole_program, symtab_node *node)
 	   next != node; next = next->same_comdat_group)
 	{
 	  next->set_comdat_group (NULL);
-	  if (!next->alias)
-	    next->set_section (NULL);
 	  if (!next->transparent_alias)
 	    next->make_decl_local ();
 	  next->unique_name
@@ -602,8 +600,6 @@ localize_node (bool whole_program, symtab_node *node)
 
   if (TREE_PUBLIC (node->decl))
     node->set_comdat_group (NULL);
-  if (DECL_COMDAT (node->decl) && !node->alias)
-    node->set_section (NULL);
   if (!node->transparent_alias)
     {
       node->resolution = LDPR_PREVAILING_DEF_IRONLY;
diff --git a/gcc/testsuite/g++.dg/ext/section-class-inline-function-lto.C b/gcc/testsuite/g++.dg/ext/section-class-inline-function-lto.C
new file mode 100644
index 00000000000..4567d03a512
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/section-class-inline-function-lto.C
@@ -0,0 +1,17 @@
+// attribute((section)) should affect inline member functions even with -flto.
+
+// { dg-do link }
+// { dg-require-effective-target lto }
+// { dg-require-named-sections "" }
+// { dg-options "-flto --save-temps" }
+
+// { dg-final { scan-lto-assembler-symbol-section {callee} {^(\.testsection|__TEXT,__testsection)$} } }
+#include "section-class-inline-function.C"
+
+// { dg-final { cleanup-saved-temps } }
+
+int
+main()
+{
+  return f();
+}
diff --git a/gcc/testsuite/g++.dg/ext/section-class-inline-function.C b/gcc/testsuite/g++.dg/ext/section-class-inline-function.C
new file mode 100644
index 00000000000..01a12d02aff
--- /dev/null
+++ b/gcc/testsuite/g++.dg/ext/section-class-inline-function.C
@@ -0,0 +1,25 @@
+// attribute((section)) should affect inline member functions.
+
+// { dg-do compile }
+// { dg-require-named-sections "" }
+
+#if defined(__APPLE__)
+#define TESTSECTION "__TEXT,__testsection"
+#else
+#define TESTSECTION ".testsection"
+#endif
+
+// { dg-final { scan-assembler-symbol-section {callee} {^(\.testsection|__TEXT,__testsection)$} } }
+struct s {
+  __attribute__((section(TESTSECTION)))
+      int callee()
+  {
+    return 0;
+  }
+};
+
+int
+f()
+{
+  return s().callee();
+}
diff --git a/gcc/testsuite/lib/scanasm.exp b/gcc/testsuite/lib/scanasm.exp
index 43b76495ad8..02cd4379910 100644
--- a/gcc/testsuite/lib/scanasm.exp
+++ b/gcc/testsuite/lib/scanasm.exp
@@ -183,6 +183,29 @@ proc scan-assembler-symbol-section { args } {
     $expected_section_pattern
 }
 
+# Check that symbols are emitted in the desired section.
+# Like scan-assembler-symbol-section, but using the assembly output generated by
+# the compiler with '-flto --save-temps'.
+#
+# Example:
+#
+# // All numbered functions (func1, func2, etc.) must be in the .text section or
+# // in a .text sub-section (like .text._func1).
+# { dg-final { scan-lto-assembler-symbol-section {^_func[1-5]$} {^\.text($|\.)} } }
+
+proc scan-lto-assembler-symbol-section { args } {
+    set testcase [testname-for-summary]
+    set output_file [lto_assembly_output_file $testcase]
+    set symbol_pattern [lindex $args 0]
+    set expected_section_pattern [lindex $args 1]
+    dg-scan-symbol-section \
+    "scan-lto-assembler-symbol-section" \
+    $testcase \
+    $output_file \
+    $symbol_pattern \
+    $expected_section_pattern
+}
+
 # Check that symbols are emitted in the desired section.
 #
 # Symbols and sections are interpreted as regexp patterns.
@@ -724,11 +747,16 @@ proc dg-function-on-line { args } {
 
 proc scan-lto-assembler { args } {
     set testcase [testname-for-summary]
+    set output_file [lto_assembly_output_file $testcase]
+    dg-scan "scan-lto-assembler" 1 $testcase $output_file $args
+}
+
+proc lto_assembly_output_file { testcase } {
     # The name might include a list of options; extract the file name.
     set filename [lindex $testcase 0]
     set output_file "[file rootname [file tail $filename]].exe.ltrans0.s"
     verbose "output_file: $output_file"
-    dg-scan "scan-lto-assembler" 1 $testcase $output_file $args
+    return $output_file
 }
 
 # Read assembly file FILENAME and store a mapping from function names
