

avr-elf seems to use HImode for both integer_type_node and
signed_char_type_node, which is causing the check for different sized
VARYING ranges to fail.

I've fixed this by using a char which I think should always be smaller than an
int.  Is there a preferred way of fixing this?  Perhaps build_nonstandard_integer
or __attribute__((mode(XX)))?

Tested on an x86-64 x avr-elf.

gcc/ChangeLog:

	* value-range.cc (range_tests_legacy): Use signed char instead
	of signed short.
---
 gcc/value-range.cc | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/gcc/value-range.cc b/gcc/value-range.cc
index 8d7b46c0239..5eefd5ff174 100644
--- a/gcc/value-range.cc
+++ b/gcc/value-range.cc
@@ -2251,10 +2251,10 @@ range_tests_legacy ()
 
   // VARYING of different sizes should not be equal.
   int_range_max r0 (integer_type_node);
-  int_range_max r1 (short_integer_type_node);
+  int_range_max r1 (signed_char_type_node);
   ASSERT_TRUE (r0 != r1);
   value_range vr0 (integer_type_node);
-  int_range_max vr1 (short_integer_type_node);
+  int_range_max vr1 (signed_char_type_node);
   ASSERT_TRUE (vr0 != vr1);
 }
 
-- 
2.31.1

