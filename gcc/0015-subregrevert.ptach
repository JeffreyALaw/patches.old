diff --git a/gcc/expr.c b/gcc/expr.c
index 5dd98a9bccc..096c0315ecc 100644
--- a/gcc/expr.c
+++ b/gcc/expr.c
@@ -688,24 +688,7 @@ convert_modes (machine_mode mode, machine_mode oldmode, rtx x, int unsignedp)
       && (GET_MODE_PRECISION (subreg_promoted_mode (x))
 	  >= GET_MODE_PRECISION (int_mode))
       && SUBREG_CHECK_PROMOTED_SIGN (x, unsignedp))
-    {
-      scalar_int_mode int_orig_mode;
-      machine_mode orig_mode = GET_MODE (x);
-      x = gen_lowpart (int_mode, SUBREG_REG (x));
-
-      /* Preserve SUBREG_PROMOTED_VAR_P if the new mode is wider than
-	 the original mode, but narrower than the inner mode.  */
-      if (GET_CODE (x) == SUBREG
-	  && GET_MODE_PRECISION (subreg_promoted_mode (x))
-	     > GET_MODE_PRECISION (int_mode)
-	  && is_a <scalar_int_mode> (orig_mode, &int_orig_mode)
-	  && GET_MODE_PRECISION (int_mode)
-	     > GET_MODE_PRECISION (int_orig_mode))
-	{
-	  SUBREG_PROMOTED_VAR_P (x) = 1;
-	  SUBREG_PROMOTED_SET (x, unsignedp);
-	}
-    }
+    x = gen_lowpart (int_mode, SUBREG_REG (x));
 
   if (GET_MODE (x) != VOIDmode)
     oldmode = GET_MODE (x);
diff --git a/gcc/simplify-rtx.c b/gcc/simplify-rtx.c
index ebad5cb5a79..e431e0c19d7 100644
--- a/gcc/simplify-rtx.c
+++ b/gcc/simplify-rtx.c
@@ -1512,28 +1512,12 @@ simplify_context::simplify_unary_operation_1 (rtx_code code, machine_mode mode,
 	 target mode is the same as the variable's promotion.  */
       if (GET_CODE (op) == SUBREG
 	  && SUBREG_PROMOTED_VAR_P (op)
-	  && SUBREG_PROMOTED_SIGNED_P (op))
+	  && SUBREG_PROMOTED_SIGNED_P (op)
+	  && !paradoxical_subreg_p (mode, GET_MODE (SUBREG_REG (op))))
 	{
-	  rtx subreg = SUBREG_REG (op);
-	  machine_mode subreg_mode = GET_MODE (subreg);
-	  if (!paradoxical_subreg_p (mode, subreg_mode))
-	    {
-	      temp = rtl_hooks.gen_lowpart_no_emit (mode, subreg);
-	      if (temp)
-		{
-		  /* Preserve SUBREG_PROMOTED_VAR_P.  */
-		  if (partial_subreg_p (temp))
-		    {
-		      SUBREG_PROMOTED_VAR_P (temp) = 1;
-		      SUBREG_PROMOTED_SET (temp, 1);
-		    }
-		  return temp;
-		}
-	    }
-	  else
-	    /* Sign-extending a sign-extended subreg.  */
-	    return simplify_gen_unary (SIGN_EXTEND, mode,
-				       subreg, subreg_mode);
+	  temp = rtl_hooks.gen_lowpart_no_emit (mode, SUBREG_REG (op));
+	  if (temp)
+	    return temp;
 	}
 
       /* (sign_extend:M (sign_extend:N <X>)) is (sign_extend:M <X>).
@@ -1647,28 +1631,12 @@ simplify_context::simplify_unary_operation_1 (rtx_code code, machine_mode mode,
 	 target mode is the same as the variable's promotion.  */
       if (GET_CODE (op) == SUBREG
 	  && SUBREG_PROMOTED_VAR_P (op)
-	  && SUBREG_PROMOTED_UNSIGNED_P (op))
+	  && SUBREG_PROMOTED_UNSIGNED_P (op)
+	  && !paradoxical_subreg_p (mode, GET_MODE (SUBREG_REG (op))))
 	{
-	  rtx subreg = SUBREG_REG (op);
-	  machine_mode subreg_mode = GET_MODE (subreg);
-	  if (!paradoxical_subreg_p (mode, subreg_mode))
-	    {
-	      temp = rtl_hooks.gen_lowpart_no_emit (mode, subreg);
-	      if (temp)
-		{
-		  /* Preserve SUBREG_PROMOTED_VAR_P.  */
-		  if (partial_subreg_p (temp))
-		    {
-		      SUBREG_PROMOTED_VAR_P (temp) = 1;
-		      SUBREG_PROMOTED_SET (temp, 0);
-		    }
-		  return temp;
-		}
-	    }
-	  else
-	    /* Zero-extending a zero-extended subreg.  */
-	    return simplify_gen_unary (ZERO_EXTEND, mode,
-				       subreg, subreg_mode);
+	  temp = rtl_hooks.gen_lowpart_no_emit (mode, SUBREG_REG (op));
+	  if (temp)
+	    return temp;
 	}
 
       /* Extending a widening multiplication should be canonicalized to
