diff --git a/gcc/tree-ssa-dom.c b/gcc/tree-ssa-dom.c
index c21bfe9f64e..6b45effc770 100644
--- a/gcc/tree-ssa-dom.c
+++ b/gcc/tree-ssa-dom.c
@@ -585,19 +585,48 @@ record_edge_info (basic_block bb)
     }
 }
 
+class dom_jump_threader_simplifier : public jump_threader_simplifier
+{
+public:
+  dom_jump_threader_simplifier (vr_values *v,
+				avail_exprs_stack *avails)
+    : jump_threader_simplifier (v, avails) {}
+
+private:
+  tree simplify (gimple *, gimple *, basic_block);
+};
+
+tree
+dom_jump_threader_simplifier::simplify (gimple *stmt,
+					gimple *within_stmt,
+					basic_block bb)
+{
+  /* First see if the conditional is in the hash table.  */
+  tree cached_lhs =  m_avail_exprs_stack->lookup_avail_expr (stmt,
+							     false, true);
+  if (cached_lhs)
+    return cached_lhs;
+
+  return jump_threader_simplifier::simplify (stmt, within_stmt, bb);
+}
 
 class dom_opt_dom_walker : public dom_walker
 {
 public:
   dom_opt_dom_walker (cdi_direction direction,
-		      class const_and_copies *const_and_copies,
-		      class avail_exprs_stack *avail_exprs_stack,
-		      gcond *dummy_cond)
-    : dom_walker (direction, REACHABLE_BLOCKS),
-      m_const_and_copies (const_and_copies),
-      m_avail_exprs_stack (avail_exprs_stack),
-      evrp_range_analyzer (true),
-      m_dummy_cond (dummy_cond) { }
+		      jump_threader *threader,
+		      evrp_range_analyzer *analyzer,
+		      const_and_copies *const_and_copies,
+		      avail_exprs_stack *avail_exprs_stack)
+    : dom_walker (direction, REACHABLE_BLOCKS)
+    {
+      m_evrp_range_analyzer = analyzer;
+      m_dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,
+					integer_zero_node, NULL, NULL);
+      m_const_and_copies = const_and_copies;
+      m_avail_exprs_stack = avail_exprs_stack;
+      m_threader = threader;
+    }
 
   virtual edge before_dom_children (basic_block);
   virtual void after_dom_children (basic_block);
@@ -608,9 +637,6 @@ private:
   class const_and_copies *m_const_and_copies;
   class avail_exprs_stack *m_avail_exprs_stack;
 
-  /* VRP data.  */
-  class evrp_range_analyzer evrp_range_analyzer;
-
   /* Dummy condition to avoid creating lots of throw away statements.  */
   gcond *m_dummy_cond;
 
@@ -619,6 +645,13 @@ private:
      the statement is a conditional with a statically determined
      value.  */
   edge optimize_stmt (basic_block, gimple_stmt_iterator *, bool *);
+
+
+  void test_for_singularity (gimple *, avail_exprs_stack *);
+
+  dom_jump_threader_simplifier *m_simplifier;
+  jump_threader *m_threader;
+  evrp_range_analyzer *m_evrp_range_analyzer;
 };
 
 /* Jump threading, redundancy elimination and const/copy propagation.
@@ -697,9 +730,6 @@ pass_dominator::execute (function *fun)
      LOOPS_HAVE_PREHEADERS won't be needed here.  */
   loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);
 
-  /* Initialize the value-handle array.  */
-  threadedge_initialize_values ();
-
   /* We need accurate information regarding back edges in the CFG
      for jump threading; this may include back edges that are not part of
      a single loop.  */
@@ -715,12 +745,16 @@ pass_dominator::execute (function *fun)
   FOR_EACH_BB_FN (bb, fun)
     record_edge_info (bb);
 
-  gcond *dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,
-					 integer_zero_node, NULL, NULL);
-
   /* Recursively walk the dominator tree optimizing statements.  */
-  dom_opt_dom_walker walker (CDI_DOMINATORS, const_and_copies,
-			     avail_exprs_stack, dummy_cond);
+  evrp_range_analyzer analyzer (true);
+  dom_jump_threader_simplifier simplifier (&analyzer, avail_exprs_stack);
+  jump_threader threader (const_and_copies, avail_exprs_stack,
+			  &simplifier, &analyzer);
+  dom_opt_dom_walker walker (CDI_DOMINATORS,
+			     &threader,
+			     &analyzer,
+			     const_and_copies,
+			     avail_exprs_stack);
   walker.walk (fun->cfg->x_entry_block_ptr);
 
   /* Look for blocks where we cleared EDGE_EXECUTABLE on an outgoing
@@ -749,7 +783,7 @@ pass_dominator::execute (function *fun)
 	     containing any edge leaving BB.  */
 	  if (found)
 	    FOR_EACH_EDGE (e, ei, bb->succs)
-	      remove_jump_threads_including (e);
+	      threader.remove_jump_threads_including (e);
 	}
     }
 
@@ -773,7 +807,7 @@ pass_dominator::execute (function *fun)
   free_all_edge_infos ();
 
   /* Thread jumps, creating duplicate blocks as needed.  */
-  cfg_altered |= thread_through_all_blocks (may_peel_loop_headers_p);
+  cfg_altered |= threader.thread_through_all_blocks (may_peel_loop_headers_p);
 
   if (cfg_altered)
     free_dominance_info (CDI_DOMINATORS);
@@ -849,9 +883,6 @@ pass_dominator::execute (function *fun)
   delete avail_exprs_stack;
   delete const_and_copies;
 
-  /* Free the value-handle array.  */
-  threadedge_finalize_values ();
-
   return 0;
 }
 
@@ -863,72 +894,6 @@ make_pass_dominator (gcc::context *ctxt)
   return new pass_dominator (ctxt);
 }
 
-/* A hack until we remove threading from tree-vrp.c and bring the
-   simplification routine into the dom_opt_dom_walker class.  */
-static class vr_values *x_vr_values;
-
-/* A trivial wrapper so that we can present the generic jump
-   threading code with a simple API for simplifying statements.
-
-   ?? This should be cleaned up.  There's a virtually identical copy
-   of this function in tree-vrp.c.  */
-
-static tree
-simplify_stmt_for_jump_threading (gimple *stmt,
-				  gimple *within_stmt ATTRIBUTE_UNUSED,
-				  class avail_exprs_stack *avail_exprs_stack,
-				  basic_block bb ATTRIBUTE_UNUSED)
-{
-  /* First query our hash table to see if the expression is available
-     there.  A non-NULL return value will be either a constant or another
-     SSA_NAME.  */
-  tree cached_lhs =  avail_exprs_stack->lookup_avail_expr (stmt, false, true);
-  if (cached_lhs)
-    return cached_lhs;
-
-  /* If the hash table query failed, query VRP information.  This is
-     essentially the same as tree-vrp's simplification routine.  The
-     copy in tree-vrp is scheduled for removal in gcc-9.  */
-  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))
-    {
-      simplify_using_ranges simplifier (x_vr_values);
-      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),
-						  gimple_cond_lhs (cond_stmt),
-						  gimple_cond_rhs (cond_stmt),
-						  within_stmt);
-    }
-
-  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))
-    {
-      tree op = gimple_switch_index (switch_stmt);
-      if (TREE_CODE (op) != SSA_NAME)
-	return NULL_TREE;
-
-      const value_range_equiv *vr = x_vr_values->get_value_range (op);
-      return find_case_label_range (switch_stmt, vr);
-    }
-
-  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))
-    {
-      tree lhs = gimple_assign_lhs (assign_stmt);
-      if (TREE_CODE (lhs) == SSA_NAME
-	  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))
-	      || POINTER_TYPE_P (TREE_TYPE (lhs)))
-	  && stmt_interesting_for_vrp (stmt))
-	{
-	  edge dummy_e;
-	  tree dummy_tree;
-	  value_range_equiv new_vr;
-	  x_vr_values->extract_range_from_stmt (stmt, &dummy_e,
-						&dummy_tree, &new_vr);
-	  tree singleton;
-	  if (new_vr.singleton_p (&singleton))
-	    return singleton;
-	}
-    }
-  return NULL;
-}
-
 /* Valueize hook for gimple_fold_stmt_to_constant_1.  */
 
 static tree
@@ -1417,7 +1382,7 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)
   if (dump_file && (dump_flags & TDF_DETAILS))
     fprintf (dump_file, "\n\nOptimizing block #%d\n\n", bb->index);
 
-  evrp_range_analyzer.enter (bb);
+  m_evrp_range_analyzer->enter (bb);
 
   /* Push a marker on the stacks of local information so that we know how
      far to unwind when we finalize this block.  */
@@ -1455,7 +1420,7 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)
 	}
 
       /* Compute range information and optimize the stmt.  */
-      evrp_range_analyzer.record_ranges_from_stmt (gsi_stmt (gsi), false);
+      m_evrp_range_analyzer->record_ranges_from_stmt (gsi_stmt (gsi), false);
       bool removed_p = false;
       taken_edge = this->optimize_stmt (bb, &gsi, &removed_p);
       if (!removed_p)
@@ -1500,17 +1465,10 @@ dom_opt_dom_walker::before_dom_children (basic_block bb)
 void
 dom_opt_dom_walker::after_dom_children (basic_block bb)
 {
-  x_vr_values = &evrp_range_analyzer;
-  thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,
-			 m_avail_exprs_stack,
-			 &evrp_range_analyzer,
-			 simplify_stmt_for_jump_threading);
-  x_vr_values = NULL;
-
-  /* These remove expressions local to BB from the tables.  */
+  m_threader->thread_outgoing_edges (bb);
   m_avail_exprs_stack->pop_to_marker ();
   m_const_and_copies->pop_to_marker ();
-  evrp_range_analyzer.leave (bb);
+  m_evrp_range_analyzer->leave (bb);
 }
 
 /* Search for redundant computations in STMT.  If any are found, then
@@ -1849,9 +1807,9 @@ cprop_into_stmt (gimple *stmt, vr_values *vr_values)
 
    This is similar to code in VRP.  */
 
-static void
-test_for_singularity (gimple *stmt, gcond *dummy_cond,
-		      avail_exprs_stack *avail_exprs_stack)
+void
+dom_opt_dom_walker::test_for_singularity (gimple *stmt,
+					  avail_exprs_stack *avail_exprs_stack)
 {
   /* We want to support gimple conditionals as well as assignments
      where the RHS contains a conditional.  */
@@ -1897,11 +1855,12 @@ test_for_singularity (gimple *stmt, gcond *dummy_cond,
 	    test_code = GE_EXPR;
 
 	  /* Update the dummy statement so we can query the hash tables.  */
-	  gimple_cond_set_code (dummy_cond, test_code);
-	  gimple_cond_set_lhs (dummy_cond, lhs);
-	  gimple_cond_set_rhs (dummy_cond, rhs);
+	  gimple_cond_set_code (m_dummy_cond, test_code);
+	  gimple_cond_set_lhs (m_dummy_cond, lhs);
+	  gimple_cond_set_rhs (m_dummy_cond, rhs);
 	  tree cached_lhs
-	    = avail_exprs_stack->lookup_avail_expr (dummy_cond, false, false);
+	    = avail_exprs_stack->lookup_avail_expr (m_dummy_cond,
+						    false, false);
 
 	  /* If the lookup returned 1 (true), then the expression we
 	     queried was in the hash table.  As a result there is only
@@ -1970,7 +1929,7 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,
   opt_stats.num_stmts++;
 
   /* Const/copy propagate into USES, VUSES and the RHS of VDEFs.  */
-  cprop_into_stmt (stmt, &evrp_range_analyzer);
+  cprop_into_stmt (stmt, m_evrp_range_analyzer);
 
   /* If the statement has been modified with constant replacements,
      fold its RHS before checking for redundant computations.  */
@@ -2068,8 +2027,8 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,
 		 SSA_NAMES.  */
 	      update_stmt_if_modified (stmt);
 	      edge taken_edge = NULL;
-	      evrp_range_analyzer.vrp_visit_cond_stmt (as_a <gcond *> (stmt),
-						       &taken_edge);
+	      m_evrp_range_analyzer->vrp_visit_cond_stmt
+		(as_a <gcond *> (stmt), &taken_edge);
 	      if (taken_edge)
 		{
 		  if (taken_edge->flags & EDGE_TRUE_VALUE)
@@ -2136,7 +2095,7 @@ dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator *si,
       /* If this statement was not redundant, we may still be able to simplify
 	 it, which may in turn allow other part of DOM or other passes to do
 	 a better job.  */
-      test_for_singularity (stmt, m_dummy_cond, m_avail_exprs_stack);
+      test_for_singularity (stmt, m_avail_exprs_stack);
     }
 
   /* Record any additional equivalences created by this statement.  */
diff --git a/gcc/tree-ssa-threadbackward.c b/gcc/tree-ssa-threadbackward.c
index 327628f1662..002cb22977f 100644
--- a/gcc/tree-ssa-threadbackward.c
+++ b/gcc/tree-ssa-threadbackward.c
@@ -39,9 +39,11 @@ along with GCC; see the file COPYING3.  If not see
 
 class thread_jumps
 {
- public:
+public:
   void find_jump_threads_backwards (basic_block bb, bool speed_p);
- private:
+  bool thread_through_all_blocks ();
+
+private:
   edge profitable_jump_thread_path (basic_block bbi, tree name, tree arg,
 				    bool *creates_irreducible_loop);
   void convert_and_register_current_path (edge taken_edge);
@@ -65,8 +67,16 @@ class thread_jumps
   /* Indicate that we could increase code size to improve the
      code path.  */
   bool m_speed_p;
+
+  jump_thread_path_registry m_registry;
 };
 
+bool
+thread_jumps::thread_through_all_blocks ()
+{
+  return m_registry.thread_through_all_blocks (true);
+}
+
 /* Simple helper to get the last statement from BB, which is assumed
    to be a control statement.   Return NULL if the last statement is
    not a control statement.  */
@@ -454,7 +464,7 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,
 void
 thread_jumps::convert_and_register_current_path (edge taken_edge)
 {
-  vec<jump_thread_edge *> *jump_thread_path = new vec<jump_thread_edge *> ();
+  jump_thread_path *path = m_registry.allocate_thread_path ();
 
   /* Record the edges between the blocks in PATH.  */
   for (unsigned int j = 0; j + 1 < m_path.length (); j++)
@@ -464,16 +474,17 @@ thread_jumps::convert_and_register_current_path (edge taken_edge)
 
       edge e = find_edge (bb1, bb2);
       gcc_assert (e);
-      jump_thread_edge *x = new jump_thread_edge (e, EDGE_FSM_THREAD);
-      jump_thread_path->safe_push (x);
+      jump_thread_edge *x
+	= m_registry.allocate_thread_edge (e, EDGE_FSM_THREAD);
+      path->safe_push (x);
     }
 
   /* Add the edge taken when the control variable has value ARG.  */
   jump_thread_edge *x
-    = new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);
-  jump_thread_path->safe_push (x);
+    = m_registry.allocate_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);
+  path->safe_push (x);
 
-  register_jump_thread (jump_thread_path);
+  m_registry.register_jump_thread (path);
   --m_max_threaded_paths;
 }
 
@@ -822,7 +833,7 @@ pass_thread_jumps::execute (function *fun)
       if (EDGE_COUNT (bb->succs) > 1)
 	threader.find_jump_threads_backwards (bb, true);
     }
-  bool changed = thread_through_all_blocks (true);
+  bool changed = threader.thread_through_all_blocks ();
 
   loop_optimizer_finalize ();
   return changed ? TODO_cleanup_cfg : 0;
@@ -883,7 +894,7 @@ pass_early_thread_jumps::execute (function *fun)
       if (EDGE_COUNT (bb->succs) > 1)
 	threader.find_jump_threads_backwards (bb, false);
     }
-  thread_through_all_blocks (true);
+  threader.thread_through_all_blocks ();
 
   loop_optimizer_finalize ();
   return 0;
diff --git a/gcc/tree-ssa-threadedge.c b/gcc/tree-ssa-threadedge.c
index f43d5812270..42ce69f4932 100644
--- a/gcc/tree-ssa-threadedge.c
+++ b/gcc/tree-ssa-threadedge.c
@@ -49,10 +49,6 @@ static int stmt_count;
 /* Array to record value-handles per SSA_NAME.  */
 vec<tree> ssa_name_values;
 
-typedef tree (pfn_simplify) (gimple *, gimple *,
-			     class avail_exprs_stack *,
-			     basic_block);
-
 /* Set the value for the SSA name NAME to VALUE.  */
 
 void
@@ -65,25 +61,48 @@ set_ssa_name_value (tree name, tree value)
   ssa_name_values[SSA_NAME_VERSION (name)] = value;
 }
 
-/* Initialize the per SSA_NAME value-handles array.  Returns it.  */
-void
-threadedge_initialize_values (void)
+jump_threader::jump_threader (const_and_copies *copies,
+			      avail_exprs_stack *avails,
+			      jump_threader_simplifier *simplifier,
+			      evrp_range_analyzer *analyzer)
 {
+  /* Initialize the per SSA_NAME value-handles array.  */
   gcc_assert (!ssa_name_values.exists ());
   ssa_name_values.create (num_ssa_names);
+
+  dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,
+				  integer_zero_node, NULL, NULL);
+
+  m_const_and_copies = copies;
+  m_avail_exprs_stack = avails;
+  m_registry = new jump_thread_path_registry ();
+  m_simplifier = simplifier;
+  m_evrp_range_analyzer = analyzer;
 }
 
-/* Free the per SSA_NAME value-handle array.  */
-void
-threadedge_finalize_values (void)
+jump_threader::~jump_threader (void)
 {
   ssa_name_values.release ();
+  ggc_free (dummy_cond);
+  delete m_registry;
+}
+
+void
+jump_threader::remove_jump_threads_including (edge_def *e)
+{
+  m_registry->remove_jump_threads_including (e);
+}
+
+bool
+jump_threader::thread_through_all_blocks (bool may_peel_loop_headers)
+{
+  return m_registry->thread_through_all_blocks (may_peel_loop_headers);
 }
 
 /* Return TRUE if we may be able to thread an incoming edge into
    BB to an outgoing edge from BB.  Return FALSE otherwise.  */
 
-bool
+static bool
 potentially_threadable_block (basic_block bb)
 {
   gimple_stmt_iterator gsi;
@@ -116,16 +135,13 @@ potentially_threadable_block (basic_block bb)
 }
 
 /* Record temporary equivalences created by PHIs at the target of the
-   edge E.  Record unwind information for the equivalences into
-   CONST_AND_COPIES and EVRP_RANGE_DATA.
+   edge E.
 
    If a PHI which prevents threading is encountered, then return FALSE
    indicating we should not thread this edge, else return TRUE.  */
 
-static bool
-record_temporary_equivalences_from_phis (edge e,
-    const_and_copies *const_and_copies,
-    evrp_range_analyzer *evrp_range_analyzer)
+bool
+jump_threader::record_temporary_equivalences_from_phis (edge e)
 {
   gphi_iterator gsi;
 
@@ -152,19 +168,19 @@ record_temporary_equivalences_from_phis (edge e,
       if (!virtual_operand_p (dst))
 	stmt_count++;
 
-      const_and_copies->record_const_or_copy (dst, src);
+      m_const_and_copies->record_const_or_copy (dst, src);
 
       /* Also update the value range associated with DST, using
 	 the range from SRC.
 
 	 Note that even if SRC is a constant we need to set a suitable
 	 output range so that VR_UNDEFINED ranges do not leak through.  */
-      if (evrp_range_analyzer)
+      if (m_evrp_range_analyzer)
 	{
 	  /* Get an empty new VR we can pass to update_value_range and save
 	     away in the VR stack.  */
 	  value_range_equiv *new_vr
-			  = evrp_range_analyzer->allocate_value_range_equiv ();
+	    = m_evrp_range_analyzer->allocate_value_range_equiv ();
 	  new (new_vr) value_range_equiv ();
 
 	  /* There are three cases to consider:
@@ -178,14 +194,14 @@ record_temporary_equivalences_from_phis (edge e,
 	       Otherwise set NEW_VR to varying.  This may be overly
 	       conservative.  */
 	  if (TREE_CODE (src) == SSA_NAME)
-	    new_vr->deep_copy (evrp_range_analyzer->get_value_range (src));
+	    new_vr->deep_copy (m_evrp_range_analyzer->get_value_range (src));
 	  else if (TREE_CODE (src) == INTEGER_CST)
 	    new_vr->set (src);
 	  else
 	    new_vr->set_varying (TREE_TYPE (src));
 
 	  /* This is a temporary range for DST, so push it.  */
-	  evrp_range_analyzer->push_value_range (dst, new_vr);
+	  m_evrp_range_analyzer->push_value_range (dst, new_vr);
 	}
     }
   return true;
@@ -210,8 +226,8 @@ threadedge_valueize (tree t)
 
    Record unwind information for temporary equivalences onto STACK.
 
-   Use SIMPLIFY (a pointer to a callback function) to further simplify
-   statements using pass specific information.
+   Use SIMPLIFIER to further simplify statements using pass specific
+   information.
 
    We might consider marking just those statements which ultimately
    feed the COND_EXPR.  It's not clear if the overhead of bookkeeping
@@ -222,12 +238,8 @@ threadedge_valueize (tree t)
    a context sensitive equivalence which may help us simplify
    later statements in E->dest.  */
 
-static gimple *
-record_temporary_equivalences_from_stmts_at_dest (edge e,
-    const_and_copies *const_and_copies,
-    avail_exprs_stack *avail_exprs_stack,
-    evrp_range_analyzer *evrp_range_analyzer,
-    pfn_simplify simplify)
+gimple *
+jump_threader::record_temporary_equivalences_from_stmts_at_dest (edge e)
 {
   gimple *stmt = NULL;
   gimple_stmt_iterator gsi;
@@ -288,8 +300,8 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,
 
       /* These are temporary ranges, do nto reflect them back into
 	 the global range data.  */
-      if (evrp_range_analyzer)
-	evrp_range_analyzer->record_ranges_from_stmt (stmt, true);
+      if (m_evrp_range_analyzer)
+	m_evrp_range_analyzer->record_ranges_from_stmt (stmt, true);
 
       /* If this is not a statement that sets an SSA_NAME to a new
 	 value, then do not try to simplify this statement as it will
@@ -390,7 +402,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,
 		    SET_USE (use_p, tmp);
 		}
 
-	      cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack, e->src);
+	      cached_lhs = m_simplifier->simplify (stmt, stmt, e->src);
 
 	      /* Restore the statement's original uses/defs.  */
 	      i = 0;
@@ -404,38 +416,23 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,
       if (cached_lhs
 	  && (TREE_CODE (cached_lhs) == SSA_NAME
 	      || is_gimple_min_invariant (cached_lhs)))
-	const_and_copies->record_const_or_copy (gimple_get_lhs (stmt),
-						cached_lhs);
+	m_const_and_copies->record_const_or_copy (gimple_get_lhs (stmt),
+						  cached_lhs);
     }
   return stmt;
 }
 
-static tree simplify_control_stmt_condition_1 (edge, gimple *,
-					       class avail_exprs_stack *,
-					       tree, enum tree_code, tree,
-					       gcond *, pfn_simplify,
-					       unsigned);
-
 /* Simplify the control statement at the end of the block E->dest.
 
-   To avoid allocating memory unnecessarily, a scratch GIMPLE_COND
-   is available to use/clobber in DUMMY_COND.
-
    Use SIMPLIFY (a pointer to a callback function) to further simplify
    a condition using pass specific information.
 
    Return the simplified condition or NULL if simplification could
    not be performed.  When simplifying a GIMPLE_SWITCH, we may return
-   the CASE_LABEL_EXPR that will be taken.
+   the CASE_LABEL_EXPR that will be taken.  */
 
-   The available expression table is referenced via AVAIL_EXPRS_STACK.  */
-
-static tree
-simplify_control_stmt_condition (edge e,
-				 gimple *stmt,
-				 class avail_exprs_stack *avail_exprs_stack,
-				 gcond *dummy_cond,
-				 pfn_simplify simplify)
+tree
+jump_threader::simplify_control_stmt_condition (edge e, gimple *stmt)
 {
   tree cond, cached_lhs;
   enum gimple_code code = gimple_code (stmt);
@@ -479,9 +476,7 @@ simplify_control_stmt_condition (edge e,
       const unsigned recursion_limit = 4;
 
       cached_lhs
-	= simplify_control_stmt_condition_1 (e, stmt, avail_exprs_stack,
-					     op0, cond_code, op1,
-					     dummy_cond, simplify,
+	= simplify_control_stmt_condition_1 (e, stmt, op0, cond_code, op1,
 					     recursion_limit);
 
       /* If we were testing an integer/pointer against a constant, then
@@ -551,12 +546,11 @@ simplify_control_stmt_condition (edge e,
 		 the label that is proven to be taken.  */
 	      gswitch *dummy_switch = as_a<gswitch *> (gimple_copy (stmt));
 	      gimple_switch_set_index (dummy_switch, cached_lhs);
-	      cached_lhs = (*simplify) (dummy_switch, stmt,
-					avail_exprs_stack, e->src);
+	      cached_lhs = m_simplifier->simplify (dummy_switch, stmt, e->src);
 	      ggc_free (dummy_switch);
 	    }
 	  else
-	    cached_lhs = (*simplify) (stmt, stmt, avail_exprs_stack, e->src);
+	    cached_lhs = m_simplifier->simplify (stmt, stmt, e->src);
 	}
 
       /* We couldn't find an invariant.  But, callers of this
@@ -573,16 +567,14 @@ simplify_control_stmt_condition (edge e,
 
 /* Recursive helper for simplify_control_stmt_condition.  */
 
-static tree
-simplify_control_stmt_condition_1 (edge e,
-				   gimple *stmt,
-				   class avail_exprs_stack *avail_exprs_stack,
-				   tree op0,
-				   enum tree_code cond_code,
-				   tree op1,
-				   gcond *dummy_cond,
-				   pfn_simplify simplify,
-				   unsigned limit)
+tree
+jump_threader::simplify_control_stmt_condition_1
+					(edge e,
+					 gimple *stmt,
+					 tree op0,
+					 enum tree_code cond_code,
+					 tree op1,
+					 unsigned limit)
 {
   if (limit == 0)
     return NULL_TREE;
@@ -617,9 +609,8 @@ simplify_control_stmt_condition_1 (edge e,
 
 	  /* Is A != 0 ?  */
 	  const tree res1
-	    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,
+	    = simplify_control_stmt_condition_1 (e, def_stmt,
 						 rhs1, NE_EXPR, op1,
-						 dummy_cond, simplify,
 						 limit - 1);
 	  if (res1 == NULL_TREE)
 	    ;
@@ -644,9 +635,8 @@ simplify_control_stmt_condition_1 (edge e,
 
 	  /* Is B != 0 ?  */
 	  const tree res2
-	    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,
+	    = simplify_control_stmt_condition_1 (e, def_stmt,
 						 rhs2, NE_EXPR, op1,
-						 dummy_cond, simplify,
 						 limit - 1);
 	  if (res2 == NULL_TREE)
 	    ;
@@ -709,9 +699,8 @@ simplify_control_stmt_condition_1 (edge e,
 	    new_cond = invert_tree_comparison (new_cond, false);
 
 	  tree res
-	    = simplify_control_stmt_condition_1 (e, def_stmt, avail_exprs_stack,
+	    = simplify_control_stmt_condition_1 (e, def_stmt,
 						 rhs1, new_cond, rhs2,
-						 dummy_cond, simplify,
 						 limit - 1);
 	  if (res != NULL_TREE && is_gimple_min_invariant (res))
 	    return res;
@@ -738,7 +727,7 @@ simplify_control_stmt_condition_1 (edge e,
      then use the pass specific callback to simplify the condition.  */
   if (!res
       || !is_gimple_min_invariant (res))
-    res = (*simplify) (dummy_cond, stmt, avail_exprs_stack, e->src);
+    res = m_simplifier->simplify (dummy_cond, stmt, e->src);
 
   return res;
 }
@@ -887,18 +876,12 @@ propagate_threaded_block_debug_into (basic_block dest, basic_block src)
    returning TRUE from the toplevel call.   Otherwise do nothing and
    return false.
 
-   DUMMY_COND, SIMPLIFY are used to try and simplify the condition at the
-   end of TAKEN_EDGE->dest.
-
    The available expression table is referenced via AVAIL_EXPRS_STACK.  */
 
-static bool
-thread_around_empty_blocks (edge taken_edge,
-			    gcond *dummy_cond,
-			    class avail_exprs_stack *avail_exprs_stack,
-			    pfn_simplify simplify,
-			    bitmap visited,
-			    vec<jump_thread_edge *> *path)
+bool
+jump_threader::thread_around_empty_blocks (jump_thread_path *path,
+					   edge taken_edge,
+					   bitmap visited)
 {
   basic_block bb = taken_edge->dest;
   gimple_stmt_iterator gsi;
@@ -940,15 +923,11 @@ thread_around_empty_blocks (edge taken_edge,
 	  if (!bitmap_bit_p (visited, taken_edge->dest->index))
 	    {
 	      jump_thread_edge *x
-		= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);
+		= m_registry->allocate_thread_edge (taken_edge,
+						    EDGE_NO_COPY_SRC_BLOCK);
 	      path->safe_push (x);
 	      bitmap_set_bit (visited, taken_edge->dest->index);
-	      return thread_around_empty_blocks (taken_edge,
-						 dummy_cond,
-						 avail_exprs_stack,
-						 simplify,
-						 visited,
-						 path);
+	      return thread_around_empty_blocks (path, taken_edge, visited);
 	    }
 	}
 
@@ -965,9 +944,7 @@ thread_around_empty_blocks (edge taken_edge,
     return false;
 
   /* Extract and simplify the condition.  */
-  cond = simplify_control_stmt_condition (taken_edge, stmt,
-					  avail_exprs_stack, dummy_cond,
-					  simplify);
+  cond = simplify_control_stmt_condition (taken_edge, stmt);
 
   /* If the condition can be statically computed and we have not already
      visited the destination edge, then add the taken edge to our thread
@@ -990,15 +967,11 @@ thread_around_empty_blocks (edge taken_edge,
       bitmap_set_bit (visited, taken_edge->dest->index);
 
       jump_thread_edge *x
-	= new jump_thread_edge (taken_edge, EDGE_NO_COPY_SRC_BLOCK);
+	= m_registry->allocate_thread_edge (taken_edge,
+					    EDGE_NO_COPY_SRC_BLOCK);
       path->safe_push (x);
 
-      thread_around_empty_blocks (taken_edge,
-				  dummy_cond,
-				  avail_exprs_stack,
-				  simplify,
-				  visited,
-				  path);
+      thread_around_empty_blocks (path, taken_edge, visited);
       return true;
     }
 
@@ -1018,14 +991,9 @@ thread_around_empty_blocks (edge taken_edge,
    limited in that case to avoid short-circuiting the loop
    incorrectly.
 
-   DUMMY_COND is a shared cond_expr used by condition simplification as scratch,
-   to avoid allocating memory.
-
    STACK is used to undo temporary equivalences created during the walk of
    E->dest.
 
-   SIMPLIFY is a pass-specific function used to simplify statements.
-
    Our caller is responsible for restoring the state of the expression
    and const_and_copies stacks.
 
@@ -1034,34 +1002,23 @@ thread_around_empty_blocks (edge taken_edge,
    negative indicates the block should not be duplicated and thus is not
    suitable for a joiner in a jump threading path.  */
 
-static int
-thread_through_normal_block (edge e,
-			     gcond *dummy_cond,
-			     const_and_copies *const_and_copies,
-			     avail_exprs_stack *avail_exprs_stack,
-			     evrp_range_analyzer *evrp_range_analyzer,
-			     pfn_simplify simplify,
-			     vec<jump_thread_edge *> *path,
-			     bitmap visited)
+int
+jump_threader::thread_through_normal_block (jump_thread_path *path,
+					    edge e, bitmap visited)
 {
   /* We want to record any equivalences created by traversing E.  */
-  record_temporary_equivalences (e, const_and_copies, avail_exprs_stack);
+  record_temporary_equivalences (e, m_const_and_copies, m_avail_exprs_stack);
 
   /* PHIs create temporary equivalences.
      Note that if we found a PHI that made the block non-threadable, then
      we need to bubble that up to our caller in the same manner we do
      when we prematurely stop processing statements below.  */
-  if (!record_temporary_equivalences_from_phis (e, const_and_copies,
-					        evrp_range_analyzer))
+  if (!record_temporary_equivalences_from_phis (e))
     return -1;
 
   /* Now walk each statement recording any context sensitive
      temporary equivalences we can detect.  */
-  gimple *stmt
-    = record_temporary_equivalences_from_stmts_at_dest (e, const_and_copies,
-							avail_exprs_stack,
-							evrp_range_analyzer,
-							simplify);
+  gimple *stmt = record_temporary_equivalences_from_stmts_at_dest (e);
 
   /* There's two reasons STMT might be null, and distinguishing
      between them is important.
@@ -1098,8 +1055,7 @@ thread_through_normal_block (edge e,
       tree cond;
 
       /* Extract and simplify the condition.  */
-      cond = simplify_control_stmt_condition (e, stmt, avail_exprs_stack,
-					      dummy_cond, simplify);
+      cond = simplify_control_stmt_condition (e, stmt);
 
       if (!cond)
 	return 0;
@@ -1129,12 +1085,13 @@ thread_through_normal_block (edge e,
 	  if (path->length () == 0)
 	    {
               jump_thread_edge *x
-	        = new jump_thread_edge (e, EDGE_START_JUMP_THREAD);
+		= m_registry->allocate_thread_edge (e, EDGE_START_JUMP_THREAD);
 	      path->safe_push (x);
 	    }
 
 	  jump_thread_edge *x
-	    = new jump_thread_edge (taken_edge, EDGE_COPY_SRC_BLOCK);
+	    = m_registry->allocate_thread_edge (taken_edge,
+						EDGE_COPY_SRC_BLOCK);
 	  path->safe_push (x);
 
 	  /* See if we can thread through DEST as well, this helps capture
@@ -1145,12 +1102,7 @@ thread_through_normal_block (edge e,
  	     visited.  This may be overly conservative.  */
 	  bitmap_set_bit (visited, dest->index);
 	  bitmap_set_bit (visited, e->dest->index);
-	  thread_around_empty_blocks (taken_edge,
-				      dummy_cond,
-				      avail_exprs_stack,
-				      simplify,
-				      visited,
-				      path);
+	  thread_around_empty_blocks (path, taken_edge, visited);
 	  return 1;
 	}
     }
@@ -1220,48 +1172,28 @@ edge_forwards_cmp_to_conditional_jump_through_empty_bb_p (edge e)
 }
 
 /* We are exiting E->src, see if E->dest ends with a conditional
-   jump which has a known value when reached via E.
-
-   DUMMY_COND is a shared cond_expr used by condition simplification as scratch,
-   to avoid allocating memory.
-
-   CONST_AND_COPIES is used to undo temporary equivalences created during the
-   walk of E->dest.
-
-   The available expression table is referenced vai AVAIL_EXPRS_STACK.
+   jump which has a known value when reached via E.  */
 
-   SIMPLIFY is a pass-specific function used to simplify statements.  */
-
-static void
-thread_across_edge (gcond *dummy_cond,
-		    edge e,
-		    class const_and_copies *const_and_copies,
-		    class avail_exprs_stack *avail_exprs_stack,
-		    class evrp_range_analyzer *evrp_range_analyzer,
-		    pfn_simplify simplify)
+void
+jump_threader::thread_across_edge (edge e)
 {
   bitmap visited = BITMAP_ALLOC (NULL);
 
-  const_and_copies->push_marker ();
-  avail_exprs_stack->push_marker ();
-  if (evrp_range_analyzer)
-    evrp_range_analyzer->push_marker ();
+  m_const_and_copies->push_marker ();
+  m_avail_exprs_stack->push_marker ();
+  if (m_evrp_range_analyzer)
+    m_evrp_range_analyzer->push_marker ();
 
   stmt_count = 0;
 
-  vec<jump_thread_edge *> *path = new vec<jump_thread_edge *> ();
+  jump_thread_path *path = m_registry->allocate_thread_path ();
   bitmap_clear (visited);
   bitmap_set_bit (visited, e->src->index);
   bitmap_set_bit (visited, e->dest->index);
 
   int threaded;
   if ((e->flags & EDGE_DFS_BACK) == 0)
-    threaded = thread_through_normal_block (e, dummy_cond,
-					    const_and_copies,
-					    avail_exprs_stack,
-					    evrp_range_analyzer,
-					    simplify, path,
-					    visited);
+    threaded = thread_through_normal_block (path, e, visited);
   else
     threaded = 0;
 
@@ -1269,12 +1201,12 @@ thread_across_edge (gcond *dummy_cond,
     {
       propagate_threaded_block_debug_into (path->last ()->e->dest,
 					   e->dest);
-      const_and_copies->pop_to_marker ();
-      avail_exprs_stack->pop_to_marker ();
-      if (evrp_range_analyzer)
-	evrp_range_analyzer->pop_to_marker ();
+      m_const_and_copies->pop_to_marker ();
+      m_avail_exprs_stack->pop_to_marker ();
+      if (m_evrp_range_analyzer)
+	m_evrp_range_analyzer->pop_to_marker ();
       BITMAP_FREE (visited);
-      register_jump_thread (path);
+      m_registry->register_jump_thread (path);
       return;
     }
   else
@@ -1284,7 +1216,6 @@ thread_across_edge (gcond *dummy_cond,
 	 through the vector entries.  */
       gcc_assert (path->length () == 0);
       path->release ();
-      delete path;
 
       /* A negative status indicates the target block was deemed too big to
 	 duplicate.  Just quit now rather than trying to use the block as
@@ -1296,10 +1227,10 @@ thread_across_edge (gcond *dummy_cond,
       if (threaded < 0)
 	{
 	  BITMAP_FREE (visited);
-	  const_and_copies->pop_to_marker ();
-          avail_exprs_stack->pop_to_marker ();
-	  if (evrp_range_analyzer)
-	    evrp_range_analyzer->pop_to_marker ();
+	  m_const_and_copies->pop_to_marker ();
+	  m_avail_exprs_stack->pop_to_marker ();
+	  if (m_evrp_range_analyzer)
+	    m_evrp_range_analyzer->pop_to_marker ();
 	  return;
 	}
     }
@@ -1325,10 +1256,10 @@ thread_across_edge (gcond *dummy_cond,
     FOR_EACH_EDGE (taken_edge, ei, e->dest->succs)
       if (taken_edge->flags & EDGE_COMPLEX)
 	{
-	  const_and_copies->pop_to_marker ();
-          avail_exprs_stack->pop_to_marker ();
-	  if (evrp_range_analyzer)
-	    evrp_range_analyzer->pop_to_marker ();
+	  m_const_and_copies->pop_to_marker ();
+	  m_avail_exprs_stack->pop_to_marker ();
+	  if (m_evrp_range_analyzer)
+	    m_evrp_range_analyzer->pop_to_marker ();
 	  BITMAP_FREE (visited);
 	  return;
 	}
@@ -1342,39 +1273,32 @@ thread_across_edge (gcond *dummy_cond,
 
 	/* Push a fresh marker so we can unwind the equivalences created
 	   for each of E->dest's successors.  */
-	const_and_copies->push_marker ();
-	avail_exprs_stack->push_marker ();
-	if (evrp_range_analyzer)
-	  evrp_range_analyzer->push_marker ();
+	m_const_and_copies->push_marker ();
+	m_avail_exprs_stack->push_marker ();
+	if (m_evrp_range_analyzer)
+	  m_evrp_range_analyzer->push_marker ();
 
 	/* Avoid threading to any block we have already visited.  */
 	bitmap_clear (visited);
 	bitmap_set_bit (visited, e->src->index);
 	bitmap_set_bit (visited, e->dest->index);
 	bitmap_set_bit (visited, taken_edge->dest->index);
-        vec<jump_thread_edge *> *path = new vec<jump_thread_edge *> ();
+	jump_thread_path *path = m_registry->allocate_thread_path ();
 
 	/* Record whether or not we were able to thread through a successor
 	   of E->dest.  */
-        jump_thread_edge *x = new jump_thread_edge (e, EDGE_START_JUMP_THREAD);
+	jump_thread_edge *x
+	  = m_registry->allocate_thread_edge (e, EDGE_START_JUMP_THREAD);
 	path->safe_push (x);
 
-        x = new jump_thread_edge (taken_edge, EDGE_COPY_SRC_JOINER_BLOCK);
+	x = m_registry->allocate_thread_edge (taken_edge,
+					      EDGE_COPY_SRC_JOINER_BLOCK);
 	path->safe_push (x);
-	found = thread_around_empty_blocks (taken_edge,
-					    dummy_cond,
-					    avail_exprs_stack,
-					    simplify,
-					    visited,
-					    path);
+	found = thread_around_empty_blocks (path, taken_edge, visited);
 
 	if (!found)
-	  found = thread_through_normal_block (path->last ()->e, dummy_cond,
-					       const_and_copies,
-					       avail_exprs_stack,
-					       evrp_range_analyzer,
-					       simplify, path,
-					       visited) > 0;
+	  found = thread_through_normal_block (path,
+					       path->last ()->e, visited) > 0;
 
 	/* If we were able to thread through a successor of E->dest, then
 	   record the jump threading opportunity.  */
@@ -1384,47 +1308,31 @@ thread_across_edge (gcond *dummy_cond,
 	    if (taken_edge->dest != path->last ()->e->dest)
 	      propagate_threaded_block_debug_into (path->last ()->e->dest,
 						   taken_edge->dest);
-	    register_jump_thread (path);
+	    m_registry->register_jump_thread (path);
 	  }
 	else
-	  delete_jump_thread_path (path);
+	  path->release ();
 
 	/* And unwind the equivalence table.  */
-	if (evrp_range_analyzer)
-	  evrp_range_analyzer->pop_to_marker ();
-	avail_exprs_stack->pop_to_marker ();
-	const_and_copies->pop_to_marker ();
+	if (m_evrp_range_analyzer)
+	  m_evrp_range_analyzer->pop_to_marker ();
+	m_avail_exprs_stack->pop_to_marker ();
+	m_const_and_copies->pop_to_marker ();
       }
     BITMAP_FREE (visited);
   }
 
-  if (evrp_range_analyzer)
-    evrp_range_analyzer->pop_to_marker ();
-  const_and_copies->pop_to_marker ();
-  avail_exprs_stack->pop_to_marker ();
+  if (m_evrp_range_analyzer)
+    m_evrp_range_analyzer->pop_to_marker ();
+  m_const_and_copies->pop_to_marker ();
+  m_avail_exprs_stack->pop_to_marker ();
 }
 
 /* Examine the outgoing edges from BB and conditionally
-   try to thread them.
-
-   DUMMY_COND is a shared cond_expr used by condition simplification as scratch,
-   to avoid allocating memory.
-
-   CONST_AND_COPIES is used to undo temporary equivalences created during the
-   walk of E->dest.
-
-   The available expression table is referenced vai AVAIL_EXPRS_STACK.
-
-   SIMPLIFY is a pass-specific function used to simplify statements.  */
+   try to thread them.  */
 
 void
-thread_outgoing_edges (basic_block bb, gcond *dummy_cond,
-		       class const_and_copies *const_and_copies,
-		       class avail_exprs_stack *avail_exprs_stack,
-		       class evrp_range_analyzer *evrp_range_analyzer,
-		       tree (*simplify) (gimple *, gimple *,
-					 class avail_exprs_stack *,
-					 basic_block))
+jump_threader::thread_outgoing_edges (basic_block bb)
 {
   int flags = (EDGE_IGNORE | EDGE_COMPLEX | EDGE_ABNORMAL);
   gimple *last;
@@ -1437,9 +1345,7 @@ thread_outgoing_edges (basic_block bb, gcond *dummy_cond,
       && (single_succ_edge (bb)->flags & flags) == 0
       && potentially_threadable_block (single_succ (bb)))
     {
-      thread_across_edge (dummy_cond, single_succ_edge (bb),
-			  const_and_copies, avail_exprs_stack,
-			  evrp_range_analyzer, simplify);
+      thread_across_edge (single_succ_edge (bb));
     }
   else if ((last = last_stmt (bb))
 	   && gimple_code (last) == GIMPLE_COND
@@ -1454,14 +1360,53 @@ thread_outgoing_edges (basic_block bb, gcond *dummy_cond,
       /* Only try to thread the edge if it reaches a target block with
 	 more than one predecessor and more than one successor.  */
       if (potentially_threadable_block (true_edge->dest))
-	thread_across_edge (dummy_cond, true_edge,
-			    const_and_copies, avail_exprs_stack,
-			    evrp_range_analyzer, simplify);
+	thread_across_edge (true_edge);
 
       /* Similarly for the ELSE arm.  */
       if (potentially_threadable_block (false_edge->dest))
-	thread_across_edge (dummy_cond, false_edge,
-			    const_and_copies, avail_exprs_stack,
-			    evrp_range_analyzer, simplify);
+	thread_across_edge (false_edge);
+    }
+}
+
+tree
+jump_threader_simplifier::simplify (gimple *stmt,
+				    gimple *within_stmt,
+				    basic_block)
+{
+  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))
+    {
+      simplify_using_ranges simplifier (m_vr_values);
+      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),
+						  gimple_cond_lhs (cond_stmt),
+						  gimple_cond_rhs (cond_stmt),
+						  within_stmt);
+    }
+  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))
+    {
+      tree op = gimple_switch_index (switch_stmt);
+      if (TREE_CODE (op) != SSA_NAME)
+	return NULL_TREE;
+
+      const value_range_equiv *vr = m_vr_values->get_value_range (op);
+      return find_case_label_range (switch_stmt, vr);
+    }
+   if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))
+    {
+      tree lhs = gimple_assign_lhs (assign_stmt);
+      if (TREE_CODE (lhs) == SSA_NAME
+	  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))
+	      || POINTER_TYPE_P (TREE_TYPE (lhs)))
+	  && stmt_interesting_for_vrp (stmt))
+	{
+	  edge dummy_e;
+	  tree dummy_tree;
+	  value_range_equiv new_vr;
+	  m_vr_values->extract_range_from_stmt (stmt, &dummy_e, &dummy_tree,
+						&new_vr);
+	  tree singleton;
+	  if (new_vr.singleton_p (&singleton))
+	    return singleton;
+	}
     }
+   return NULL;
 }
diff --git a/gcc/tree-ssa-threadedge.h b/gcc/tree-ssa-threadedge.h
index 6b305152379..32e5e5eead8 100644
--- a/gcc/tree-ssa-threadedge.h
+++ b/gcc/tree-ssa-threadedge.h
@@ -20,22 +20,80 @@ along with GCC; see the file COPYING3.  If not see
 #ifndef GCC_TREE_SSA_THREADEDGE_H
 #define GCC_TREE_SSA_THREADEDGE_H
 
+// This is the high level threader.  The entry point is
+// thread_outgoing_edges(), which calculates and registers paths to be
+// threaded.  When all candidates have been registered,
+// thread_through_all_blocks() is called to actually change the CFG.
+
+class jump_threader
+{
+public:
+  jump_threader (class const_and_copies *,
+		 avail_exprs_stack *,
+		 class jump_threader_simplifier *,
+		 class evrp_range_analyzer * = NULL);
+  ~jump_threader ();
+  void thread_outgoing_edges (basic_block);
+  void remove_jump_threads_including (edge_def *);
+  bool thread_through_all_blocks (bool may_peel_loop_headers);
+
+private:
+  tree simplify_control_stmt_condition (edge, gimple *);
+  tree simplify_control_stmt_condition_1 (edge,
+					  gimple *,
+					  tree op0,
+					  tree_code cond_code,
+					  tree op1,
+					  unsigned limit);
+
+  bool thread_around_empty_blocks (class jump_thread_path *path,
+				   edge, bitmap visited);
+  int thread_through_normal_block (jump_thread_path *path,
+				   edge, bitmap visited);
+  void thread_across_edge (edge);
+  bool record_temporary_equivalences_from_phis (edge);
+  gimple *record_temporary_equivalences_from_stmts_at_dest (edge);
+
+  // Dummy condition to avoid creating lots of throw away statements.
+  gcond *dummy_cond;
+
+  const_and_copies *m_const_and_copies;
+  avail_exprs_stack *m_avail_exprs_stack;
+  class jump_thread_path_registry *m_registry;
+  jump_threader_simplifier *m_simplifier;
+  evrp_range_analyzer *m_evrp_range_analyzer;
+};
+
+// Statement simplifier callback for the jump threader.
+
+class jump_threader_simplifier
+{
+public:
+  jump_threader_simplifier (class vr_values *v,
+			    avail_exprs_stack *avails)
+    : m_vr_values (v),
+      m_avail_exprs_stack (avails)
+  { }
+  virtual ~jump_threader_simplifier () { }
+  virtual tree simplify (gimple *, gimple *, basic_block);
+
+protected:
+  vr_values *m_vr_values;
+  avail_exprs_stack *m_avail_exprs_stack;
+};
+
+extern void propagate_threaded_block_debug_into (basic_block, basic_block);
+
+// ?? All this ssa_name_values stuff is the store of values for
+// avail_exprs_stack and const_and_copies, so it really belongs in the
+// jump_threader class.  However, it's probably not worth touching
+// this, since all this windable state is slated to go with the
+// ranger.
 extern vec<tree> ssa_name_values;
 #define SSA_NAME_VALUE(x) \
     (SSA_NAME_VERSION (x) < ssa_name_values.length () \
      ? ssa_name_values[SSA_NAME_VERSION (x)] \
      : NULL_TREE)
 extern void set_ssa_name_value (tree, tree);
-extern void threadedge_initialize_values (void);
-extern void threadedge_finalize_values (void);
-extern bool potentially_threadable_block (basic_block);
-extern void propagate_threaded_block_debug_into (basic_block, basic_block);
-class evrp_range_analyzer;
-extern void thread_outgoing_edges (basic_block, gcond *,
-				   const_and_copies *,
-				   avail_exprs_stack *,
-				   evrp_range_analyzer *,
-				   tree (*) (gimple *, gimple *,
-					     avail_exprs_stack *, basic_block));
 
 #endif /* GCC_TREE_SSA_THREADEDGE_H */
diff --git a/gcc/tree-ssa-threadupdate.c b/gcc/tree-ssa-threadupdate.c
index 5abecf6c295..8133e69b7e2 100644
--- a/gcc/tree-ssa-threadupdate.c
+++ b/gcc/tree-ssa-threadupdate.c
@@ -128,8 +128,7 @@ struct redirection_data : free_ptr_hash<redirection_data>
      which they appear in the jump thread path.  */
   basic_block dup_blocks[2];
 
-  /* The jump threading path.  */
-  vec<jump_thread_edge *> *path;
+  jump_thread_path *path;
 
   /* A list of incoming edges which we want to thread to the
      same path.  */
@@ -140,44 +139,101 @@ struct redirection_data : free_ptr_hash<redirection_data>
   static inline int equal (const redirection_data *, const redirection_data *);
 };
 
+jump_thread_path_allocator::jump_thread_path_allocator ()
+{
+  obstack_init (&m_obstack);
+}
+
+jump_thread_path_allocator::~jump_thread_path_allocator ()
+{
+  obstack_free (&m_obstack, NULL);
+}
+
+jump_thread_edge *
+jump_thread_path_allocator::allocate_thread_edge (edge e,
+						  jump_thread_edge_type type)
+{
+  void *r = obstack_alloc (&m_obstack, sizeof (jump_thread_edge));
+  return new (r) jump_thread_edge (e, type);
+}
+
+jump_thread_path *
+jump_thread_path_allocator::allocate_thread_path ()
+{
+  void *r = obstack_alloc (&m_obstack, sizeof (jump_thread_path));
+  return new (r) jump_thread_path ();
+}
+
+jump_thread_path_registry::jump_thread_path_registry ()
+{
+  m_paths.create (5);
+  m_removed_edges = new hash_table<struct removed_edges> (17);
+  m_num_threaded_edges = 0;
+  m_redirection_data = NULL;
+}
+
+jump_thread_path_registry::~jump_thread_path_registry ()
+{
+  m_paths.release ();
+  delete m_removed_edges;
+}
+
+jump_thread_edge *
+jump_thread_path_registry::allocate_thread_edge (edge e,
+						 jump_thread_edge_type t)
+{
+  return m_allocator.allocate_thread_edge (e, t);
+}
+
+jump_thread_path *
+jump_thread_path_registry::allocate_thread_path ()
+{
+  return m_allocator.allocate_thread_path ();
+}
+
 /* Dump a jump threading path, including annotations about each
    edge in the path.  */
 
-static void
-dump_jump_thread_path (FILE *dump_file, vec<jump_thread_edge *> path,
-		       bool registering)
+void
+jump_thread_path::dump (FILE *dump_file, bool registering)
 {
   fprintf (dump_file,
 	   "  %s%s jump thread: (%d, %d) incoming edge; ",
 	   (registering ? "Registering" : "Cancelling"),
-	   (path[0]->type == EDGE_FSM_THREAD ? " FSM": ""),
-	   path[0]->e->src->index, path[0]->e->dest->index);
+	   (m_path[0]->type == EDGE_FSM_THREAD ? " FSM": ""),
+	   m_path[0]->e->src->index, m_path[0]->e->dest->index);
 
-  for (unsigned int i = 1; i < path.length (); i++)
+  for (unsigned int i = 1; i < m_path.length (); i++)
     {
       /* We can get paths with a NULL edge when the final destination
 	 of a jump thread turns out to be a constant address.  We dump
 	 those paths when debugging, so we have to be prepared for that
 	 possibility here.  */
-      if (path[i]->e == NULL)
+      if (m_path[i]->e == NULL)
 	continue;
 
-      if (path[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)
+      if (m_path[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)
 	fprintf (dump_file, " (%d, %d) joiner; ",
-		 path[i]->e->src->index, path[i]->e->dest->index);
-      if (path[i]->type == EDGE_COPY_SRC_BLOCK)
+		 m_path[i]->e->src->index, m_path[i]->e->dest->index);
+      if (m_path[i]->type == EDGE_COPY_SRC_BLOCK)
        fprintf (dump_file, " (%d, %d) normal;",
-		 path[i]->e->src->index, path[i]->e->dest->index);
-      if (path[i]->type == EDGE_NO_COPY_SRC_BLOCK)
+		 m_path[i]->e->src->index, m_path[i]->e->dest->index);
+      if (m_path[i]->type == EDGE_NO_COPY_SRC_BLOCK)
        fprintf (dump_file, " (%d, %d) nocopy;",
-		 path[i]->e->src->index, path[i]->e->dest->index);
-      if (path[0]->type == EDGE_FSM_THREAD)
+		 m_path[i]->e->src->index, m_path[i]->e->dest->index);
+      if (m_path[0]->type == EDGE_FSM_THREAD)
 	fprintf (dump_file, " (%d, %d) ",
-		 path[i]->e->src->index, path[i]->e->dest->index);
+		 m_path[i]->e->src->index, m_path[i]->e->dest->index);
     }
   fputc ('\n', dump_file);
 }
 
+void
+jump_thread_path::dump (FILE *f)
+{
+  dump (f, true);
+}
+
 /* Simple hashing function.  For any given incoming edge E, we're going
    to be most concerned with the final destination of its jump thread
    path.  So hash on the block index of the final edge in the path.  */
@@ -185,7 +241,7 @@ dump_jump_thread_path (FILE *dump_file, vec<jump_thread_edge *> path,
 inline hashval_t
 redirection_data::hash (const redirection_data *p)
 {
-  vec<jump_thread_edge *> *path = p->path;
+  jump_thread_path *path = p->path;
   return path->last ()->e->dest->index;
 }
 
@@ -194,8 +250,8 @@ redirection_data::hash (const redirection_data *p)
 inline int
 redirection_data::equal (const redirection_data *p1, const redirection_data *p2)
 {
-  vec<jump_thread_edge *> *path1 = p1->path;
-  vec<jump_thread_edge *> *path2 = p2->path;
+  jump_thread_path *path1 = p1->path;
+  jump_thread_path *path2 = p2->path;
 
   if (path1->length () != path2->length ())
     return false;
@@ -210,18 +266,6 @@ redirection_data::equal (const redirection_data *p1, const redirection_data *p2)
   return true;
 }
 
-/* Rather than search all the edges in jump thread paths each time
-   DOM is able to simply if control statement, we build a hash table
-   with the deleted edges.  We only care about the address of the edge,
-   not its contents.  */
-struct removed_edges : nofree_ptr_hash<edge_def>
-{
-  static hashval_t hash (edge e) { return htab_hash_pointer (e); }
-  static bool equal (edge e1, edge e2) { return e1 == e2; }
-};
-
-static hash_table<removed_edges> *removed_edges;
-
 /* Data structure of information to pass to hash table traversal routines.  */
 struct ssa_local_info_t
 {
@@ -251,34 +295,21 @@ struct ssa_local_info_t
      final destinations, then we may need to correct for potential
      profile insanities.  */
   bool need_profile_correction;
-};
 
-/* Passes which use the jump threading code register jump threading
-   opportunities as they are discovered.  We keep the registered
-   jump threading opportunities in this vector as edge pairs
-   (original_edge, target_edge).  */
-static vec<vec<jump_thread_edge *> *> paths;
+  // Jump threading statistics.
+  unsigned long num_threaded_edges;
+};
 
 /* When we start updating the CFG for threading, data necessary for jump
    threading is attached to the AUX field for the incoming edge.  Use these
    macros to access the underlying structure attached to the AUX field.  */
-#define THREAD_PATH(E) ((vec<jump_thread_edge *> *)(E)->aux)
-
-/* Jump threading statistics.  */
-
-struct thread_stats_d
-{
-  unsigned long num_threaded_edges;
-};
-
-struct thread_stats_d thread_stats;
-
+#define THREAD_PATH(E) ((jump_thread_path *)(E)->aux)
 
 /* Remove the last statement in block BB if it is a control statement
    Also remove all outgoing edges except the edge which reaches DEST_BB.
    If DEST_BB is NULL, then remove all outgoing edges.  */
 
-void
+static void
 remove_ctrl_stmt_and_useless_edges (basic_block bb, basic_block dest_bb)
 {
   gimple_stmt_iterator gsi;
@@ -360,22 +391,19 @@ create_block_for_threading (basic_block bb,
     bitmap_set_bit (*duplicate_blocks, rd->dup_blocks[count]->index);
 }
 
-/* Main data structure to hold information for duplicates of BB.  */
-
-static hash_table<redirection_data> *redirection_data;
-
 /* Given an outgoing edge E lookup and return its entry in our hash table.
 
    If INSERT is true, then we insert the entry into the hash table if
    it is not already present.  INCOMING_EDGE is added to the list of incoming
    edges associated with E in the hash table.  */
 
-static struct redirection_data *
-lookup_redirection_data (edge e, enum insert_option insert)
+redirection_data *
+jump_thread_path_registry::lookup_redirection_data (edge e,
+						    enum insert_option insert)
 {
   struct redirection_data **slot;
   struct redirection_data *elt;
-  vec<jump_thread_edge *> *path = THREAD_PATH (e);
+  jump_thread_path *path = THREAD_PATH (e);
 
   /* Build a hash table element so we can see if E is already
      in the table.  */
@@ -385,7 +413,7 @@ lookup_redirection_data (edge e, enum insert_option insert)
   elt->dup_blocks[1] = NULL;
   elt->incoming_edges = NULL;
 
-  slot = redirection_data->find_slot (elt, insert);
+  slot = m_redirection_data->find_slot (elt, insert);
 
   /* This will only happen if INSERT is false and the entry is not
      in the hash table.  */
@@ -460,7 +488,7 @@ copy_phi_arg_into_existing_phi (edge src_e, edge tgt_e)
    Return DEF directly if either PATH or idx is ZERO.  */
 
 static tree
-get_value_locus_in_path (tree def, vec<jump_thread_edge *> *path,
+get_value_locus_in_path (tree def, jump_thread_path *path,
 			 basic_block bb, int idx, location_t *locus)
 {
   tree arg;
@@ -506,7 +534,7 @@ get_value_locus_in_path (tree def, vec<jump_thread_edge *> *path,
 
 static void
 copy_phi_args (basic_block bb, edge src_e, edge tgt_e,
-	       vec<jump_thread_edge *> *path, int idx)
+	       jump_thread_path *path, int idx)
 {
   gphi_iterator gsi;
   int src_indx = src_e->dest_idx;
@@ -535,7 +563,7 @@ copy_phi_args (basic_block bb, edge src_e, edge tgt_e,
 
 static void
 update_destination_phis (basic_block orig_bb, basic_block new_bb,
-			 vec<jump_thread_edge *> *path, int idx)
+			 jump_thread_path *path, int idx)
 {
   edge_iterator ei;
   edge e;
@@ -592,7 +620,7 @@ create_edge_and_update_destination_phis (struct redirection_data *rd,
    any additional blocks that need to be duplicated.  Otherwise,
    return FALSE.  */
 static bool
-any_remaining_duplicated_blocks (vec<jump_thread_edge *> *path,
+any_remaining_duplicated_blocks (jump_thread_path *path,
 				 unsigned int start)
 {
   for (unsigned int i = start + 1; i < path->length (); i++)
@@ -710,7 +738,7 @@ compute_path_counts (struct redirection_data *rd,
 		     profile_count *path_out_count_ptr)
 {
   edge e = rd->incoming_edges->e;
-  vec<jump_thread_edge *> *path = THREAD_PATH (e);
+  jump_thread_path *path = THREAD_PATH (e);
   edge elast = path->last ()->e;
   profile_count nonpath_count = profile_count::zero ();
   bool has_joiner = false;
@@ -743,7 +771,7 @@ compute_path_counts (struct redirection_data *rd,
   edge_iterator ei;
   FOR_EACH_EDGE (ein, ei, e->dest->preds)
     {
-      vec<jump_thread_edge *> *ein_path = THREAD_PATH (ein);
+      jump_thread_path *ein_path = THREAD_PATH (ein);
       /* Simply check the incoming edge src against the set captured above.  */
       if (ein_path
 	  && bitmap_bit_p (in_edge_srcs, (*ein_path)[0]->e->src->index))
@@ -958,7 +986,7 @@ ssa_fix_duplicate_block_edges (struct redirection_data *rd,
 {
   bool multi_incomings = (rd->incoming_edges->next != NULL);
   edge e = rd->incoming_edges->e;
-  vec<jump_thread_edge *> *path = THREAD_PATH (e);
+  jump_thread_path *path = THREAD_PATH (e);
   edge elast = path->last ()->e;
   profile_count path_in_count = profile_count::zero ();
   profile_count path_out_count = profile_count::zero ();
@@ -1111,7 +1139,7 @@ ssa_create_duplicates (struct redirection_data **slot,
      Note the search starts with the third edge on the path.  The first
      edge is the incoming edge, the second edge always has its source
      duplicated.  Thus we start our search with the third edge.  */
-  vec<jump_thread_edge *> *path = rd->path;
+  jump_thread_path *path = rd->path;
   for (unsigned int i = 2; i < path->length (); i++)
     {
       if ((*path)[i]->type == EDGE_COPY_SRC_BLOCK
@@ -1253,7 +1281,7 @@ ssa_fixup_template_block (struct redirection_data **slot,
 /* Hash table traversal callback to redirect each incoming edge
    associated with this hash table element to its new destination.  */
 
-int
+static int
 ssa_redirect_edges (struct redirection_data **slot,
 		    ssa_local_info_t *local_info)
 {
@@ -1265,7 +1293,7 @@ ssa_redirect_edges (struct redirection_data **slot,
   for (el = rd->incoming_edges; el; el = next)
     {
       edge e = el->e;
-      vec<jump_thread_edge *> *path = THREAD_PATH (e);
+      jump_thread_path *path = THREAD_PATH (e);
 
       /* Go ahead and free this element from the list.  Doing this now
 	 avoids the need for another list walk when we destroy the hash
@@ -1273,7 +1301,7 @@ ssa_redirect_edges (struct redirection_data **slot,
       next = el->next;
       free (el);
 
-      thread_stats.num_threaded_edges++;
+      local_info->num_threaded_edges++;
 
       if (rd->dup_blocks[0])
 	{
@@ -1292,7 +1320,7 @@ ssa_redirect_edges (struct redirection_data **slot,
 
       /* Go ahead and clear E->aux.  It's not needed anymore and failure
 	 to clear it will cause all kinds of unpleasant problems later.  */
-      delete_jump_thread_path (path);
+      path->release ();
       e->aux = NULL;
 
     }
@@ -1356,8 +1384,10 @@ redirection_block_p (basic_block bb)
 
    If JOINERS is true, then thread through joiner blocks as well.  */
 
-static bool
-thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
+bool
+jump_thread_path_registry::thread_block_1 (basic_block bb,
+					   bool noloop_only,
+					   bool joiners)
 {
   /* E is an incoming edge into BB that we may or may not want to
      redirect to a duplicate of BB.  */
@@ -1367,12 +1397,13 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
 
   local_info.duplicate_blocks = BITMAP_ALLOC (NULL);
   local_info.need_profile_correction = false;
+  local_info.num_threaded_edges = 0;
 
   /* To avoid scanning a linear array for the element we need we instead
      use a hash table.  For normal code there should be no noticeable
      difference.  However, if we have a block with a large number of
      incoming and outgoing edges such linear searches can get expensive.  */
-  redirection_data
+  m_redirection_data
     = new hash_table<struct redirection_data> (EDGE_COUNT (bb->succs));
 
   /* Record each unique threaded destination into a hash table for
@@ -1383,7 +1414,7 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
       if (e->aux == NULL)
 	continue;
 
-      vec<jump_thread_edge *> *path = THREAD_PATH (e);
+      jump_thread_path *path = THREAD_PATH (e);
 
       if (((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK && !joiners)
 	  || ((*path)[1]->type == EDGE_COPY_SRC_BLOCK && joiners))
@@ -1407,7 +1438,7 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
 	      /* Since this case is not handled by our special code
 		 to thread through a loop header, we must explicitly
 		 cancel the threading request here.  */
-	      delete_jump_thread_path (path);
+	      path->release ();
 	      e->aux = NULL;
 	      continue;
 	    }
@@ -1446,7 +1477,7 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
 
 	      if (i != path->length ())
 		{
-		  delete_jump_thread_path (path);
+		  path->release ();
 		  e->aux = NULL;
 		  continue;
 		}
@@ -1491,7 +1522,7 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
   local_info.template_block = NULL;
   local_info.bb = bb;
   local_info.jumps_threaded = false;
-  redirection_data->traverse <ssa_local_info_t *, ssa_create_duplicates>
+  m_redirection_data->traverse <ssa_local_info_t *, ssa_create_duplicates>
 			    (&local_info);
 
   /* The template does not have an outgoing edge.  Create that outgoing
@@ -1499,19 +1530,19 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
 
      We do this after creating all the duplicates to avoid creating
      unnecessary edges.  */
-  redirection_data->traverse <ssa_local_info_t *, ssa_fixup_template_block>
+  m_redirection_data->traverse <ssa_local_info_t *, ssa_fixup_template_block>
 			    (&local_info);
 
   /* The hash table traversals above created the duplicate blocks (and the
      statements within the duplicate blocks).  This loop creates PHI nodes for
      the duplicated blocks and redirects the incoming edges into BB to reach
      the duplicates of BB.  */
-  redirection_data->traverse <ssa_local_info_t *, ssa_redirect_edges>
+  m_redirection_data->traverse <ssa_local_info_t *, ssa_redirect_edges>
 			    (&local_info);
 
   /* Done with this block.  Clear REDIRECTION_DATA.  */
-  delete redirection_data;
-  redirection_data = NULL;
+  delete m_redirection_data;
+  m_redirection_data = NULL;
 
   if (noloop_only
       && bb == bb->loop_father->header)
@@ -1520,6 +1551,8 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
   BITMAP_FREE (local_info.duplicate_blocks);
   local_info.duplicate_blocks = NULL;
 
+  m_num_threaded_edges += local_info.num_threaded_edges;
+
   /* Indicate to our caller whether or not any jumps were threaded.  */
   return local_info.jumps_threaded;
 }
@@ -1532,8 +1565,8 @@ thread_block_1 (basic_block bb, bool noloop_only, bool joiners)
    not worry that copying a joiner block will create a jump threading
    opportunity.  */
 
-static bool
-thread_block (basic_block bb, bool noloop_only)
+bool
+jump_thread_path_registry::thread_block (basic_block bb, bool noloop_only)
 {
   bool retval;
   retval = thread_block_1 (bb, noloop_only, false);
@@ -1613,8 +1646,10 @@ determine_bb_domination_status (class loop *loop, basic_block bb)
    If MAY_PEEL_LOOP_HEADERS is false, we avoid threading from entry edges
    to the inside of the loop.  */
 
-static bool
-thread_through_loop_header (class loop *loop, bool may_peel_loop_headers)
+bool
+jump_thread_path_registry::thread_through_loop_header
+				(class loop *loop,
+				 bool may_peel_loop_headers)
 {
   basic_block header = loop->header;
   edge e, tgt_edge, latch = loop_latch_edge (loop);
@@ -1710,7 +1745,7 @@ thread_through_loop_header (class loop *loop, bool may_peel_loop_headers)
 	      goto fail;
 	    }
 
-	  vec<jump_thread_edge *> *path = THREAD_PATH (e);
+	  jump_thread_path *path = THREAD_PATH (e);
 
 	  if ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)
 	    goto fail;
@@ -1797,11 +1832,11 @@ fail:
   /* We failed to thread anything.  Cancel the requests.  */
   FOR_EACH_EDGE (e, ei, header->preds)
     {
-      vec<jump_thread_edge *> *path = THREAD_PATH (e);
+      jump_thread_path *path = THREAD_PATH (e);
 
       if (path)
 	{
-	  delete_jump_thread_path (path);
+	  path->release ();
 	  e->aux = NULL;
 	}
     }
@@ -1868,8 +1903,8 @@ count_stmts_and_phis_in_block (basic_block bb)
    discover blocks which need processing and avoids unnecessary
    hash table lookups to map from threaded edge to new target.  */
 
-static void
-mark_threaded_blocks (bitmap threaded_blocks)
+void
+jump_thread_path_registry::mark_threaded_blocks (bitmap threaded_blocks)
 {
   unsigned int i;
   bitmap_iterator bi;
@@ -1892,9 +1927,9 @@ mark_threaded_blocks (bitmap threaded_blocks)
 
      So first convert the jump thread requests which do not require a
      joiner block.  */
-  for (i = 0; i < paths.length (); i++)
+  for (i = 0; i < m_paths.length (); i++)
     {
-      vec<jump_thread_edge *> *path = paths[i];
+      jump_thread_path *path = m_paths[i];
 
       if (path->length () > 1
 	  && (*path)[1]->type != EDGE_COPY_SRC_JOINER_BLOCK)
@@ -1913,9 +1948,9 @@ mark_threaded_blocks (bitmap threaded_blocks)
      cases where the second path starts at a downstream edge on the same
      path).  First record all joiner paths, deleting any in the unexpected
      case where there is already a path for that incoming edge.  */
-  for (i = 0; i < paths.length ();)
+  for (i = 0; i < m_paths.length ();)
     {
-      vec<jump_thread_edge *> *path = paths[i];
+      jump_thread_path *path = m_paths[i];
 
       if (path->length () > 1
 	  && (*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK)
@@ -1928,10 +1963,10 @@ mark_threaded_blocks (bitmap threaded_blocks)
 	    }
 	  else
 	    {
-	      paths.unordered_remove (i);
+	      m_paths.unordered_remove (i);
 	      if (dump_file && (dump_flags & TDF_DETAILS))
-		dump_jump_thread_path (dump_file, *path, false);
-	      delete_jump_thread_path (path);
+		path->dump (dump_file, false);
+	      path->release ();
 	    }
 	}
       else
@@ -1942,9 +1977,9 @@ mark_threaded_blocks (bitmap threaded_blocks)
 
   /* Second, look for paths that have any other jump thread attached to
      them, and either finish converting them or cancel them.  */
-  for (i = 0; i < paths.length ();)
+  for (i = 0; i < m_paths.length ();)
     {
-      vec<jump_thread_edge *> *path = paths[i];
+      jump_thread_path *path = m_paths[i];
       edge e = (*path)[0]->e;
 
       if (path->length () > 1
@@ -1965,10 +2000,10 @@ mark_threaded_blocks (bitmap threaded_blocks)
 	  else
 	    {
 	      e->aux = NULL;
-	      paths.unordered_remove (i);
+	      m_paths.unordered_remove (i);
 	      if (dump_file && (dump_flags & TDF_DETAILS))
-		dump_jump_thread_path (dump_file, *path, false);
-	      delete_jump_thread_path (path);
+		path->dump (dump_file, false);
+	      path->release ();
 	    }
 	}
       else
@@ -1997,7 +2032,7 @@ mark_threaded_blocks (bitmap threaded_blocks)
 	  FOR_EACH_EDGE (e, ei, BASIC_BLOCK_FOR_FN (cfun, i)->preds)
 	    if (e->aux)
 	      {
-		vec<jump_thread_edge *> *path = THREAD_PATH (e);
+		jump_thread_path *path = THREAD_PATH (e);
 
 		unsigned int j;
 		for (j = 1; j < path->length (); j++)
@@ -2015,8 +2050,8 @@ mark_threaded_blocks (bitmap threaded_blocks)
 		if (j != path->length ())
 		  {
 		    if (dump_file && (dump_flags & TDF_DETAILS))
-		      dump_jump_thread_path (dump_file, *path, 0);
-		    delete_jump_thread_path (path);
+		      path->dump (dump_file, false);
+		    path->release ();
 		    e->aux = NULL;
 		  }
 		else
@@ -2051,7 +2086,7 @@ mark_threaded_blocks (bitmap threaded_blocks)
 	{
 	  if (e->aux)
 	    {
-	      vec<jump_thread_edge *> *path = THREAD_PATH (e);
+	      jump_thread_path *path = THREAD_PATH (e);
 	      bool have_joiner = ((*path)[1]->type == EDGE_COPY_SRC_JOINER_BLOCK);
 
 	      if (have_joiner)
@@ -2063,7 +2098,7 @@ mark_threaded_blocks (bitmap threaded_blocks)
 
 		  if (e2 && !phi_args_equal_on_edges (e2, final_edge))
 		    {
-		      delete_jump_thread_path (path);
+		      path->release ();
 		      e->aux = NULL;
 		    }
 		}
@@ -2083,7 +2118,7 @@ mark_threaded_blocks (bitmap threaded_blocks)
 	{
 	  if (e->aux)
 	    {
-	      vec<jump_thread_edge *> *path = THREAD_PATH (e);
+	      jump_thread_path *path = THREAD_PATH (e);
 
 	      for (unsigned int i = 0, crossed_headers = 0;
 		   i < path->length ();
@@ -2137,10 +2172,10 @@ bb_in_bbs (basic_block bb, basic_block *bbs, int n)
   return false;
 }
 
-DEBUG_FUNCTION void
-debug_path (FILE *dump_file, int pathno)
+void
+jump_thread_path_registry::debug_path (FILE *dump_file, int pathno)
 {
-  vec<jump_thread_edge *> *p = paths[pathno];
+  jump_thread_path *p = m_paths[pathno];
   fprintf (dump_file, "path: ");
   for (unsigned i = 0; i < p->length (); ++i)
     fprintf (dump_file, "%d -> %d, ",
@@ -2148,10 +2183,10 @@ debug_path (FILE *dump_file, int pathno)
   fprintf (dump_file, "\n");
 }
 
-DEBUG_FUNCTION void
-debug_all_paths ()
+void
+jump_thread_path_registry::dump ()
 {
-  for (unsigned i = 0; i < paths.length (); ++i)
+  for (unsigned i = 0; i < m_paths.length (); ++i)
     debug_path (stderr, i);
 }
 
@@ -2163,10 +2198,11 @@ debug_all_paths ()
 
    Returns TRUE if we were able to successfully rewire the edge.  */
 
-static bool
-rewire_first_differing_edge (unsigned path_num, unsigned edge_num)
+bool
+jump_thread_path_registry::rewire_first_differing_edge (unsigned path_num,
+							unsigned edge_num)
 {
-  vec<jump_thread_edge *> *path = paths[path_num];
+  jump_thread_path *path = m_paths[path_num];
   edge &e = (*path)[edge_num]->e;
   if (dump_file && (dump_flags & TDF_DETAILS))
     fprintf (dump_file, "rewiring edge candidate: %d -> %d\n",
@@ -2208,10 +2244,11 @@ rewire_first_differing_edge (unsigned path_num, unsigned edge_num)
    CURR_PATH_NUM is an index into the global paths table.  It
    specifies the path that was just threaded.  */
 
-static void
-adjust_paths_after_duplication (unsigned curr_path_num)
+void
+jump_thread_path_registry::adjust_paths_after_duplication
+	(unsigned curr_path_num)
 {
-  vec<jump_thread_edge *> *curr_path = paths[curr_path_num];
+  jump_thread_path *curr_path = m_paths[curr_path_num];
   gcc_assert ((*curr_path)[0]->type == EDGE_FSM_THREAD);
 
   if (dump_file && (dump_flags & TDF_DETAILS))
@@ -2221,7 +2258,7 @@ adjust_paths_after_duplication (unsigned curr_path_num)
     }
 
   /* Iterate through all the other paths and adjust them.  */
-  for (unsigned cand_path_num = 0; cand_path_num < paths.length (); )
+  for (unsigned cand_path_num = 0; cand_path_num < m_paths.length (); )
     {
       if (cand_path_num == curr_path_num)
 	{
@@ -2230,7 +2267,7 @@ adjust_paths_after_duplication (unsigned curr_path_num)
 	}
       /* Make sure the candidate to adjust starts with the same path
 	 as the recently threaded path and is an FSM thread.  */
-      vec<jump_thread_edge *> *cand_path = paths[cand_path_num];
+      jump_thread_path *cand_path = m_paths[cand_path_num];
       if ((*cand_path)[0]->type != EDGE_FSM_THREAD
 	  || (*cand_path)[0]->e != (*curr_path)[0]->e)
 	{
@@ -2284,8 +2321,8 @@ adjust_paths_after_duplication (unsigned curr_path_num)
 	    remove_candidate_from_list:
 	      if (dump_file && (dump_flags & TDF_DETAILS))
 		fprintf (dump_file, "adjusted candidate: [EMPTY]\n");
-	      delete_jump_thread_path (cand_path);
-	      paths.unordered_remove (cand_path_num);
+	      cand_path->release ();
+	      m_paths.unordered_remove (cand_path_num);
 	      continue;
 	    }
 	  /* Otherwise, just remove the redundant sub-path.  */
@@ -2312,9 +2349,12 @@ adjust_paths_after_duplication (unsigned curr_path_num)
 
    Returns false if it is unable to copy the region, true otherwise.  */
 
-static bool
-duplicate_thread_path (edge entry, edge exit, basic_block *region,
-		       unsigned n_region, unsigned current_path_no)
+bool
+jump_thread_path_registry::duplicate_thread_path (edge entry,
+						  edge exit,
+						  basic_block *region,
+						  unsigned n_region,
+						  unsigned current_path_no)
 {
   unsigned i;
   class loop *loop = entry->dest->loop_father;
@@ -2468,7 +2508,7 @@ duplicate_thread_path (edge entry, edge exit, basic_block *region,
 /* Return true when PATH is a valid jump-thread path.  */
 
 static bool
-valid_jump_thread_path (vec<jump_thread_edge *> *path)
+valid_jump_thread_path (jump_thread_path *path)
 {
   unsigned len = path->length ();
 
@@ -2489,15 +2529,12 @@ valid_jump_thread_path (vec<jump_thread_edge *> *path)
    DOM/VRP rather than for every case where DOM optimizes away a COND_EXPR.  */
 
 void
-remove_jump_threads_including (edge_def *e)
+jump_thread_path_registry::remove_jump_threads_including (edge_def *e)
 {
-  if (!paths.exists ())
+  if (!m_paths.exists ())
     return;
 
-  if (!removed_edges)
-    removed_edges = new hash_table<struct removed_edges> (17);
-
-  edge *slot = removed_edges->find_slot (e, INSERT);
+  edge *slot = m_removed_edges->find_slot (e, INSERT);
   *slot = e;
 }
 
@@ -2513,7 +2550,8 @@ remove_jump_threads_including (edge_def *e)
    Returns true if one or more edges were threaded, false otherwise.  */
 
 bool
-thread_through_all_blocks (bool may_peel_loop_headers)
+jump_thread_path_registry::thread_through_all_blocks
+	(bool may_peel_loop_headers)
 {
   bool retval = false;
   unsigned int i;
@@ -2521,41 +2559,41 @@ thread_through_all_blocks (bool may_peel_loop_headers)
   auto_bitmap threaded_blocks;
   hash_set<edge> visited_starting_edges;
 
-  if (!paths.exists ())
+  if (!m_paths.exists ())
     {
       retval = false;
       goto out;
     }
 
-  memset (&thread_stats, 0, sizeof (thread_stats));
+  m_num_threaded_edges = 0;
 
   /* Remove any paths that referenced removed edges.  */
-  if (removed_edges)
-    for (i = 0; i < paths.length (); )
+  if (m_removed_edges)
+    for (i = 0; i < m_paths.length (); )
       {
 	unsigned int j;
-	vec<jump_thread_edge *> *path = paths[i];
+	jump_thread_path *path = m_paths[i];
 
 	for (j = 0; j < path->length (); j++)
 	  {
 	    edge e = (*path)[j]->e;
-	    if (removed_edges->find_slot (e, NO_INSERT))
+	    if (m_removed_edges->find_slot (e, NO_INSERT))
 	      break;
 	  }
 
 	if (j != path->length ())
 	  {
-	    delete_jump_thread_path (path);
-	    paths.unordered_remove (i);
+	    path->release ();
+	    m_paths.unordered_remove (i);
 	    continue;
 	  }
 	i++;
       }
 
   /* Jump-thread all FSM threads before other jump-threads.  */
-  for (i = 0; i < paths.length ();)
+  for (i = 0; i < m_paths.length ();)
     {
-      vec<jump_thread_edge *> *path = paths[i];
+      jump_thread_path *path = m_paths[i];
       edge entry = (*path)[0]->e;
 
       /* Only code-generate FSM jump-threads in this loop.  */
@@ -2579,8 +2617,8 @@ thread_through_all_blocks (bool may_peel_loop_headers)
 	  || !valid_jump_thread_path (path))
 	{
 	  /* Remove invalid FSM jump-thread paths.  */
-	  delete_jump_thread_path (path);
-	  paths.unordered_remove (i);
+	  path->release ();
+	  m_paths.unordered_remove (i);
 	  continue;
 	}
 
@@ -2597,26 +2635,26 @@ thread_through_all_blocks (bool may_peel_loop_headers)
 	  free_dominance_info (CDI_DOMINATORS);
 	  visited_starting_edges.add (entry);
 	  retval = true;
-	  thread_stats.num_threaded_edges++;
+	  m_num_threaded_edges++;
 	}
 
-      delete_jump_thread_path (path);
-      paths.unordered_remove (i);
+      path->release ();
+      m_paths.unordered_remove (i);
       free (region);
     }
 
   /* Remove from PATHS all the jump-threads starting with an edge already
      jump-threaded.  */
-  for (i = 0; i < paths.length ();)
+  for (i = 0; i < m_paths.length ();)
     {
-      vec<jump_thread_edge *> *path = paths[i];
+      jump_thread_path *path = m_paths[i];
       edge entry = (*path)[0]->e;
 
       /* Do not jump-thread twice from the same block.  */
       if (visited_starting_edges.contains (entry))
 	{
-	  delete_jump_thread_path (path);
-	  paths.unordered_remove (i);
+	  path->release ();
+	  m_paths.unordered_remove (i);
 	}
       else
 	i++;
@@ -2678,34 +2716,19 @@ thread_through_all_blocks (bool may_peel_loop_headers)
 	gcc_assert (e->aux == NULL);
     }
 
-  statistics_counter_event (cfun, "Jumps threaded",
-			    thread_stats.num_threaded_edges);
+  statistics_counter_event (cfun, "Jumps threaded", m_num_threaded_edges);
 
   free_original_copy_tables ();
 
-  paths.release ();
+  m_paths.release ();
 
   if (retval)
     loops_state_set (LOOPS_NEED_FIXUP);
 
  out:
-  delete removed_edges;
-  removed_edges = NULL;
   return retval;
 }
 
-/* Delete the jump threading path PATH.  We have to explicitly delete
-   each entry in the vector, then the container.  */
-
-void
-delete_jump_thread_path (vec<jump_thread_edge *> *path)
-{
-  for (unsigned int i = 0; i < path->length (); i++)
-    delete (*path)[i];
-  path->release();
-  delete path;
-}
-
 /* Register a jump threading opportunity.  We queue up all the jump
    threading opportunities discovered by a pass and update the CFG
    and SSA form all at once.
@@ -2715,11 +2738,11 @@ delete_jump_thread_path (vec<jump_thread_edge *> *path)
    after fixing the SSA graph.  */
 
 void
-register_jump_thread (vec<jump_thread_edge *> *path)
+jump_thread_path_registry::register_jump_thread (jump_thread_path *path)
 {
   if (!dbg_cnt (registered_jump_thread))
     {
-      delete_jump_thread_path (path);
+      path->release ();
       return;
     }
 
@@ -2733,10 +2756,10 @@ register_jump_thread (vec<jump_thread_edge *> *path)
 	    {
 	      fprintf (dump_file,
 		       "Found NULL edge in jump threading path.  Cancelling jump thread:\n");
-	      dump_jump_thread_path (dump_file, *path, false);
+	      path->dump (dump_file, false);
 	    }
 
-	  delete_jump_thread_path (path);
+	  path->release ();
 	  return;
 	}
 
@@ -2748,12 +2771,9 @@ register_jump_thread (vec<jump_thread_edge *> *path)
     }
 
   if (dump_file && (dump_flags & TDF_DETAILS))
-    dump_jump_thread_path (dump_file, *path, true);
-
-  if (!paths.exists ())
-    paths.create (5);
+    path->dump (dump_file, true);
 
-  paths.safe_push (path);
+  m_paths.safe_push (path);
 }
 
 /* Return how many uses of T there are within BB, as long as there
diff --git a/gcc/tree-ssa-threadupdate.h b/gcc/tree-ssa-threadupdate.h
index 38192246a99..5af69535f8f 100644
--- a/gcc/tree-ssa-threadupdate.h
+++ b/gcc/tree-ssa-threadupdate.h
@@ -21,8 +21,6 @@ along with GCC; see the file COPYING3.  If not see
 #ifndef _TREE_SSA_THREADUPDATE_H
 #define _TREE_SSA_THREADUPDATE_H 1
 
-/* In tree-ssa-threadupdate.c.  */
-extern bool thread_through_all_blocks (bool);
 enum jump_thread_edge_type
 {
   EDGE_START_JUMP_THREAD,
@@ -32,21 +30,150 @@ enum jump_thread_edge_type
   EDGE_NO_COPY_SRC_BLOCK
 };
 
+// We keep the registered jump threading opportunities in this
+// vector as edge pairs (original_edge, target_edge).
+
 class jump_thread_edge
 {
 public:
-  jump_thread_edge (edge e, enum jump_thread_edge_type type)
-    : e (e), type (type) {}
+  jump_thread_edge (edge e, jump_thread_edge_type t) : e (e), type (t) {}
 
   edge e;
-  enum jump_thread_edge_type type;
+  jump_thread_edge_type type;
+};
+
+class jump_thread_path
+{
+public:
+  jump_thread_path ();
+  jump_thread_edge *&operator[] (int);
+  jump_thread_edge *last ();
+  void safe_push (jump_thread_edge *);
+  unsigned length ();
+  void dump (FILE *, bool registering);
+  void dump (FILE *);
+  void block_remove (unsigned ix, unsigned len);
+  // ?? Is this method really necessary?  I mean, the pointers in
+  // m_path live in an obstack that gets automatically cleaned up.  So
+  // technically we'd only leave the container up for the GC to
+  // cleanup.  I've changed this method to a NOP with no adverse
+  // effects.
+  void release ();
+
+private:
+  DISABLE_COPY_AND_ASSIGN (jump_thread_path);
+  vec<jump_thread_edge *> m_path;
+};
+
+class jump_thread_path_allocator
+{
+public:
+  jump_thread_path_allocator ();
+  ~jump_thread_path_allocator ();
+  jump_thread_edge *allocate_thread_edge (edge, jump_thread_edge_type);
+  jump_thread_path *allocate_thread_path ();
+private:
+  DISABLE_COPY_AND_ASSIGN (jump_thread_path_allocator);
+  obstack m_obstack;
+};
+
+// This is the underlying jump thread registry.  When all candidates
+// have been registered with register_jump_thread(),
+// thread_through_all_blocks() is called to actually change the CFG.
+
+class jump_thread_path_registry
+{
+public:
+  jump_thread_path_registry ();
+  ~jump_thread_path_registry ();
+  void register_jump_thread (jump_thread_path *);
+  void remove_jump_threads_including (edge);
+  bool thread_through_all_blocks (bool);
+  jump_thread_edge *allocate_thread_edge (edge e, jump_thread_edge_type t);
+  jump_thread_path *allocate_thread_path ();
+  void dump ();
+
+private:
+  void debug_path (FILE *, int pathno);
+  void mark_threaded_blocks (bitmap threaded_blocks);
+  bool rewire_first_differing_edge (unsigned path_num, unsigned edge_num);
+  void adjust_paths_after_duplication (unsigned curr_path_num);
+  bool duplicate_thread_path (edge entry,
+			      edge exit,
+			      basic_block *region,
+			      unsigned n_region,
+			      unsigned current_path_no);
+  bool thread_block_1 (basic_block, bool noloop_only, bool joiners);
+  bool thread_block (basic_block, bool noloop_only);
+  bool thread_through_loop_header (class loop *loop,
+				   bool may_peel_loop_headers);
+  class redirection_data *lookup_redirection_data (edge e, enum insert_option);
+
+  vec<jump_thread_path *> m_paths;
+
+  hash_table<struct removed_edges> *m_removed_edges;
+
+  // Main data structure to hold information for duplicates of BB.
+  hash_table<redirection_data> *m_redirection_data;
+
+  // Jump threading statistics.
+  unsigned long m_num_threaded_edges;
+
+  jump_thread_path_allocator m_allocator;
+};
+
+inline
+jump_thread_path::jump_thread_path ()
+{
+  m_path.create (5);
+}
+
+inline jump_thread_edge *&
+jump_thread_path::operator[] (int i)
+{
+  return m_path[i];
+}
+
+inline jump_thread_edge *
+jump_thread_path::last ()
+{
+  return m_path.last ();
+}
+
+inline void
+jump_thread_path::safe_push (jump_thread_edge *e)
+{
+  m_path.safe_push (e);
+}
+
+inline unsigned
+jump_thread_path::length ()
+{
+  return m_path.length ();
+}
+
+inline void
+jump_thread_path::block_remove (unsigned ix, unsigned len)
+{
+  return m_path.block_remove (ix, len);
+}
+
+inline void
+jump_thread_path::release ()
+{
+  m_path.release ();
+}
+
+// Rather than search all the edges in jump thread paths each time DOM
+// is able to simply if control statement, we build a hash table with
+// the deleted edges.  We only care about the address of the edge, not
+// its contents.
+struct removed_edges : nofree_ptr_hash<edge_def>
+{
+  static hashval_t hash (edge e) { return htab_hash_pointer (e); }
+  static bool equal (edge e1, edge e2) { return e1 == e2; }
 };
 
-extern void register_jump_thread (vec <class jump_thread_edge *> *);
-extern void remove_jump_threads_including (edge);
-extern void delete_jump_thread_path (vec <class jump_thread_edge *> *);
-extern void remove_ctrl_stmt_and_useless_edges (basic_block, basic_block);
-extern void free_dom_edge_info (edge);
 extern unsigned int estimate_threading_killed_stmts (basic_block);
 
 enum bb_dom_status
@@ -61,4 +188,7 @@ enum bb_dom_status
 
 enum bb_dom_status determine_bb_domination_status (class loop *, basic_block);
 
+// In tree-ssa-dom.c.
+extern void free_dom_edge_info (edge);
+
 #endif
diff --git a/gcc/tree-vrp.c b/gcc/tree-vrp.c
index d661866630e..68a6cfa7eb1 100644
--- a/gcc/tree-vrp.c
+++ b/gcc/tree-vrp.c
@@ -2365,9 +2365,6 @@ lhs_of_dominating_assert (tree op, basic_block bb, gimple *stmt)
   return op;
 }
 
-/* A hack.  */
-static class vr_values *x_vr_values;
-
 /* Searches the case label vector VEC for the index *IDX of the CASE_LABEL
    that includes the value VAL.  The search is restricted to the range
    [START_IDX, n - 1] where n is the size of VEC.
@@ -4155,6 +4152,54 @@ vrp_folder::fold_stmt (gimple_stmt_iterator *si)
   return simplifier.simplify (si);
 }
 
+class vrp_jump_threader_simplifier : public jump_threader_simplifier
+{
+public:
+  vrp_jump_threader_simplifier (vr_values *v, avail_exprs_stack *avails)
+    : jump_threader_simplifier (v, avails) {}
+
+private:
+  tree simplify (gimple *, gimple *, basic_block) OVERRIDE;
+};
+
+tree
+vrp_jump_threader_simplifier::simplify (gimple *stmt,
+					gimple *within_stmt,
+					basic_block bb)
+{
+  /* First see if the conditional is in the hash table.  */
+  tree cached_lhs = m_avail_exprs_stack->lookup_avail_expr (stmt, false, true);
+  if (cached_lhs && is_gimple_min_invariant (cached_lhs))
+    return cached_lhs;
+
+  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))
+    {
+      tree op0 = gimple_cond_lhs (cond_stmt);
+      op0 = lhs_of_dominating_assert (op0, bb, stmt);
+
+      tree op1 = gimple_cond_rhs (cond_stmt);
+      op1 = lhs_of_dominating_assert (op1, bb, stmt);
+
+      simplify_using_ranges simplifier (m_vr_values);
+      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),
+						  op0, op1, within_stmt);
+    }
+
+  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))
+    {
+      tree op = gimple_switch_index (switch_stmt);
+      if (TREE_CODE (op) != SSA_NAME)
+	return NULL_TREE;
+
+      op = lhs_of_dominating_assert (op, bb, stmt);
+
+      const value_range_equiv *vr = m_vr_values->get_value_range (op);
+      return find_case_label_range (switch_stmt, vr);
+    }
+
+  return jump_threader_simplifier::simplify (stmt, within_stmt, bb);
+}
+
 /* Blocks which have more than one predecessor and more than
    one successor present jump threading opportunities, i.e.,
    when the block is reached from a specific predecessor, we
@@ -4178,7 +4223,7 @@ vrp_folder::fold_stmt (gimple_stmt_iterator *si)
 class vrp_jump_threader : public dom_walker
 {
 public:
-  vrp_jump_threader (struct function *, vr_values *);
+  vrp_jump_threader (function *, vr_values *);
   ~vrp_jump_threader ();
 
   void thread_jumps ()
@@ -4186,9 +4231,13 @@ public:
     walk (m_fun->cfg->x_entry_block_ptr);
   }
 
+  void thread_through_all_blocks ()
+  {
+    // FIXME: Put this in the destructor?
+    m_threader->thread_through_all_blocks (false);
+  }
+
 private:
-  static tree simplify_stmt (gimple *stmt, gimple *within_stmt,
-			     avail_exprs_stack *, basic_block);
   virtual edge before_dom_children (basic_block);
   virtual void after_dom_children (basic_block);
 
@@ -4197,7 +4246,8 @@ private:
   const_and_copies *m_const_and_copies;
   avail_exprs_stack *m_avail_exprs_stack;
   hash_table<expr_elt_hasher> *m_avail_exprs;
-  gcond *m_dummy_cond;
+  vrp_jump_threader_simplifier *m_simplifier;
+  jump_threader *m_threader;
 };
 
 vrp_jump_threader::vrp_jump_threader (struct function *fun, vr_values *v)
@@ -4219,11 +4269,15 @@ vrp_jump_threader::vrp_jump_threader (struct function *fun, vr_values *v)
      that might be recorded.  */
   m_const_and_copies = new const_and_copies ();
 
-  m_dummy_cond = NULL;
   m_fun = fun;
   m_vr_values = v;
   m_avail_exprs = new hash_table<expr_elt_hasher> (1024);
   m_avail_exprs_stack = new avail_exprs_stack (m_avail_exprs);
+
+  m_simplifier = new vrp_jump_threader_simplifier (m_vr_values,
+						   m_avail_exprs_stack);
+  m_threader = new jump_threader (m_const_and_copies, m_avail_exprs_stack,
+				  m_simplifier);
 }
 
 vrp_jump_threader::~vrp_jump_threader ()
@@ -4234,6 +4288,8 @@ vrp_jump_threader::~vrp_jump_threader ()
   delete m_const_and_copies;
   delete m_avail_exprs;
   delete m_avail_exprs_stack;
+  delete m_simplifier;
+  delete m_threader;
 }
 
 /* Called before processing dominator children of BB.  We want to look
@@ -4276,89 +4332,12 @@ vrp_jump_threader::before_dom_children (basic_block bb)
   return NULL;
 }
 
-/* A trivial wrapper so that we can present the generic jump threading
-   code with a simple API for simplifying statements.  STMT is the
-   statement we want to simplify, WITHIN_STMT provides the location
-   for any overflow warnings.
-
-   ?? This should be cleaned up.  There's a virtually identical copy
-   of this function in tree-ssa-dom.c.  */
-
-tree
-vrp_jump_threader::simplify_stmt (gimple *stmt,
-				  gimple *within_stmt,
-				  avail_exprs_stack *avail_exprs_stack,
-				  basic_block bb)
-{
-  /* First see if the conditional is in the hash table.  */
-  tree cached_lhs = avail_exprs_stack->lookup_avail_expr (stmt, false, true);
-  if (cached_lhs && is_gimple_min_invariant (cached_lhs))
-    return cached_lhs;
-
-  class vr_values *vr_values = x_vr_values;
-  if (gcond *cond_stmt = dyn_cast <gcond *> (stmt))
-    {
-      tree op0 = gimple_cond_lhs (cond_stmt);
-      op0 = lhs_of_dominating_assert (op0, bb, stmt);
-
-      tree op1 = gimple_cond_rhs (cond_stmt);
-      op1 = lhs_of_dominating_assert (op1, bb, stmt);
-
-      simplify_using_ranges simplifier (vr_values);
-      return simplifier.vrp_evaluate_conditional (gimple_cond_code (cond_stmt),
-						  op0, op1, within_stmt);
-    }
-
-  if (gswitch *switch_stmt = dyn_cast <gswitch *> (stmt))
-    {
-      tree op = gimple_switch_index (switch_stmt);
-      if (TREE_CODE (op) != SSA_NAME)
-	return NULL_TREE;
-
-      op = lhs_of_dominating_assert (op, bb, stmt);
-
-      const value_range_equiv *vr = vr_values->get_value_range (op);
-      return find_case_label_range (switch_stmt, vr);
-    }
-
-  if (gassign *assign_stmt = dyn_cast <gassign *> (stmt))
-    {
-      tree lhs = gimple_assign_lhs (assign_stmt);
-      if (TREE_CODE (lhs) == SSA_NAME
-	  && (INTEGRAL_TYPE_P (TREE_TYPE (lhs))
-	      || POINTER_TYPE_P (TREE_TYPE (lhs)))
-	  && stmt_interesting_for_vrp (stmt))
-	{
-	  edge dummy_e;
-	  tree dummy_tree;
-	  value_range_equiv new_vr;
-	  vr_values->extract_range_from_stmt (stmt, &dummy_e,
-					      &dummy_tree, &new_vr);
-	  tree singleton;
-	  if (new_vr.singleton_p (&singleton))
-	    return singleton;
-	}
-    }
-
-  return NULL_TREE;
-}
-
 /* Called after processing dominator children of BB.  This is where we
    actually call into the threader.  */
 void
 vrp_jump_threader::after_dom_children (basic_block bb)
 {
-  if (!m_dummy_cond)
-    m_dummy_cond = gimple_build_cond (NE_EXPR,
-				      integer_zero_node, integer_zero_node,
-				      NULL, NULL);
-
-  x_vr_values = m_vr_values;
-  thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,
-			 m_avail_exprs_stack, NULL,
-			 simplify_stmt);
-  x_vr_values = NULL;
-
+  m_threader->thread_outgoing_edges (bb);
   m_avail_exprs_stack->pop_to_marker ();
   m_const_and_copies->pop_to_marker ();
 }
@@ -4481,8 +4460,6 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)
   vrp_asserts assert_engine (fun);
   assert_engine.insert_range_assertions ();
 
-  threadedge_initialize_values ();
-
   /* For visiting PHI nodes we need EDGE_DFS_BACK computed.  */
   mark_dfs_back_edges ();
 
@@ -4558,9 +4535,7 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)
 
      Note the SSA graph update will occur during the normal TODO
      processing by the pass manager.  */
-  thread_through_all_blocks (false);
-
-  threadedge_finalize_values ();
+  threader.thread_through_all_blocks ();
 
   scev_finalize ();
   loop_optimizer_finalize ();
