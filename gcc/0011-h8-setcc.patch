diff --git a/gcc/config/h8300/h8300.md b/gcc/config/h8300/h8300.md
index 89bfcf11126..e81e21b103e 100644
--- a/gcc/config/h8300/h8300.md
+++ b/gcc/config/h8300/h8300.md
@@ -223,6 +223,7 @@
 (define_mode_iterator HSI [HI SI])
 
 (define_mode_iterator QHSI [QI HI SI])
+(define_mode_iterator QHSI2 [QI HI SI])
 
 (define_mode_iterator QHSIF [QI HI SI SF])
 
diff --git a/gcc/config/h8300/testcompare.md b/gcc/config/h8300/testcompare.md
index 9ff7a51077e..eb68bebada9 100644
--- a/gcc/config/h8300/testcompare.md
+++ b/gcc/config/h8300/testcompare.md
@@ -61,6 +61,15 @@
   "mov.b	%t0,%t0"
   [(set_attr "length" "2")])
 
+(define_insn "*tsthi_upper_z"
+  [(set (reg:CCZ CC_REG)
+	(compare (and:HI (match_operand:HI 0 "register_operand" "r")
+			 (const_int -256))
+		 (const_int 0)))]
+  "reload_completed"
+  "mov.b	%t0,%t0"
+  [(set_attr "length" "2")])
+
 (define_insn "*tstsi_upper"
   [(set (reg:CCZN CC_REG)
 	(compare (and:SI (match_operand:SI 0 "register_operand" "r")
@@ -70,6 +79,15 @@
   "mov.w	%e0,%e0"
   [(set_attr "length" "2")])
 
+(define_insn "*tstsi_upper_z"
+  [(set (reg:CCZ CC_REG)
+	(compare (and:SI (match_operand:SI 0 "register_operand" "r")
+			 (const_int -65536))
+		 (const_int 0)))]
+  "reload_completed"
+  "mov.w	%e0,%e0"
+  [(set_attr "length" "2")])
+
 (define_insn "*cmp<mode>_c"
   [(set (reg:CCC CC_REG)
 	(ltu (match_operand:QHSI 0 "h8300_dst_operand" "rQ")
@@ -86,6 +104,22 @@
   }
   [(set_attr "length_table" "add")])
 
+(define_insn "*cmp<mode>_z"
+  [(set (reg:CCZ CC_REG)
+	(ne (match_operand:QHSI 0 "h8300_dst_operand" "rQ")
+	    (match_operand:QHSI 1 "h8300_src_operand" "rQi")))]
+  "reload_completed"
+  {
+    if (<MODE>mode == QImode)
+      return "cmp.b	%X1,%X0";
+    else if (<MODE>mode == HImode)
+      return "cmp.w	%T1,%T0";
+    else if (<MODE>mode == SImode)
+      return "cmp.l	%S1,%S0";
+    gcc_unreachable ();
+  }
+  [(set_attr "length_table" "add")])
+
 (define_insn "*cmpqi"
   [(set (reg:CC CC_REG)
 	(compare (match_operand:QI 0 "h8300_dst_operand" "rQ")
@@ -224,3 +258,72 @@
 	(ltu:CCC (match_dup 1) (match_dup 2)))
    (set (match_dup 0)
 	(<geultu_to_c>:QHSI (reg:CCC CC_REG) (const_int 0)))])
+
+;; Using the Z bit is more difficult than the C bit as we only have
+;; stc to get the data from the condition code regsiter into a GPR.
+;; But that copies a bunch of stuff we don't need and the Z bit is not
+;; at a convenient location.  So we have to mask and shift which
+;; increases the cost.
+(define_insn "*store_z_<mode>"
+  [(set (match_operand:QHSI 0 "register_operand" "=r")
+	(ne:QHSI (reg:CCZ CC_REG) (const_int 0)))]
+  "TARGET_H8300S && reload_completed"
+  {
+    if (<MODE>mode == QImode)
+      return "stc\tccr,%X0\;shlr.b\t#2,%X0\;and.b\t#1,%X0";
+    else if (<MODE>mode == HImode)
+      return "stc\tccr,%X0\;shlr.b\t#2,%X0\;and.w\t#1,%T0";
+    else if (<MODE>mode == SImode)
+      return "stc\tccr,%X0\;shlr.b\t#2,%X0\;and.l\t#1,%S0";
+    gcc_unreachable ();
+  }
+  [(set (attr "length") (symbol_ref "(<MODE>mode == SImode
+				      ? 10 : <MODE>mode == HImode ? 8 : 6)"))])
+
+(define_insn_and_split "*store_z"
+  [(set (match_operand:QHSI2 0 "register_operand" "=r")
+	(ne:QHSI2 (match_operand:QHSI 1 "register_operand" "r")
+		  (match_operand:QHSI 2 "register_operand" "r")))]
+  "TARGET_H8300S"
+  "#"
+  "&& reload_completed"
+  [(set (reg:CCZ CC_REG)
+	(ne:CCZ (match_dup 1) (match_dup 2)))
+   (set (match_dup 0)
+	(ne:QHSI2 (reg:CCZ CC_REG) (const_int 0)))])
+
+;; We can test the upper byte of a HImode register and the upper word
+;; of a SImode register
+(define_insn_and_split "*store_z"
+  [(set (match_operand:QHSI2 0 "register_operand" "=r")
+	(ne:QHSI2 (and:HI (match_operand:HI 1 "register_operand" "r")
+			  (const_int -256))
+		  (const_int 0)))]
+  "TARGET_H8300S"
+  "#"
+  "&& reload_completed"
+  [(set (reg:CCZ CC_REG)
+	(compare (and:HI (match_dup 1) (const_int -256))
+		 (const_int 0)))
+   (set (match_dup 0)
+	(ne:QHSI2 (reg:CCZ CC_REG) (const_int 0)))])
+
+(define_insn_and_split "*store_z"
+  [(set (match_operand:QHSI2 0 "register_operand" "=r")
+	(ne:QHSI2 (and:SI (match_operand:SI 1 "register_operand" "r")
+			  (const_int -65536))
+		  (const_int 0)))]
+  "TARGET_H8300S"
+  "#"
+  "&& reload_completed"
+  [(set (reg:CCZ CC_REG)
+	(compare (and:SI (match_dup 1) (const_int -65536))
+		 (const_int 0)))
+   (set (match_dup 0)
+	(ne:QHSI2 (reg:CCZ CC_REG) (const_int 0)))])
+
+;; We could probably handle N on the H8/SX, but there's a richer set of
+;; primitives to work with on the H8/SX, so a different approach may be
+;; warranted.  It might be advantageous to handle N on H8/S, but it's hard
+;; to see how it would be profitable on the older models given the need
+;; to shift 3 positions.
