commit 99879f0bc425ed61b81d5574d20202aec249021a
Author: Jeff Law <law@redhat.com>
Date:   Mon Mar 9 08:41:59 2020 -0600

    Handle BIT_FIELD_REF which feeds a masking BIT_AND

diff --git a/gcc/tree-ssa-forwprop.c b/gcc/tree-ssa-forwprop.c
index f65216d23e9..0c0a77d13f9 100644
--- a/gcc/tree-ssa-forwprop.c
+++ b/gcc/tree-ssa-forwprop.c
@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see
 #include "vec-perm-indices.h"
 #include "internal-fn.h"
 #include "cgraph.h"
+#include "convert.h"
 
 /* This pass propagates the RHS of assignment statements into use
    sites of the LHS of the assignment.  It's basically a specialized
@@ -2568,6 +2569,90 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)
   return true;
 }
 
+/* Simplify a BIT_AND_EXPR statement pointed to by GSI if it was fed
+   by a BIT_FIELD_REF and just masks off upper bits.
+
+   Simplification results in changing the type of the feeding BIT_FIELD_REF
+   and performing a NOP conversion to the ultimate desination.  */
+
+static bool
+simplify_bit_and_expr (gimple_stmt_iterator gsi)
+{
+  gimple *stmt = gsi_stmt (gsi);
+  tree rhs1 = gimple_assign_rhs1 (stmt);
+  tree rhs2 = gimple_assign_rhs2 (stmt);
+
+  /* We already know we have a BIT_AND_EXPR, so verify the code of both
+     operands to ensure it's SSA_NAME & LOW_MASK.  Also verify the resultant
+     type is an unsigned integral type.  */
+  if (TREE_CODE (rhs1) == SSA_NAME
+      && TREE_CODE (rhs2) == INTEGER_CST
+      && INTEGRAL_TYPE_P (TREE_TYPE (rhs1))
+      && TYPE_UNSIGNED (TREE_TYPE (rhs1))
+      && pow2p_hwi (int_cst_value (rhs2) + 1))
+    {
+      /* Now verify the first operand was set from a BIT_FIELD_REF.  */
+      gimple *def = SSA_NAME_DEF_STMT (rhs1);
+      if (def
+	  && is_gimple_assign (def)
+	  && has_single_use (rhs1)
+	  && gimple_assign_rhs_code (def) == BIT_FIELD_REF)
+	{
+	  tree field = gimple_assign_rhs1 (def);
+	  /* Verify the size of the reference is constant.  */
+	  if (TREE_CODE (TREE_OPERAND (field, 1)) == INTEGER_CST)
+	    {
+	      /* While we have a has_single_use check, that returns true if
+		 there is a single real use, even if there's other uses in
+		 debug statements.  So fix those up.  Do this before adjusting
+		 the real statements.  */
+	      imm_use_iterator iter;
+	      gimple *use_stmt;
+	      FOR_EACH_IMM_USE_STMT (use_stmt, iter, rhs1)
+		{
+		  if (is_gimple_debug (use_stmt))
+		    {
+		      if (gimple_debug_bind_p (use_stmt))
+			{
+			  gimple_debug_bind_reset_value (use_stmt);
+			  update_stmt (use_stmt);
+			}
+		      continue;
+		    }
+		}
+
+	      /* We know we have a low order bitmask.  Adding one, then
+		 counting the number of trailing zeros should give us
+		 the size of the field we want to extract.  */
+	      HOST_WIDE_INT new_size = int_cst_value (rhs2) + 1;
+	      new_size = wi::ctz (new_size);
+
+	      /* We're going to need to change the type of the BIT_FIELD_REF,
+		 this is the new type to use.  We're also going to change the
+		 LHS of the BIT_FIELD_REF to a new SSA_NAME of the appropriate
+		 type.  */
+	      tree new_type = make_unsigned_type (new_size);
+	      tree new_lhs = make_ssa_name (new_type);
+
+	      /* Now install the changes to the BIT_FIELD_REF.  */
+	      TREE_OPERAND (field, 1)
+		= build_int_cst (TREE_TYPE (TREE_OPERAND (field, 1)), new_size);
+	      TREE_TYPE (field) = new_type;
+	      gimple_assign_set_lhs (def, new_lhs);
+	      update_stmt (def);
+
+	      /* And replace STMT (the BIT_AND_EXPR) with a NOP conversion.  */
+	      tree conversion = convert_to_integer (TREE_TYPE (rhs1), new_lhs);
+	      gimple_assign_set_rhs_from_tree (&gsi, conversion);
+	      update_stmt (stmt);
+	      return true;
+	    }
+	}
+    }
+  return false;
+}
+
+
 
 /* Primitive "lattice" function for gimple_simplify.  */
 
@@ -3091,6 +3176,8 @@ pass_forwprop::execute (function *fun)
 		      changed = simplify_vector_constructor (&gsi);
 		    else if (code == ARRAY_REF)
 		      changed = simplify_count_trailing_zeroes (&gsi);
+		    else if (code == BIT_AND_EXPR)
+		      changed = simplify_bit_and_expr (gsi);
 		    break;
 		  }
 
